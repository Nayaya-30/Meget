import * as Lt from "react";
import kc, { useReducer as pO, useRef as fr, useEffect as Hs, useLayoutEffect as IC, useDebugValue as mO, useState as qp, useMemo as zc, createContext as ah, useContext as rs, useInsertionEffect as FC, useCallback as pM, forwardRef as vO, createElement as gO, useId as TE, cloneElement as yO, Children as xO, isValidElement as _O } from "react";
import SO from "react-dom";
function MO(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var mM = { exports: {} }, Ap = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lw;
function EO() {
  if (Lw) return Ap;
  Lw = 1;
  var i = kc, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, r = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(u, d, h) {
    var m, g = {}, y = null, _ = null;
    h !== void 0 && (y = "" + h), d.key !== void 0 && (y = "" + d.key), d.ref !== void 0 && (_ = d.ref);
    for (m in d) n.call(d, m) && !o.hasOwnProperty(m) && (g[m] = d[m]);
    if (u && u.defaultProps) for (m in d = u.defaultProps, d) g[m] === void 0 && (g[m] = d[m]);
    return { $$typeof: e, type: u, key: y, ref: _, props: g, _owner: r.current };
  }
  return Ap.Fragment = t, Ap.jsx = l, Ap.jsxs = l, Ap;
}
var Rp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dw;
function bO() {
  return Dw || (Dw = 1, process.env.NODE_ENV !== "production" && function() {
    var i = kc, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), u = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), m = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), _ = Symbol.for("react.offscreen"), E = Symbol.iterator, w = "@@iterator";
    function T($) {
      if ($ === null || typeof $ != "object")
        return null;
      var ke = E && $[E] || $[w];
      return typeof ke == "function" ? ke : null;
    }
    var M = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function C($) {
      {
        for (var ke = arguments.length, vt = new Array(ke > 1 ? ke - 1 : 0), Ft = 1; Ft < ke; Ft++)
          vt[Ft - 1] = arguments[Ft];
        A("error", $, vt);
      }
    }
    function A($, ke, vt) {
      {
        var Ft = M.ReactDebugCurrentFrame, xn = Ft.getStackAddendum();
        xn !== "" && (ke += "%s", vt = vt.concat([xn]));
        var hn = vt.map(function(k) {
          return String(k);
        });
        hn.unshift("Warning: " + ke), Function.prototype.apply.call(console[$], console, hn);
      }
    }
    var N = !1, z = !1, I = !1, V = !1, W = !1, U;
    U = Symbol.for("react.module.reference");
    function O($) {
      return !!(typeof $ == "string" || typeof $ == "function" || $ === n || $ === o || W || $ === r || $ === h || $ === m || V || $ === _ || N || z || I || typeof $ == "object" && $ !== null && ($.$$typeof === y || $.$$typeof === g || $.$$typeof === l || $.$$typeof === u || $.$$typeof === d || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      $.$$typeof === U || $.getModuleId !== void 0));
    }
    function q($, ke, vt) {
      var Ft = $.displayName;
      if (Ft)
        return Ft;
      var xn = ke.displayName || ke.name || "";
      return xn !== "" ? vt + "(" + xn + ")" : vt;
    }
    function le($) {
      return $.displayName || "Context";
    }
    function ye($) {
      if ($ == null)
        return null;
      if (typeof $.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof $ == "function")
        return $.displayName || $.name || null;
      if (typeof $ == "string")
        return $;
      switch ($) {
        case n:
          return "Fragment";
        case t:
          return "Portal";
        case o:
          return "Profiler";
        case r:
          return "StrictMode";
        case h:
          return "Suspense";
        case m:
          return "SuspenseList";
      }
      if (typeof $ == "object")
        switch ($.$$typeof) {
          case u:
            var ke = $;
            return le(ke) + ".Consumer";
          case l:
            var vt = $;
            return le(vt._context) + ".Provider";
          case d:
            return q($, $.render, "ForwardRef");
          case g:
            var Ft = $.displayName || null;
            return Ft !== null ? Ft : ye($.type) || "Memo";
          case y: {
            var xn = $, hn = xn._payload, k = xn._init;
            try {
              return ye(k(hn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var K = Object.assign, oe = 0, ie, Ee, Q, se, re, ue, Le;
    function pe() {
    }
    pe.__reactDisabledLog = !0;
    function Ae() {
      {
        if (oe === 0) {
          ie = console.log, Ee = console.info, Q = console.warn, se = console.error, re = console.group, ue = console.groupCollapsed, Le = console.groupEnd;
          var $ = {
            configurable: !0,
            enumerable: !0,
            value: pe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: $,
            log: $,
            warn: $,
            error: $,
            group: $,
            groupCollapsed: $,
            groupEnd: $
          });
        }
        oe++;
      }
    }
    function qe() {
      {
        if (oe--, oe === 0) {
          var $ = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: K({}, $, {
              value: ie
            }),
            info: K({}, $, {
              value: Ee
            }),
            warn: K({}, $, {
              value: Q
            }),
            error: K({}, $, {
              value: se
            }),
            group: K({}, $, {
              value: re
            }),
            groupCollapsed: K({}, $, {
              value: ue
            }),
            groupEnd: K({}, $, {
              value: Le
            })
          });
        }
        oe < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var je = M.ReactCurrentDispatcher, $e;
    function Rt($, ke, vt) {
      {
        if ($e === void 0)
          try {
            throw Error();
          } catch (xn) {
            var Ft = xn.stack.trim().match(/\n( *(at )?)/);
            $e = Ft && Ft[1] || "";
          }
        return `
` + $e + $;
      }
    }
    var Ut = !1, ot;
    {
      var pt = typeof WeakMap == "function" ? WeakMap : Map;
      ot = new pt();
    }
    function J($, ke) {
      if (!$ || Ut)
        return "";
      {
        var vt = ot.get($);
        if (vt !== void 0)
          return vt;
      }
      var Ft;
      Ut = !0;
      var xn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var hn;
      hn = je.current, je.current = null, Ae();
      try {
        if (ke) {
          var k = function() {
            throw Error();
          };
          if (Object.defineProperty(k.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(k, []);
            } catch (At) {
              Ft = At;
            }
            Reflect.construct($, [], k);
          } else {
            try {
              k.call();
            } catch (At) {
              Ft = At;
            }
            $.call(k.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (At) {
            Ft = At;
          }
          $();
        }
      } catch (At) {
        if (At && Ft && typeof At.stack == "string") {
          for (var ne = At.stack.split(`
`), ge = Ft.stack.split(`
`), ve = ne.length - 1, me = ge.length - 1; ve >= 1 && me >= 0 && ne[ve] !== ge[me]; )
            me--;
          for (; ve >= 1 && me >= 0; ve--, me--)
            if (ne[ve] !== ge[me]) {
              if (ve !== 1 || me !== 1)
                do
                  if (ve--, me--, me < 0 || ne[ve] !== ge[me]) {
                    var Qe = `
` + ne[ve].replace(" at new ", " at ");
                    return $.displayName && Qe.includes("<anonymous>") && (Qe = Qe.replace("<anonymous>", $.displayName)), typeof $ == "function" && ot.set($, Qe), Qe;
                  }
                while (ve >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Ut = !1, je.current = hn, qe(), Error.prepareStackTrace = xn;
      }
      var wt = $ ? $.displayName || $.name : "", Ct = wt ? Rt(wt) : "";
      return typeof $ == "function" && ot.set($, Ct), Ct;
    }
    function Be($, ke, vt) {
      return J($, !1);
    }
    function Pe($) {
      var ke = $.prototype;
      return !!(ke && ke.isReactComponent);
    }
    function He($, ke, vt) {
      if ($ == null)
        return "";
      if (typeof $ == "function")
        return J($, Pe($));
      if (typeof $ == "string")
        return Rt($);
      switch ($) {
        case h:
          return Rt("Suspense");
        case m:
          return Rt("SuspenseList");
      }
      if (typeof $ == "object")
        switch ($.$$typeof) {
          case d:
            return Be($.render);
          case g:
            return He($.type, ke, vt);
          case y: {
            var Ft = $, xn = Ft._payload, hn = Ft._init;
            try {
              return He(hn(xn), ke, vt);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, _t = {}, rt = M.ReactDebugCurrentFrame;
    function G($) {
      if ($) {
        var ke = $._owner, vt = He($.type, $._source, ke ? ke.type : null);
        rt.setExtraStackFrame(vt);
      } else
        rt.setExtraStackFrame(null);
    }
    function B($, ke, vt, Ft, xn) {
      {
        var hn = Function.call.bind(Re);
        for (var k in $)
          if (hn($, k)) {
            var ne = void 0;
            try {
              if (typeof $[k] != "function") {
                var ge = Error((Ft || "React class") + ": " + vt + " type `" + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof $[k] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ge.name = "Invariant Violation", ge;
              }
              ne = $[k](ke, k, Ft, vt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ve) {
              ne = ve;
            }
            ne && !(ne instanceof Error) && (G(xn), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ft || "React class", vt, k, typeof ne), G(null)), ne instanceof Error && !(ne.message in _t) && (_t[ne.message] = !0, G(xn), C("Failed %s type: %s", vt, ne.message), G(null));
          }
      }
    }
    var ce = Array.isArray;
    function Fe($) {
      return ce($);
    }
    function ze($) {
      {
        var ke = typeof Symbol == "function" && Symbol.toStringTag, vt = ke && $[Symbol.toStringTag] || $.constructor.name || "Object";
        return vt;
      }
    }
    function Ie($) {
      try {
        return Mt($), !1;
      } catch {
        return !0;
      }
    }
    function Mt($) {
      return "" + $;
    }
    function it($) {
      if (Ie($))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ze($)), Mt($);
    }
    var mt = M.ReactCurrentOwner, Dt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ht, de;
    function nt($) {
      if (Re.call($, "ref")) {
        var ke = Object.getOwnPropertyDescriptor($, "ref").get;
        if (ke && ke.isReactWarning)
          return !1;
      }
      return $.ref !== void 0;
    }
    function lt($) {
      if (Re.call($, "key")) {
        var ke = Object.getOwnPropertyDescriptor($, "key").get;
        if (ke && ke.isReactWarning)
          return !1;
      }
      return $.key !== void 0;
    }
    function Xe($, ke) {
      typeof $.ref == "string" && mt.current;
    }
    function dt($, ke) {
      {
        var vt = function() {
          Ht || (Ht = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ke));
        };
        vt.isReactWarning = !0, Object.defineProperty($, "key", {
          get: vt,
          configurable: !0
        });
      }
    }
    function at($, ke) {
      {
        var vt = function() {
          de || (de = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ke));
        };
        vt.isReactWarning = !0, Object.defineProperty($, "ref", {
          get: vt,
          configurable: !0
        });
      }
    }
    var Y = function($, ke, vt, Ft, xn, hn, k) {
      var ne = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: $,
        key: ke,
        ref: vt,
        props: k,
        // Record the component responsible for creating this element.
        _owner: hn
      };
      return ne._store = {}, Object.defineProperty(ne._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ne, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ft
      }), Object.defineProperty(ne, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: xn
      }), Object.freeze && (Object.freeze(ne.props), Object.freeze(ne)), ne;
    };
    function he($, ke, vt, Ft, xn) {
      {
        var hn, k = {}, ne = null, ge = null;
        vt !== void 0 && (it(vt), ne = "" + vt), lt(ke) && (it(ke.key), ne = "" + ke.key), nt(ke) && (ge = ke.ref, Xe(ke, xn));
        for (hn in ke)
          Re.call(ke, hn) && !Dt.hasOwnProperty(hn) && (k[hn] = ke[hn]);
        if ($ && $.defaultProps) {
          var ve = $.defaultProps;
          for (hn in ve)
            k[hn] === void 0 && (k[hn] = ve[hn]);
        }
        if (ne || ge) {
          var me = typeof $ == "function" ? $.displayName || $.name || "Unknown" : $;
          ne && dt(k, me), ge && at(k, me);
        }
        return Y($, ne, ge, xn, Ft, mt.current, k);
      }
    }
    var Ze = M.ReactCurrentOwner, Ve = M.ReactDebugCurrentFrame;
    function Te($) {
      if ($) {
        var ke = $._owner, vt = He($.type, $._source, ke ? ke.type : null);
        Ve.setExtraStackFrame(vt);
      } else
        Ve.setExtraStackFrame(null);
    }
    var ee;
    ee = !1;
    function Ke($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === e;
    }
    function st() {
      {
        if (Ze.current) {
          var $ = ye(Ze.current.type);
          if ($)
            return `

Check the render method of \`` + $ + "`.";
        }
        return "";
      }
    }
    function zt($) {
      return "";
    }
    var Ye = {};
    function qt($) {
      {
        var ke = st();
        if (!ke) {
          var vt = typeof $ == "string" ? $ : $.displayName || $.name;
          vt && (ke = `

Check the top-level render call using <` + vt + ">.");
        }
        return ke;
      }
    }
    function tn($, ke) {
      {
        if (!$._store || $._store.validated || $.key != null)
          return;
        $._store.validated = !0;
        var vt = qt(ke);
        if (Ye[vt])
          return;
        Ye[vt] = !0;
        var Ft = "";
        $ && $._owner && $._owner !== Ze.current && (Ft = " It was passed a child from " + ye($._owner.type) + "."), Te($), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', vt, Ft), Te(null);
      }
    }
    function Sn($, ke) {
      {
        if (typeof $ != "object")
          return;
        if (Fe($))
          for (var vt = 0; vt < $.length; vt++) {
            var Ft = $[vt];
            Ke(Ft) && tn(Ft, ke);
          }
        else if (Ke($))
          $._store && ($._store.validated = !0);
        else if ($) {
          var xn = T($);
          if (typeof xn == "function" && xn !== $.entries)
            for (var hn = xn.call($), k; !(k = hn.next()).done; )
              Ke(k.value) && tn(k.value, ke);
        }
      }
    }
    function bn($) {
      {
        var ke = $.type;
        if (ke == null || typeof ke == "string")
          return;
        var vt;
        if (typeof ke == "function")
          vt = ke.propTypes;
        else if (typeof ke == "object" && (ke.$$typeof === d || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ke.$$typeof === g))
          vt = ke.propTypes;
        else
          return;
        if (vt) {
          var Ft = ye(ke);
          B(vt, $.props, "prop", Ft, $);
        } else if (ke.PropTypes !== void 0 && !ee) {
          ee = !0;
          var xn = ye(ke);
          C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", xn || "Unknown");
        }
        typeof ke.getDefaultProps == "function" && !ke.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Jt($) {
      {
        for (var ke = Object.keys($.props), vt = 0; vt < ke.length; vt++) {
          var Ft = ke[vt];
          if (Ft !== "children" && Ft !== "key") {
            Te($), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ft), Te(null);
            break;
          }
        }
        $.ref !== null && (Te($), C("Invalid attribute `ref` supplied to `React.Fragment`."), Te(null));
      }
    }
    var di = {};
    function hi($, ke, vt, Ft, xn, hn) {
      {
        var k = O($);
        if (!k) {
          var ne = "";
          ($ === void 0 || typeof $ == "object" && $ !== null && Object.keys($).length === 0) && (ne += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ge = zt();
          ge ? ne += ge : ne += st();
          var ve;
          $ === null ? ve = "null" : Fe($) ? ve = "array" : $ !== void 0 && $.$$typeof === e ? (ve = "<" + (ye($.type) || "Unknown") + " />", ne = " Did you accidentally export a JSX literal instead of a component?") : ve = typeof $, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ve, ne);
        }
        var me = he($, ke, vt, xn, hn);
        if (me == null)
          return me;
        if (k) {
          var Qe = ke.children;
          if (Qe !== void 0)
            if (Ft)
              if (Fe(Qe)) {
                for (var wt = 0; wt < Qe.length; wt++)
                  Sn(Qe[wt], $);
                Object.freeze && Object.freeze(Qe);
              } else
                C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Sn(Qe, $);
        }
        if (Re.call(ke, "key")) {
          var Ct = ye($), At = Object.keys(ke).filter(function(Zt) {
            return Zt !== "key";
          }), Wt = At.length > 0 ? "{key: someKey, " + At.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!di[Ct + Wt]) {
            var Xt = At.length > 0 ? "{" + At.join(": ..., ") + ": ...}" : "{}";
            C(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wt, Ct, Xt, Ct), di[Ct + Wt] = !0;
          }
        }
        return $ === n ? Jt(me) : bn(me), me;
      }
    }
    function va($, ke, vt) {
      return hi($, ke, vt, !0);
    }
    function Mo($, ke, vt) {
      return hi($, ke, vt, !1);
    }
    var ws = Mo, Zn = va;
    Rp.Fragment = n, Rp.jsx = ws, Rp.jsxs = Zn;
  }()), Rp;
}
process.env.NODE_ENV === "production" ? mM.exports = EO() : mM.exports = bO();
var _n = mM.exports, Xp = {}, Cp = SO;
if (process.env.NODE_ENV === "production")
  Xp.createRoot = Cp.createRoot, Xp.hydrateRoot = Cp.hydrateRoot;
else {
  var Og = Cp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Xp.createRoot = function(i, e) {
    Og.usingClientEntryPoint = !0;
    try {
      return Cp.createRoot(i, e);
    } finally {
      Og.usingClientEntryPoint = !1;
    }
  }, Xp.hydrateRoot = function(i, e, t) {
    Og.usingClientEntryPoint = !0;
    try {
      return Cp.hydrateRoot(i, e, t);
    } finally {
      Og.usingClientEntryPoint = !1;
    }
  };
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const l0 = "160", _c = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Sc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, zC = 0, vM = 1, BC = 2, TO = 3, VC = 0, u0 = 1, Zp = 2, za = 3, sl = 0, ss = 1, po = 2, wO = 2, nl = 0, Nc = 1, gM = 2, yM = 3, xM = 4, HC = 5, uu = 100, kC = 101, GC = 102, _M = 103, SM = 104, WC = 200, XC = 201, jC = 202, YC = 203, jy = 204, Yy = 205, qC = 206, ZC = 207, KC = 208, JC = 209, QC = 210, $C = 211, eP = 212, tP = 213, nP = 214, iP = 0, rP = 1, sP = 2, sm = 3, aP = 4, oP = 5, lP = 6, uP = 7, Pm = 0, cP = 1, fP = 2, mo = 0, dP = 1, hP = 2, pP = 3, wE = 4, mP = 5, vP = 6, MM = "attached", gP = "detached", c0 = 300, al = 301, vu = 302, am = 303, om = 304, oh = 306, lm = 1e3, Wr = 1001, um = 1002, Ui = 1003, qy = 1004, AO = 1004, Kp = 1005, RO = 1005, Oi = 1006, AE = 1007, CO = 1007, gu = 1008, PO = 1008, vo = 1009, yP = 1010, xP = 1011, f0 = 1012, RE = 1013, $o = 1014, Va = 1015, Qd = 1016, CE = 1017, PE = 1018, cu = 1020, _P = 1021, is = 1023, SP = 1024, MP = 1025, fu = 1026, Bc = 1027, EP = 1028, LE = 1029, bP = 1030, DE = 1031, NE = 1033, Iy = 33776, Fy = 33777, zy = 33778, By = 33779, EM = 35840, bM = 35841, TM = 35842, wM = 35843, UE = 36196, AM = 37492, RM = 37496, CM = 37808, PM = 37809, LM = 37810, DM = 37811, NM = 37812, UM = 37813, OM = 37814, IM = 37815, FM = 37816, zM = 37817, BM = 37818, VM = 37819, HM = 37820, kM = 37821, Vy = 36492, GM = 36494, WM = 36495, TP = 36283, XM = 36284, jM = 36285, YM = 36286, wP = 2200, AP = 2201, RP = 2202, cm = 2300, fm = 2301, Hy = 2302, Rc = 2400, Cc = 2401, dm = 2402, d0 = 2500, OE = 2501, LO = 0, DO = 1, NO = 2, IE = 3e3, du = 3001, CP = 3200, PP = 3201, Su = 0, LP = 1, Vs = "", nr = "srgb", xo = "srgb-linear", h0 = "display-p3", Lm = "display-p3-linear", hm = "linear", Yn = "srgb", pm = "rec709", mm = "p3", UO = 0, Mc = 7680, OO = 7681, IO = 7682, FO = 7683, zO = 34055, BO = 34056, VO = 5386, HO = 512, kO = 513, GO = 514, WO = 515, XO = 516, jO = 517, YO = 518, qM = 519, DP = 512, NP = 513, UP = 514, FE = 515, OP = 516, IP = 517, FP = 518, zP = 519, vm = 35044, qO = 35048, ZO = 35040, KO = 35045, JO = 35049, QO = 35041, $O = 35046, eI = 35050, tI = 35042, nI = "100", ZM = "300 es", Zy = 1035, Ha = 2e3, $d = 2001;
let ul = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const o = r.indexOf(t);
      o !== -1 && r.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let o = 0, l = r.length; o < l; o++)
        r[o].call(this, e);
      e.target = null;
    }
  }
};
const Vr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Nw = 1234567;
const Uc = Math.PI / 180, eh = 180 / Math.PI;
function ks() {
  const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Vr[i & 255] + Vr[i >> 8 & 255] + Vr[i >> 16 & 255] + Vr[i >> 24 & 255] + "-" + Vr[e & 255] + Vr[e >> 8 & 255] + "-" + Vr[e >> 16 & 15 | 64] + Vr[e >> 24 & 255] + "-" + Vr[t & 63 | 128] + Vr[t >> 8 & 255] + "-" + Vr[t >> 16 & 255] + Vr[t >> 24 & 255] + Vr[n & 255] + Vr[n >> 8 & 255] + Vr[n >> 16 & 255] + Vr[n >> 24 & 255]).toLowerCase();
}
function Mi(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function zE(i, e) {
  return (i % e + e) % e;
}
function iI(i, e, t, n, r) {
  return n + (i - e) * (r - n) / (t - e);
}
function rI(i, e, t) {
  return i !== e ? (t - i) / (e - i) : 0;
}
function Jp(i, e, t) {
  return (1 - t) * i + t * e;
}
function sI(i, e, t, n) {
  return Jp(i, e, 1 - Math.exp(-t * n));
}
function aI(i, e = 1) {
  return e - Math.abs(zE(i, e * 2) - e);
}
function oI(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
}
function lI(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
}
function uI(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}
function cI(i, e) {
  return i + Math.random() * (e - i);
}
function fI(i) {
  return i * (0.5 - Math.random());
}
function dI(i) {
  i !== void 0 && (Nw = i);
  let e = Nw += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function hI(i) {
  return i * Uc;
}
function pI(i) {
  return i * eh;
}
function KM(i) {
  return (i & i - 1) === 0 && i !== 0;
}
function mI(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function Ky(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function vI(i, e, t, n, r) {
  const o = Math.cos, l = Math.sin, u = o(t / 2), d = l(t / 2), h = o((e + n) / 2), m = l((e + n) / 2), g = o((e - n) / 2), y = l((e - n) / 2), _ = o((n - e) / 2), E = l((n - e) / 2);
  switch (r) {
    case "XYX":
      i.set(u * m, d * g, d * y, u * h);
      break;
    case "YZY":
      i.set(d * y, u * m, d * g, u * h);
      break;
    case "ZXZ":
      i.set(d * g, d * y, u * m, u * h);
      break;
    case "XZX":
      i.set(u * m, d * E, d * _, u * h);
      break;
    case "YXY":
      i.set(d * _, u * m, d * E, u * h);
      break;
    case "ZYZ":
      i.set(d * E, d * _, u * m, u * h);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Es(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function dn(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const gI = {
  DEG2RAD: Uc,
  RAD2DEG: eh,
  generateUUID: ks,
  clamp: Mi,
  euclideanModulo: zE,
  mapLinear: iI,
  inverseLerp: rI,
  lerp: Jp,
  damp: sI,
  pingpong: aI,
  smoothstep: oI,
  smootherstep: lI,
  randInt: uI,
  randFloat: cI,
  randFloatSpread: fI,
  seededRandom: dI,
  degToRad: hI,
  radToDeg: pI,
  isPowerOfTwo: KM,
  ceilPowerOfTwo: mI,
  floorPowerOfTwo: Ky,
  setQuaternionFromProperEuler: vI,
  normalize: dn,
  denormalize: Es
};
class Oe {
  constructor(e = 0, t = 0) {
    Oe.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Mi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), r = Math.sin(t), o = this.x - e.x, l = this.y - e.y;
    return this.x = o * n - l * r + e.x, this.y = o * r + l * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class vn {
  constructor(e, t, n, r, o, l, u, d, h) {
    vn.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, r, o, l, u, d, h);
  }
  set(e, t, n, r, o, l, u, d, h) {
    const m = this.elements;
    return m[0] = e, m[1] = r, m[2] = u, m[3] = t, m[4] = o, m[5] = d, m[6] = n, m[7] = l, m[8] = h, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, o = this.elements, l = n[0], u = n[3], d = n[6], h = n[1], m = n[4], g = n[7], y = n[2], _ = n[5], E = n[8], w = r[0], T = r[3], M = r[6], C = r[1], A = r[4], N = r[7], z = r[2], I = r[5], V = r[8];
    return o[0] = l * w + u * C + d * z, o[3] = l * T + u * A + d * I, o[6] = l * M + u * N + d * V, o[1] = h * w + m * C + g * z, o[4] = h * T + m * A + g * I, o[7] = h * M + m * N + g * V, o[2] = y * w + _ * C + E * z, o[5] = y * T + _ * A + E * I, o[8] = y * M + _ * N + E * V, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], o = e[3], l = e[4], u = e[5], d = e[6], h = e[7], m = e[8];
    return t * l * m - t * u * h - n * o * m + n * u * d + r * o * h - r * l * d;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], o = e[3], l = e[4], u = e[5], d = e[6], h = e[7], m = e[8], g = m * l - u * h, y = u * d - m * o, _ = h * o - l * d, E = t * g + n * y + r * _;
    if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / E;
    return e[0] = g * w, e[1] = (r * h - m * n) * w, e[2] = (u * n - r * l) * w, e[3] = y * w, e[4] = (m * t - r * d) * w, e[5] = (r * o - u * t) * w, e[6] = _ * w, e[7] = (n * d - h * t) * w, e[8] = (l * t - n * o) * w, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, r, o, l, u) {
    const d = Math.cos(o), h = Math.sin(o);
    return this.set(
      n * d,
      n * h,
      -n * (d * l + h * u) + l + e,
      -r * h,
      r * d,
      -r * (-h * l + d * u) + u + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(aS.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(aS.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(aS.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const aS = /* @__PURE__ */ new vn();
function BP(i) {
  for (let e = i.length - 1; e >= 0; --e)
    if (i[e] >= 65535) return !0;
  return !1;
}
const yI = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Hd(i, e) {
  return new yI[i](e);
}
function gm(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function VP() {
  const i = gm("canvas");
  return i.style.display = "block", i;
}
const Uw = {};
function Qp(i) {
  i in Uw || (Uw[i] = !0, console.warn(i));
}
const Ow = /* @__PURE__ */ new vn().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), Iw = /* @__PURE__ */ new vn().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), Ig = {
  [xo]: {
    transfer: hm,
    primaries: pm,
    toReference: (i) => i,
    fromReference: (i) => i
  },
  [nr]: {
    transfer: Yn,
    primaries: pm,
    toReference: (i) => i.convertSRGBToLinear(),
    fromReference: (i) => i.convertLinearToSRGB()
  },
  [Lm]: {
    transfer: hm,
    primaries: mm,
    toReference: (i) => i.applyMatrix3(Iw),
    fromReference: (i) => i.applyMatrix3(Ow)
  },
  [h0]: {
    transfer: Yn,
    primaries: mm,
    toReference: (i) => i.convertSRGBToLinear().applyMatrix3(Iw),
    fromReference: (i) => i.applyMatrix3(Ow).convertLinearToSRGB()
  }
}, xI = /* @__PURE__ */ new Set([xo, Lm]), zn = {
  enabled: !0,
  _workingColorSpace: xo,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(i) {
    if (!xI.has(i))
      throw new Error(`Unsupported working color space, "${i}".`);
    this._workingColorSpace = i;
  },
  convert: function(i, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return i;
    const n = Ig[e].toReference, r = Ig[t].fromReference;
    return r(n(i));
  },
  fromWorkingColorSpace: function(i, e) {
    return this.convert(i, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(i, e) {
    return this.convert(i, e, this._workingColorSpace);
  },
  getPrimaries: function(i) {
    return Ig[i].primaries;
  },
  getTransfer: function(i) {
    return i === Vs ? hm : Ig[i].transfer;
  }
};
function Jd(i) {
  return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function oS(i) {
  return i < 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let vd;
class BE {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      vd === void 0 && (vd = gm("canvas")), vd.width = e.width, vd.height = e.height;
      const n = vd.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = vd;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = gm("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height), o = r.data;
      for (let l = 0; l < o.length; l++)
        o[l] = Jd(o[l] / 255) * 255;
      return n.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Jd(t[n] / 255) * 255) : t[n] = Jd(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let _I = 0;
class Pc {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: _I++ }), this.uuid = ks(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let o;
      if (Array.isArray(r)) {
        o = [];
        for (let l = 0, u = r.length; l < u; l++)
          r[l].isDataTexture ? o.push(lS(r[l].image)) : o.push(lS(r[l]));
      } else
        o = lS(r);
      n.url = o;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function lS(i) {
  return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? BE.getDataURL(i) : i.data ? {
    data: Array.from(i.data),
    width: i.width,
    height: i.height,
    type: i.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let SI = 0;
class Fi extends ul {
  constructor(e = Fi.DEFAULT_IMAGE, t = Fi.DEFAULT_MAPPING, n = Wr, r = Wr, o = Oi, l = gu, u = is, d = vo, h = Fi.DEFAULT_ANISOTROPY, m = Vs) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: SI++ }), this.uuid = ks(), this.name = "", this.source = new Pc(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = o, this.minFilter = l, this.anisotropy = h, this.format = u, this.internalFormat = null, this.type = d, this.offset = new Oe(0, 0), this.repeat = new Oe(1, 1), this.center = new Oe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new vn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof m == "string" ? this.colorSpace = m : (Qp("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = m === du ? nr : Vs), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== c0) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case lm:
          e.x = e.x - Math.floor(e.x);
          break;
        case Wr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case um:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case lm:
          e.y = e.y - Math.floor(e.y);
          break;
        case Wr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case um:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return Qp("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === nr ? du : IE;
  }
  set encoding(e) {
    Qp("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === du ? nr : Vs;
  }
}
Fi.DEFAULT_IMAGE = null;
Fi.DEFAULT_MAPPING = c0;
Fi.DEFAULT_ANISOTROPY = 1;
class Bn {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    Bn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, r) {
    return this.x = e, this.y = t, this.z = n, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, o = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * n + l[8] * r + l[12] * o, this.y = l[1] * t + l[5] * n + l[9] * r + l[13] * o, this.z = l[2] * t + l[6] * n + l[10] * r + l[14] * o, this.w = l[3] * t + l[7] * n + l[11] * r + l[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, r, o;
    const d = e.elements, h = d[0], m = d[4], g = d[8], y = d[1], _ = d[5], E = d[9], w = d[2], T = d[6], M = d[10];
    if (Math.abs(m - y) < 0.01 && Math.abs(g - w) < 0.01 && Math.abs(E - T) < 0.01) {
      if (Math.abs(m + y) < 0.1 && Math.abs(g + w) < 0.1 && Math.abs(E + T) < 0.1 && Math.abs(h + _ + M - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const A = (h + 1) / 2, N = (_ + 1) / 2, z = (M + 1) / 2, I = (m + y) / 4, V = (g + w) / 4, W = (E + T) / 4;
      return A > N && A > z ? A < 0.01 ? (n = 0, r = 0.707106781, o = 0.707106781) : (n = Math.sqrt(A), r = I / n, o = V / n) : N > z ? N < 0.01 ? (n = 0.707106781, r = 0, o = 0.707106781) : (r = Math.sqrt(N), n = I / r, o = W / r) : z < 0.01 ? (n = 0.707106781, r = 0.707106781, o = 0) : (o = Math.sqrt(z), n = V / o, r = W / o), this.set(n, r, o, t), this;
    }
    let C = Math.sqrt((T - E) * (T - E) + (g - w) * (g - w) + (y - m) * (y - m));
    return Math.abs(C) < 1e-3 && (C = 1), this.x = (T - E) / C, this.y = (g - w) / C, this.z = (y - m) / C, this.w = Math.acos((h + _ + M - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class HP extends ul {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Bn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Bn(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 && (Qp("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === du ? nr : Vs), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Oi,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, n), this.texture = new Fi(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Pc(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ka extends HP {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class p0 extends Fi {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Ui, this.minFilter = Ui, this.wrapR = Wr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class MI extends ka {
  constructor(e = 1, t = 1, n = 1, r = {}) {
    super(e, t, r), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new p0(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class VE extends Fi {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Ui, this.minFilter = Ui, this.wrapR = Wr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class EI extends ka {
  constructor(e = 1, t = 1, n = 1, r = {}) {
    super(e, t, r), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new VE(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class bI extends ka {
  constructor(e = 1, t = 1, n = 1, r = {}) {
    super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
    const o = this.texture;
    this.texture = [];
    for (let l = 0; l < n; l++)
      this.texture[l] = o.clone(), this.texture[l].isRenderTargetTexture = !0;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let r = 0, o = this.texture.length; r < o; r++)
        this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Xr {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r;
  }
  static slerpFlat(e, t, n, r, o, l, u) {
    let d = n[r + 0], h = n[r + 1], m = n[r + 2], g = n[r + 3];
    const y = o[l + 0], _ = o[l + 1], E = o[l + 2], w = o[l + 3];
    if (u === 0) {
      e[t + 0] = d, e[t + 1] = h, e[t + 2] = m, e[t + 3] = g;
      return;
    }
    if (u === 1) {
      e[t + 0] = y, e[t + 1] = _, e[t + 2] = E, e[t + 3] = w;
      return;
    }
    if (g !== w || d !== y || h !== _ || m !== E) {
      let T = 1 - u;
      const M = d * y + h * _ + m * E + g * w, C = M >= 0 ? 1 : -1, A = 1 - M * M;
      if (A > Number.EPSILON) {
        const z = Math.sqrt(A), I = Math.atan2(z, M * C);
        T = Math.sin(T * I) / z, u = Math.sin(u * I) / z;
      }
      const N = u * C;
      if (d = d * T + y * N, h = h * T + _ * N, m = m * T + E * N, g = g * T + w * N, T === 1 - u) {
        const z = 1 / Math.sqrt(d * d + h * h + m * m + g * g);
        d *= z, h *= z, m *= z, g *= z;
      }
    }
    e[t] = d, e[t + 1] = h, e[t + 2] = m, e[t + 3] = g;
  }
  static multiplyQuaternionsFlat(e, t, n, r, o, l) {
    const u = n[r], d = n[r + 1], h = n[r + 2], m = n[r + 3], g = o[l], y = o[l + 1], _ = o[l + 2], E = o[l + 3];
    return e[t] = u * E + m * g + d * _ - h * y, e[t + 1] = d * E + m * y + h * g - u * _, e[t + 2] = h * E + m * _ + u * y - d * g, e[t + 3] = m * E - u * g - d * y - h * _, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, r) {
    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, r = e._y, o = e._z, l = e._order, u = Math.cos, d = Math.sin, h = u(n / 2), m = u(r / 2), g = u(o / 2), y = d(n / 2), _ = d(r / 2), E = d(o / 2);
    switch (l) {
      case "XYZ":
        this._x = y * m * g + h * _ * E, this._y = h * _ * g - y * m * E, this._z = h * m * E + y * _ * g, this._w = h * m * g - y * _ * E;
        break;
      case "YXZ":
        this._x = y * m * g + h * _ * E, this._y = h * _ * g - y * m * E, this._z = h * m * E - y * _ * g, this._w = h * m * g + y * _ * E;
        break;
      case "ZXY":
        this._x = y * m * g - h * _ * E, this._y = h * _ * g + y * m * E, this._z = h * m * E + y * _ * g, this._w = h * m * g - y * _ * E;
        break;
      case "ZYX":
        this._x = y * m * g - h * _ * E, this._y = h * _ * g + y * m * E, this._z = h * m * E - y * _ * g, this._w = h * m * g + y * _ * E;
        break;
      case "YZX":
        this._x = y * m * g + h * _ * E, this._y = h * _ * g + y * m * E, this._z = h * m * E - y * _ * g, this._w = h * m * g - y * _ * E;
        break;
      case "XZY":
        this._x = y * m * g - h * _ * E, this._y = h * _ * g - y * m * E, this._z = h * m * E + y * _ * g, this._w = h * m * g + y * _ * E;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, r = Math.sin(n);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], r = t[4], o = t[8], l = t[1], u = t[5], d = t[9], h = t[2], m = t[6], g = t[10], y = n + u + g;
    if (y > 0) {
      const _ = 0.5 / Math.sqrt(y + 1);
      this._w = 0.25 / _, this._x = (m - d) * _, this._y = (o - h) * _, this._z = (l - r) * _;
    } else if (n > u && n > g) {
      const _ = 2 * Math.sqrt(1 + n - u - g);
      this._w = (m - d) / _, this._x = 0.25 * _, this._y = (r + l) / _, this._z = (o + h) / _;
    } else if (u > g) {
      const _ = 2 * Math.sqrt(1 + u - n - g);
      this._w = (o - h) / _, this._x = (r + l) / _, this._y = 0.25 * _, this._z = (d + m) / _;
    } else {
      const _ = 2 * Math.sqrt(1 + g - n - u);
      this._w = (l - r) / _, this._x = (o + h) / _, this._y = (d + m) / _, this._z = 0.25 * _;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Mi(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const r = Math.min(1, t / n);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, r = e._y, o = e._z, l = e._w, u = t._x, d = t._y, h = t._z, m = t._w;
    return this._x = n * m + l * u + r * h - o * d, this._y = r * m + l * d + o * u - n * h, this._z = o * m + l * h + n * d - r * u, this._w = l * m - n * u - r * d - o * h, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, r = this._y, o = this._z, l = this._w;
    let u = l * e._w + n * e._x + r * e._y + o * e._z;
    if (u < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, u = -u) : this.copy(e), u >= 1)
      return this._w = l, this._x = n, this._y = r, this._z = o, this;
    const d = 1 - u * u;
    if (d <= Number.EPSILON) {
      const _ = 1 - t;
      return this._w = _ * l + t * this._w, this._x = _ * n + t * this._x, this._y = _ * r + t * this._y, this._z = _ * o + t * this._z, this.normalize(), this;
    }
    const h = Math.sqrt(d), m = Math.atan2(h, u), g = Math.sin((1 - t) * m) / h, y = Math.sin(t * m) / h;
    return this._w = l * g + this._w * y, this._x = n * g + this._x * y, this._y = r * g + this._y * y, this._z = o * g + this._z * y, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), r = 2 * Math.PI * Math.random(), o = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      n * Math.sin(o),
      n * Math.cos(o),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class j {
  constructor(e = 0, t = 0, n = 0) {
    j.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Fw.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Fw.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * t + o[3] * n + o[6] * r, this.y = o[1] * t + o[4] * n + o[7] * r, this.z = o[2] * t + o[5] * n + o[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, o = e.elements, l = 1 / (o[3] * t + o[7] * n + o[11] * r + o[15]);
    return this.x = (o[0] * t + o[4] * n + o[8] * r + o[12]) * l, this.y = (o[1] * t + o[5] * n + o[9] * r + o[13]) * l, this.z = (o[2] * t + o[6] * n + o[10] * r + o[14]) * l, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, r = this.z, o = e.x, l = e.y, u = e.z, d = e.w, h = 2 * (l * r - u * n), m = 2 * (u * t - o * r), g = 2 * (o * n - l * t);
    return this.x = t + d * h + l * g - u * m, this.y = n + d * m + u * h - o * g, this.z = r + d * g + o * m - l * h, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * r, this.y = o[1] * t + o[5] * n + o[9] * r, this.z = o[2] * t + o[6] * n + o[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, r = e.y, o = e.z, l = t.x, u = t.y, d = t.z;
    return this.x = r * d - o * u, this.y = o * l - n * d, this.z = n * u - r * l, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return uS.copy(this).projectOnVector(e), this.sub(uS);
  }
  reflect(e) {
    return this.sub(uS.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Mi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z;
    return t * t + n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const uS = /* @__PURE__ */ new j(), Fw = /* @__PURE__ */ new Xr();
class as {
  constructor(e = new j(1 / 0, 1 / 0, 1 / 0), t = new j(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Oa.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Oa.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Oa.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const o = n.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let l = 0, u = o.count; l < u; l++)
          e.isMesh === !0 ? e.getVertexPosition(l, Oa) : Oa.fromBufferAttribute(o, l), Oa.applyMatrix4(e.matrixWorld), this.expandByPoint(Oa);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Fg.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Fg.copy(n.boundingBox)), Fg.applyMatrix4(e.matrixWorld), this.union(Fg);
    }
    const r = e.children;
    for (let o = 0, l = r.length; o < l; o++)
      this.expandByObject(r[o], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Oa), Oa.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Pp), zg.subVectors(this.max, Pp), gd.subVectors(e.a, Pp), yd.subVectors(e.b, Pp), xd.subVectors(e.c, Pp), Jl.subVectors(yd, gd), Ql.subVectors(xd, yd), uc.subVectors(gd, xd);
    let t = [
      0,
      -Jl.z,
      Jl.y,
      0,
      -Ql.z,
      Ql.y,
      0,
      -uc.z,
      uc.y,
      Jl.z,
      0,
      -Jl.x,
      Ql.z,
      0,
      -Ql.x,
      uc.z,
      0,
      -uc.x,
      -Jl.y,
      Jl.x,
      0,
      -Ql.y,
      Ql.x,
      0,
      -uc.y,
      uc.x,
      0
    ];
    return !cS(t, gd, yd, xd, zg) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !cS(t, gd, yd, xd, zg)) ? !1 : (Bg.crossVectors(Jl, Ql), t = [Bg.x, Bg.y, Bg.z], cS(t, gd, yd, xd, zg));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Oa).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Oa).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Xo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Xo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Xo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Xo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Xo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Xo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Xo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Xo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Xo), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Xo = [
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j()
], Oa = /* @__PURE__ */ new j(), Fg = /* @__PURE__ */ new as(), gd = /* @__PURE__ */ new j(), yd = /* @__PURE__ */ new j(), xd = /* @__PURE__ */ new j(), Jl = /* @__PURE__ */ new j(), Ql = /* @__PURE__ */ new j(), uc = /* @__PURE__ */ new j(), Pp = /* @__PURE__ */ new j(), zg = /* @__PURE__ */ new j(), Bg = /* @__PURE__ */ new j(), cc = /* @__PURE__ */ new j();
function cS(i, e, t, n, r) {
  for (let o = 0, l = i.length - 3; o <= l; o += 3) {
    cc.fromArray(i, o);
    const u = r.x * Math.abs(cc.x) + r.y * Math.abs(cc.y) + r.z * Math.abs(cc.z), d = e.dot(cc), h = t.dot(cc), m = n.dot(cc);
    if (Math.max(-Math.max(d, h, m), Math.min(d, h, m)) > u)
      return !1;
  }
  return !0;
}
const TI = /* @__PURE__ */ new as(), Lp = /* @__PURE__ */ new j(), fS = /* @__PURE__ */ new j();
let jr = class {
  constructor(e = new j(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : TI.setFromPoints(e).getCenter(n);
    let r = 0;
    for (let o = 0, l = e.length; o < l; o++)
      r = Math.max(r, n.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Lp.subVectors(e, this.center);
    const t = Lp.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), r = (n - this.radius) * 0.5;
      this.center.addScaledVector(Lp, r / n), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (fS.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Lp.copy(e.center).add(fS)), this.expandByPoint(Lp.copy(e.center).sub(fS))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const jo = /* @__PURE__ */ new j(), dS = /* @__PURE__ */ new j(), Vg = /* @__PURE__ */ new j(), $l = /* @__PURE__ */ new j(), hS = /* @__PURE__ */ new j(), Hg = /* @__PURE__ */ new j(), pS = /* @__PURE__ */ new j();
class Gc {
  constructor(e = new j(), t = new j(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, jo)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = jo.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (jo.copy(this.origin).addScaledVector(this.direction, t), jo.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, r) {
    dS.copy(e).add(t).multiplyScalar(0.5), Vg.copy(t).sub(e).normalize(), $l.copy(this.origin).sub(dS);
    const o = e.distanceTo(t) * 0.5, l = -this.direction.dot(Vg), u = $l.dot(this.direction), d = -$l.dot(Vg), h = $l.lengthSq(), m = Math.abs(1 - l * l);
    let g, y, _, E;
    if (m > 0)
      if (g = l * d - u, y = l * u - d, E = o * m, g >= 0)
        if (y >= -E)
          if (y <= E) {
            const w = 1 / m;
            g *= w, y *= w, _ = g * (g + l * y + 2 * u) + y * (l * g + y + 2 * d) + h;
          } else
            y = o, g = Math.max(0, -(l * y + u)), _ = -g * g + y * (y + 2 * d) + h;
        else
          y = -o, g = Math.max(0, -(l * y + u)), _ = -g * g + y * (y + 2 * d) + h;
      else
        y <= -E ? (g = Math.max(0, -(-l * o + u)), y = g > 0 ? -o : Math.min(Math.max(-o, -d), o), _ = -g * g + y * (y + 2 * d) + h) : y <= E ? (g = 0, y = Math.min(Math.max(-o, -d), o), _ = y * (y + 2 * d) + h) : (g = Math.max(0, -(l * o + u)), y = g > 0 ? o : Math.min(Math.max(-o, -d), o), _ = -g * g + y * (y + 2 * d) + h);
    else
      y = l > 0 ? -o : o, g = Math.max(0, -(l * y + u)), _ = -g * g + y * (y + 2 * d) + h;
    return n && n.copy(this.origin).addScaledVector(this.direction, g), r && r.copy(dS).addScaledVector(Vg, y), _;
  }
  intersectSphere(e, t) {
    jo.subVectors(e.center, this.origin);
    const n = jo.dot(this.direction), r = jo.dot(jo) - n * n, o = e.radius * e.radius;
    if (r > o) return null;
    const l = Math.sqrt(o - r), u = n - l, d = n + l;
    return d < 0 ? null : u < 0 ? this.at(d, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, r, o, l, u, d;
    const h = 1 / this.direction.x, m = 1 / this.direction.y, g = 1 / this.direction.z, y = this.origin;
    return h >= 0 ? (n = (e.min.x - y.x) * h, r = (e.max.x - y.x) * h) : (n = (e.max.x - y.x) * h, r = (e.min.x - y.x) * h), m >= 0 ? (o = (e.min.y - y.y) * m, l = (e.max.y - y.y) * m) : (o = (e.max.y - y.y) * m, l = (e.min.y - y.y) * m), n > l || o > r || ((o > n || isNaN(n)) && (n = o), (l < r || isNaN(r)) && (r = l), g >= 0 ? (u = (e.min.z - y.z) * g, d = (e.max.z - y.z) * g) : (u = (e.max.z - y.z) * g, d = (e.min.z - y.z) * g), n > d || u > r) || ((u > n || n !== n) && (n = u), (d < r || r !== r) && (r = d), r < 0) ? null : this.at(n >= 0 ? n : r, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, jo) !== null;
  }
  intersectTriangle(e, t, n, r, o) {
    hS.subVectors(t, e), Hg.subVectors(n, e), pS.crossVectors(hS, Hg);
    let l = this.direction.dot(pS), u;
    if (l > 0) {
      if (r) return null;
      u = 1;
    } else if (l < 0)
      u = -1, l = -l;
    else
      return null;
    $l.subVectors(this.origin, e);
    const d = u * this.direction.dot(Hg.crossVectors($l, Hg));
    if (d < 0)
      return null;
    const h = u * this.direction.dot(hS.cross($l));
    if (h < 0 || d + h > l)
      return null;
    const m = -u * $l.dot(pS);
    return m < 0 ? null : this.at(m / l, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class $t {
  constructor(e, t, n, r, o, l, u, d, h, m, g, y, _, E, w, T) {
    $t.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, r, o, l, u, d, h, m, g, y, _, E, w, T);
  }
  set(e, t, n, r, o, l, u, d, h, m, g, y, _, E, w, T) {
    const M = this.elements;
    return M[0] = e, M[4] = t, M[8] = n, M[12] = r, M[1] = o, M[5] = l, M[9] = u, M[13] = d, M[2] = h, M[6] = m, M[10] = g, M[14] = y, M[3] = _, M[7] = E, M[11] = w, M[15] = T, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new $t().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, r = 1 / _d.setFromMatrixColumn(e, 0).length(), o = 1 / _d.setFromMatrixColumn(e, 1).length(), l = 1 / _d.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * o, t[5] = n[5] * o, t[6] = n[6] * o, t[7] = 0, t[8] = n[8] * l, t[9] = n[9] * l, t[10] = n[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, r = e.y, o = e.z, l = Math.cos(n), u = Math.sin(n), d = Math.cos(r), h = Math.sin(r), m = Math.cos(o), g = Math.sin(o);
    if (e.order === "XYZ") {
      const y = l * m, _ = l * g, E = u * m, w = u * g;
      t[0] = d * m, t[4] = -d * g, t[8] = h, t[1] = _ + E * h, t[5] = y - w * h, t[9] = -u * d, t[2] = w - y * h, t[6] = E + _ * h, t[10] = l * d;
    } else if (e.order === "YXZ") {
      const y = d * m, _ = d * g, E = h * m, w = h * g;
      t[0] = y + w * u, t[4] = E * u - _, t[8] = l * h, t[1] = l * g, t[5] = l * m, t[9] = -u, t[2] = _ * u - E, t[6] = w + y * u, t[10] = l * d;
    } else if (e.order === "ZXY") {
      const y = d * m, _ = d * g, E = h * m, w = h * g;
      t[0] = y - w * u, t[4] = -l * g, t[8] = E + _ * u, t[1] = _ + E * u, t[5] = l * m, t[9] = w - y * u, t[2] = -l * h, t[6] = u, t[10] = l * d;
    } else if (e.order === "ZYX") {
      const y = l * m, _ = l * g, E = u * m, w = u * g;
      t[0] = d * m, t[4] = E * h - _, t[8] = y * h + w, t[1] = d * g, t[5] = w * h + y, t[9] = _ * h - E, t[2] = -h, t[6] = u * d, t[10] = l * d;
    } else if (e.order === "YZX") {
      const y = l * d, _ = l * h, E = u * d, w = u * h;
      t[0] = d * m, t[4] = w - y * g, t[8] = E * g + _, t[1] = g, t[5] = l * m, t[9] = -u * m, t[2] = -h * m, t[6] = _ * g + E, t[10] = y - w * g;
    } else if (e.order === "XZY") {
      const y = l * d, _ = l * h, E = u * d, w = u * h;
      t[0] = d * m, t[4] = -g, t[8] = h * m, t[1] = y * g + w, t[5] = l * m, t[9] = _ * g - E, t[2] = E * g - _, t[6] = u * m, t[10] = w * g + y;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(wI, e, AI);
  }
  lookAt(e, t, n) {
    const r = this.elements;
    return zs.subVectors(e, t), zs.lengthSq() === 0 && (zs.z = 1), zs.normalize(), eu.crossVectors(n, zs), eu.lengthSq() === 0 && (Math.abs(n.z) === 1 ? zs.x += 1e-4 : zs.z += 1e-4, zs.normalize(), eu.crossVectors(n, zs)), eu.normalize(), kg.crossVectors(zs, eu), r[0] = eu.x, r[4] = kg.x, r[8] = zs.x, r[1] = eu.y, r[5] = kg.y, r[9] = zs.y, r[2] = eu.z, r[6] = kg.z, r[10] = zs.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, o = this.elements, l = n[0], u = n[4], d = n[8], h = n[12], m = n[1], g = n[5], y = n[9], _ = n[13], E = n[2], w = n[6], T = n[10], M = n[14], C = n[3], A = n[7], N = n[11], z = n[15], I = r[0], V = r[4], W = r[8], U = r[12], O = r[1], q = r[5], le = r[9], ye = r[13], K = r[2], oe = r[6], ie = r[10], Ee = r[14], Q = r[3], se = r[7], re = r[11], ue = r[15];
    return o[0] = l * I + u * O + d * K + h * Q, o[4] = l * V + u * q + d * oe + h * se, o[8] = l * W + u * le + d * ie + h * re, o[12] = l * U + u * ye + d * Ee + h * ue, o[1] = m * I + g * O + y * K + _ * Q, o[5] = m * V + g * q + y * oe + _ * se, o[9] = m * W + g * le + y * ie + _ * re, o[13] = m * U + g * ye + y * Ee + _ * ue, o[2] = E * I + w * O + T * K + M * Q, o[6] = E * V + w * q + T * oe + M * se, o[10] = E * W + w * le + T * ie + M * re, o[14] = E * U + w * ye + T * Ee + M * ue, o[3] = C * I + A * O + N * K + z * Q, o[7] = C * V + A * q + N * oe + z * se, o[11] = C * W + A * le + N * ie + z * re, o[15] = C * U + A * ye + N * Ee + z * ue, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], r = e[8], o = e[12], l = e[1], u = e[5], d = e[9], h = e[13], m = e[2], g = e[6], y = e[10], _ = e[14], E = e[3], w = e[7], T = e[11], M = e[15];
    return E * (+o * d * g - r * h * g - o * u * y + n * h * y + r * u * _ - n * d * _) + w * (+t * d * _ - t * h * y + o * l * y - r * l * _ + r * h * m - o * d * m) + T * (+t * h * g - t * u * _ - o * l * g + n * l * _ + o * u * m - n * h * m) + M * (-r * u * m - t * d * g + t * u * y + r * l * g - n * l * y + n * d * m);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], o = e[3], l = e[4], u = e[5], d = e[6], h = e[7], m = e[8], g = e[9], y = e[10], _ = e[11], E = e[12], w = e[13], T = e[14], M = e[15], C = g * T * h - w * y * h + w * d * _ - u * T * _ - g * d * M + u * y * M, A = E * y * h - m * T * h - E * d * _ + l * T * _ + m * d * M - l * y * M, N = m * w * h - E * g * h + E * u * _ - l * w * _ - m * u * M + l * g * M, z = E * g * d - m * w * d - E * u * y + l * w * y + m * u * T - l * g * T, I = t * C + n * A + r * N + o * z;
    if (I === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const V = 1 / I;
    return e[0] = C * V, e[1] = (w * y * o - g * T * o - w * r * _ + n * T * _ + g * r * M - n * y * M) * V, e[2] = (u * T * o - w * d * o + w * r * h - n * T * h - u * r * M + n * d * M) * V, e[3] = (g * d * o - u * y * o - g * r * h + n * y * h + u * r * _ - n * d * _) * V, e[4] = A * V, e[5] = (m * T * o - E * y * o + E * r * _ - t * T * _ - m * r * M + t * y * M) * V, e[6] = (E * d * o - l * T * o - E * r * h + t * T * h + l * r * M - t * d * M) * V, e[7] = (l * y * o - m * d * o + m * r * h - t * y * h - l * r * _ + t * d * _) * V, e[8] = N * V, e[9] = (E * g * o - m * w * o - E * n * _ + t * w * _ + m * n * M - t * g * M) * V, e[10] = (l * w * o - E * u * o + E * n * h - t * w * h - l * n * M + t * u * M) * V, e[11] = (m * u * o - l * g * o - m * n * h + t * g * h + l * n * _ - t * u * _) * V, e[12] = z * V, e[13] = (m * w * r - E * g * r + E * n * y - t * w * y - m * n * T + t * g * T) * V, e[14] = (E * u * r - l * w * r - E * n * d + t * w * d + l * n * T - t * u * T) * V, e[15] = (l * g * r - m * u * r + m * n * d - t * g * d - l * n * y + t * u * y) * V, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, r = e.y, o = e.z;
    return t[0] *= n, t[4] *= r, t[8] *= o, t[1] *= n, t[5] *= r, t[9] *= o, t[2] *= n, t[6] *= r, t[10] *= o, t[3] *= n, t[7] *= r, t[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, r));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), r = Math.sin(t), o = 1 - n, l = e.x, u = e.y, d = e.z, h = o * l, m = o * u;
    return this.set(
      h * l + n,
      h * u - r * d,
      h * d + r * u,
      0,
      h * u + r * d,
      m * u + n,
      m * d - r * l,
      0,
      h * d - r * u,
      m * d + r * l,
      o * d * d + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, r, o, l) {
    return this.set(
      1,
      n,
      o,
      0,
      e,
      1,
      l,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const r = this.elements, o = t._x, l = t._y, u = t._z, d = t._w, h = o + o, m = l + l, g = u + u, y = o * h, _ = o * m, E = o * g, w = l * m, T = l * g, M = u * g, C = d * h, A = d * m, N = d * g, z = n.x, I = n.y, V = n.z;
    return r[0] = (1 - (w + M)) * z, r[1] = (_ + N) * z, r[2] = (E - A) * z, r[3] = 0, r[4] = (_ - N) * I, r[5] = (1 - (y + M)) * I, r[6] = (T + C) * I, r[7] = 0, r[8] = (E + A) * V, r[9] = (T - C) * V, r[10] = (1 - (y + w)) * V, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, n) {
    const r = this.elements;
    let o = _d.set(r[0], r[1], r[2]).length();
    const l = _d.set(r[4], r[5], r[6]).length(), u = _d.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (o = -o), e.x = r[12], e.y = r[13], e.z = r[14], Ia.copy(this);
    const h = 1 / o, m = 1 / l, g = 1 / u;
    return Ia.elements[0] *= h, Ia.elements[1] *= h, Ia.elements[2] *= h, Ia.elements[4] *= m, Ia.elements[5] *= m, Ia.elements[6] *= m, Ia.elements[8] *= g, Ia.elements[9] *= g, Ia.elements[10] *= g, t.setFromRotationMatrix(Ia), n.x = o, n.y = l, n.z = u, this;
  }
  makePerspective(e, t, n, r, o, l, u = Ha) {
    const d = this.elements, h = 2 * o / (t - e), m = 2 * o / (n - r), g = (t + e) / (t - e), y = (n + r) / (n - r);
    let _, E;
    if (u === Ha)
      _ = -(l + o) / (l - o), E = -2 * l * o / (l - o);
    else if (u === $d)
      _ = -l / (l - o), E = -l * o / (l - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u);
    return d[0] = h, d[4] = 0, d[8] = g, d[12] = 0, d[1] = 0, d[5] = m, d[9] = y, d[13] = 0, d[2] = 0, d[6] = 0, d[10] = _, d[14] = E, d[3] = 0, d[7] = 0, d[11] = -1, d[15] = 0, this;
  }
  makeOrthographic(e, t, n, r, o, l, u = Ha) {
    const d = this.elements, h = 1 / (t - e), m = 1 / (n - r), g = 1 / (l - o), y = (t + e) * h, _ = (n + r) * m;
    let E, w;
    if (u === Ha)
      E = (l + o) * g, w = -2 * g;
    else if (u === $d)
      E = o * g, w = -1 * g;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u);
    return d[0] = 2 * h, d[4] = 0, d[8] = 0, d[12] = -y, d[1] = 0, d[5] = 2 * m, d[9] = 0, d[13] = -_, d[2] = 0, d[6] = 0, d[10] = w, d[14] = -E, d[3] = 0, d[7] = 0, d[11] = 0, d[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const _d = /* @__PURE__ */ new j(), Ia = /* @__PURE__ */ new $t(), wI = /* @__PURE__ */ new j(0, 0, 0), AI = /* @__PURE__ */ new j(1, 1, 1), eu = /* @__PURE__ */ new j(), kg = /* @__PURE__ */ new j(), zs = /* @__PURE__ */ new j(), zw = /* @__PURE__ */ new $t(), Bw = /* @__PURE__ */ new Xr();
class Dm {
  constructor(e = 0, t = 0, n = 0, r = Dm.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, r = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const r = e.elements, o = r[0], l = r[4], u = r[8], d = r[1], h = r[5], m = r[9], g = r[2], y = r[6], _ = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Mi(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-m, _), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(y, h), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Mi(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(u, _), this._z = Math.atan2(d, h)) : (this._y = Math.atan2(-g, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Mi(y, -1, 1)), Math.abs(y) < 0.9999999 ? (this._y = Math.atan2(-g, _), this._z = Math.atan2(-l, h)) : (this._y = 0, this._z = Math.atan2(d, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Mi(g, -1, 1)), Math.abs(g) < 0.9999999 ? (this._x = Math.atan2(y, _), this._z = Math.atan2(d, o)) : (this._x = 0, this._z = Math.atan2(-l, h));
        break;
      case "YZX":
        this._z = Math.asin(Mi(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(-m, h), this._y = Math.atan2(-g, o)) : (this._x = 0, this._y = Math.atan2(u, _));
        break;
      case "XZY":
        this._z = Math.asin(-Mi(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(y, h), this._y = Math.atan2(u, o)) : (this._x = Math.atan2(-m, _), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return zw.makeRotationFromQuaternion(e), this.setFromRotationMatrix(zw, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Bw.setFromEuler(this), this.setFromQuaternion(Bw, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Dm.DEFAULT_ORDER = "XYZ";
class Oc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let RI = 0;
const Vw = /* @__PURE__ */ new j(), Sd = /* @__PURE__ */ new Xr(), Yo = /* @__PURE__ */ new $t(), Gg = /* @__PURE__ */ new j(), Dp = /* @__PURE__ */ new j(), CI = /* @__PURE__ */ new j(), PI = /* @__PURE__ */ new Xr(), Hw = /* @__PURE__ */ new j(1, 0, 0), kw = /* @__PURE__ */ new j(0, 1, 0), Gw = /* @__PURE__ */ new j(0, 0, 1), LI = { type: "added" }, DI = { type: "removed" };
class Dn extends ul {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: RI++ }), this.uuid = ks(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Dn.DEFAULT_UP.clone();
    const e = new j(), t = new Dm(), n = new Xr(), r = new j(1, 1, 1);
    function o() {
      n.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(o), n._onChange(l), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new $t()
      },
      normalMatrix: {
        value: new vn()
      }
    }), this.matrix = new $t(), this.matrixWorld = new $t(), this.matrixAutoUpdate = Dn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Dn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Oc(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Sd.setFromAxisAngle(e, t), this.quaternion.multiply(Sd), this;
  }
  rotateOnWorldAxis(e, t) {
    return Sd.setFromAxisAngle(e, t), this.quaternion.premultiply(Sd), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Hw, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(kw, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Gw, e);
  }
  translateOnAxis(e, t) {
    return Vw.copy(e).applyQuaternion(this.quaternion), this.position.add(Vw.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Hw, e);
  }
  translateY(e) {
    return this.translateOnAxis(kw, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Gw, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Yo.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Gg.copy(e) : Gg.set(e, t, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), Dp.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Yo.lookAt(Dp, Gg, this.up) : Yo.lookAt(Gg, Dp, this.up), this.quaternion.setFromRotationMatrix(Yo), r && (Yo.extractRotation(r.matrixWorld), Sd.setFromRotationMatrix(Yo), this.quaternion.premultiply(Sd.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(LI)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(DI)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Yo.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Yo.multiply(e.parent.matrixWorld)), e.applyMatrix4(Yo), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const l = this.children[n].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const r = this.children;
    for (let o = 0, l = r.length; o < l; o++)
      r[o].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Dp, e, CI), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Dp, PI, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n];
      (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let o = 0, l = r.length; o < l; o++) {
        const u = r[o];
        u.matrixWorldAutoUpdate === !0 && u.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((u) => ({
      boxInitialized: u.boxInitialized,
      boxMin: u.box.min.toArray(),
      boxMax: u.box.max.toArray(),
      sphereInitialized: u.sphereInitialized,
      sphereRadius: u.sphere.radius,
      sphereCenter: u.sphere.center.toArray()
    })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (r.boundingSphere = {
      center: r.boundingSphere.center.toArray(),
      radius: r.boundingSphere.radius
    }), this.boundingBox !== null && (r.boundingBox = {
      min: r.boundingBox.min.toArray(),
      max: r.boundingBox.max.toArray()
    }));
    function o(u, d) {
      return u[d.uuid] === void 0 && (u[d.uuid] = d.toJSON(e)), d.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = o(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const d = u.shapes;
        if (Array.isArray(d))
          for (let h = 0, m = d.length; h < m; h++) {
            const g = d[h];
            o(e.shapes, g);
          }
        else
          o(e.shapes, d);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const u = [];
        for (let d = 0, h = this.material.length; d < h; d++)
          u.push(o(e.materials, this.material[d]));
        r.material = u;
      } else
        r.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let u = 0; u < this.children.length; u++)
        r.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const d = this.animations[u];
        r.animations.push(o(e.animations, d));
      }
    }
    if (t) {
      const u = l(e.geometries), d = l(e.materials), h = l(e.textures), m = l(e.images), g = l(e.shapes), y = l(e.skeletons), _ = l(e.animations), E = l(e.nodes);
      u.length > 0 && (n.geometries = u), d.length > 0 && (n.materials = d), h.length > 0 && (n.textures = h), m.length > 0 && (n.images = m), g.length > 0 && (n.shapes = g), y.length > 0 && (n.skeletons = y), _.length > 0 && (n.animations = _), E.length > 0 && (n.nodes = E);
    }
    return n.object = r, n;
    function l(u) {
      const d = [];
      for (const h in u) {
        const m = u[h];
        delete m.metadata, d.push(m);
      }
      return d;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
Dn.DEFAULT_UP = /* @__PURE__ */ new j(0, 1, 0);
Dn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Dn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Fa = /* @__PURE__ */ new j(), qo = /* @__PURE__ */ new j(), mS = /* @__PURE__ */ new j(), Zo = /* @__PURE__ */ new j(), Md = /* @__PURE__ */ new j(), Ed = /* @__PURE__ */ new j(), Ww = /* @__PURE__ */ new j(), vS = /* @__PURE__ */ new j(), gS = /* @__PURE__ */ new j(), yS = /* @__PURE__ */ new j();
let Wg = !1;
class Ms {
  constructor(e = new j(), t = new j(), n = new j()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, r) {
    r.subVectors(n, t), Fa.subVectors(e, t), r.cross(Fa);
    const o = r.lengthSq();
    return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, r, o) {
    Fa.subVectors(r, t), qo.subVectors(n, t), mS.subVectors(e, t);
    const l = Fa.dot(Fa), u = Fa.dot(qo), d = Fa.dot(mS), h = qo.dot(qo), m = qo.dot(mS), g = l * h - u * u;
    if (g === 0)
      return o.set(0, 0, 0), null;
    const y = 1 / g, _ = (h * d - u * m) * y, E = (l * m - u * d) * y;
    return o.set(1 - _ - E, E, _);
  }
  static containsPoint(e, t, n, r) {
    return this.getBarycoord(e, t, n, r, Zo) === null ? !1 : Zo.x >= 0 && Zo.y >= 0 && Zo.x + Zo.y <= 1;
  }
  static getUV(e, t, n, r, o, l, u, d) {
    return Wg === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Wg = !0), this.getInterpolation(e, t, n, r, o, l, u, d);
  }
  static getInterpolation(e, t, n, r, o, l, u, d) {
    return this.getBarycoord(e, t, n, r, Zo) === null ? (d.x = 0, d.y = 0, "z" in d && (d.z = 0), "w" in d && (d.w = 0), null) : (d.setScalar(0), d.addScaledVector(o, Zo.x), d.addScaledVector(l, Zo.y), d.addScaledVector(u, Zo.z), d);
  }
  static isFrontFacing(e, t, n, r) {
    return Fa.subVectors(n, t), qo.subVectors(e, t), Fa.cross(qo).dot(r) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, r) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, n, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Fa.subVectors(this.c, this.b), qo.subVectors(this.a, this.b), Fa.cross(qo).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ms.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ms.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, r, o) {
    return Wg === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Wg = !0), Ms.getInterpolation(e, this.a, this.b, this.c, t, n, r, o);
  }
  getInterpolation(e, t, n, r, o) {
    return Ms.getInterpolation(e, this.a, this.b, this.c, t, n, r, o);
  }
  containsPoint(e) {
    return Ms.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ms.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, r = this.b, o = this.c;
    let l, u;
    Md.subVectors(r, n), Ed.subVectors(o, n), vS.subVectors(e, n);
    const d = Md.dot(vS), h = Ed.dot(vS);
    if (d <= 0 && h <= 0)
      return t.copy(n);
    gS.subVectors(e, r);
    const m = Md.dot(gS), g = Ed.dot(gS);
    if (m >= 0 && g <= m)
      return t.copy(r);
    const y = d * g - m * h;
    if (y <= 0 && d >= 0 && m <= 0)
      return l = d / (d - m), t.copy(n).addScaledVector(Md, l);
    yS.subVectors(e, o);
    const _ = Md.dot(yS), E = Ed.dot(yS);
    if (E >= 0 && _ <= E)
      return t.copy(o);
    const w = _ * h - d * E;
    if (w <= 0 && h >= 0 && E <= 0)
      return u = h / (h - E), t.copy(n).addScaledVector(Ed, u);
    const T = m * E - _ * g;
    if (T <= 0 && g - m >= 0 && _ - E >= 0)
      return Ww.subVectors(o, r), u = (g - m) / (g - m + (_ - E)), t.copy(r).addScaledVector(Ww, u);
    const M = 1 / (T + w + y);
    return l = w * M, u = y * M, t.copy(n).addScaledVector(Md, l).addScaledVector(Ed, u);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const kP = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, tu = { h: 0, s: 0, l: 0 }, Xg = { h: 0, s: 0, l: 0 };
function xS(i, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
}
class Tt {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = nr) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, zn.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, r = zn.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, zn.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, t, n, r = zn.workingColorSpace) {
    if (e = zE(e, 1), t = Mi(t, 0, 1), n = Mi(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const o = n <= 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - o;
      this.r = xS(l, o, e + 1 / 3), this.g = xS(l, o, e), this.b = xS(l, o, e - 1 / 3);
    }
    return zn.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = nr) {
    function n(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const l = r[1], u = r[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              t
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = r[1], l = o.length;
      if (l === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (l === 6)
        return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = nr) {
    const n = kP[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Jd(e.r), this.g = Jd(e.g), this.b = Jd(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = oS(e.r), this.g = oS(e.g), this.b = oS(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = nr) {
    return zn.fromWorkingColorSpace(Hr.copy(this), e), Math.round(Mi(Hr.r * 255, 0, 255)) * 65536 + Math.round(Mi(Hr.g * 255, 0, 255)) * 256 + Math.round(Mi(Hr.b * 255, 0, 255));
  }
  getHexString(e = nr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = zn.workingColorSpace) {
    zn.fromWorkingColorSpace(Hr.copy(this), t);
    const n = Hr.r, r = Hr.g, o = Hr.b, l = Math.max(n, r, o), u = Math.min(n, r, o);
    let d, h;
    const m = (u + l) / 2;
    if (u === l)
      d = 0, h = 0;
    else {
      const g = l - u;
      switch (h = m <= 0.5 ? g / (l + u) : g / (2 - l - u), l) {
        case n:
          d = (r - o) / g + (r < o ? 6 : 0);
          break;
        case r:
          d = (o - n) / g + 2;
          break;
        case o:
          d = (n - r) / g + 4;
          break;
      }
      d /= 6;
    }
    return e.h = d, e.s = h, e.l = m, e;
  }
  getRGB(e, t = zn.workingColorSpace) {
    return zn.fromWorkingColorSpace(Hr.copy(this), t), e.r = Hr.r, e.g = Hr.g, e.b = Hr.b, e;
  }
  getStyle(e = nr) {
    zn.fromWorkingColorSpace(Hr.copy(this), e);
    const t = Hr.r, n = Hr.g, r = Hr.b;
    return e !== nr ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(tu), this.setHSL(tu.h + e, tu.s + t, tu.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(tu), e.getHSL(Xg);
    const n = Jp(tu.h, Xg.h, t), r = Jp(tu.s, Xg.s, t), o = Jp(tu.l, Xg.l, t);
    return this.setHSL(n, r, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, r = this.b, o = e.elements;
    return this.r = o[0] * t + o[3] * n + o[6] * r, this.g = o[1] * t + o[4] * n + o[7] * r, this.b = o[2] * t + o[5] * n + o[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Hr = /* @__PURE__ */ new Tt();
Tt.NAMES = kP;
let NI = 0;
class Yr extends ul {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: NI++ }), this.uuid = ks(), this.name = "", this.type = "Material", this.blending = Nc, this.side = sl, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = jy, this.blendDst = Yy, this.blendEquation = uu, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Tt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = sm, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = qM, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Mc, this.stencilZFail = Mc, this.stencilZPass = Mc, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Nc && (n.blending = this.blending), this.side !== sl && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== jy && (n.blendSrc = this.blendSrc), this.blendDst !== Yy && (n.blendDst = this.blendDst), this.blendEquation !== uu && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== sm && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== qM && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Mc && (n.stencilFail = this.stencilFail), this.stencilZFail !== Mc && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Mc && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function r(o) {
      const l = [];
      for (const u in o) {
        const d = o[u];
        delete d.metadata, l.push(d);
      }
      return l;
    }
    if (t) {
      const o = r(e.textures), l = r(e.images);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const r = t.length;
      n = new Array(r);
      for (let o = 0; o !== r; ++o)
        n[o] = t[o].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Mu extends Yr {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Pm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Qo = /* @__PURE__ */ UI();
function UI() {
  const i = new ArrayBuffer(4), e = new Float32Array(i), t = new Uint32Array(i), n = new Uint32Array(512), r = new Uint32Array(512);
  for (let d = 0; d < 256; ++d) {
    const h = d - 127;
    h < -27 ? (n[d] = 0, n[d | 256] = 32768, r[d] = 24, r[d | 256] = 24) : h < -14 ? (n[d] = 1024 >> -h - 14, n[d | 256] = 1024 >> -h - 14 | 32768, r[d] = -h - 1, r[d | 256] = -h - 1) : h <= 15 ? (n[d] = h + 15 << 10, n[d | 256] = h + 15 << 10 | 32768, r[d] = 13, r[d | 256] = 13) : h < 128 ? (n[d] = 31744, n[d | 256] = 64512, r[d] = 24, r[d | 256] = 24) : (n[d] = 31744, n[d | 256] = 64512, r[d] = 13, r[d | 256] = 13);
  }
  const o = new Uint32Array(2048), l = new Uint32Array(64), u = new Uint32Array(64);
  for (let d = 1; d < 1024; ++d) {
    let h = d << 13, m = 0;
    for (; !(h & 8388608); )
      h <<= 1, m -= 8388608;
    h &= -8388609, m += 947912704, o[d] = h | m;
  }
  for (let d = 1024; d < 2048; ++d)
    o[d] = 939524096 + (d - 1024 << 13);
  for (let d = 1; d < 31; ++d)
    l[d] = d << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let d = 33; d < 63; ++d)
    l[d] = 2147483648 + (d - 32 << 23);
  l[63] = 3347054592;
  for (let d = 1; d < 64; ++d)
    d !== 32 && (u[d] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: r,
    mantissaTable: o,
    exponentTable: l,
    offsetTable: u
  };
}
function Ss(i) {
  Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = Mi(i, -65504, 65504), Qo.floatView[0] = i;
  const e = Qo.uint32View[0], t = e >> 23 & 511;
  return Qo.baseTable[t] + ((e & 8388607) >> Qo.shiftTable[t]);
}
function jp(i) {
  const e = i >> 10;
  return Qo.uint32View[0] = Qo.mantissaTable[Qo.offsetTable[e] + (i & 1023)] + Qo.exponentTable[e], Qo.floatView[0];
}
const OI = {
  toHalfFloat: Ss,
  fromHalfFloat: jp
}, Xi = /* @__PURE__ */ new j(), jg = /* @__PURE__ */ new Oe();
class Vn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = vm, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Va, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let r = 0, o = this.itemSize; r < o; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        jg.fromBufferAttribute(this, t), jg.applyMatrix3(e), this.setXY(t, jg.x, jg.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Xi.fromBufferAttribute(this, t), Xi.applyMatrix3(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Xi.fromBufferAttribute(this, t), Xi.applyMatrix4(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Xi.fromBufferAttribute(this, t), Xi.applyNormalMatrix(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Xi.fromBufferAttribute(this, t), Xi.transformDirection(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Es(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = dn(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = dn(t, this.array), n = dn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, r) {
    return e *= this.itemSize, this.normalized && (t = dn(t, this.array), n = dn(n, this.array), r = dn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, n, r, o) {
    return e *= this.itemSize, this.normalized && (t = dn(t, this.array), n = dn(n, this.array), r = dn(r, this.array), o = dn(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== vm && (e.usage = this.usage), e;
  }
}
class II extends Vn {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class FI extends Vn {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class zI extends Vn {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class BI extends Vn {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class HE extends Vn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class VI extends Vn {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class kE extends Vn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class HI extends Vn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = jp(this.array[e * this.itemSize]);
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize] = Ss(t), this;
  }
  getY(e) {
    let t = jp(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize + 1] = Ss(t), this;
  }
  getZ(e) {
    let t = jp(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize + 2] = Ss(t), this;
  }
  getW(e) {
    let t = jp(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.array[e * this.itemSize + 3] = Ss(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = dn(t, this.array), n = dn(n, this.array)), this.array[e + 0] = Ss(t), this.array[e + 1] = Ss(n), this;
  }
  setXYZ(e, t, n, r) {
    return e *= this.itemSize, this.normalized && (t = dn(t, this.array), n = dn(n, this.array), r = dn(r, this.array)), this.array[e + 0] = Ss(t), this.array[e + 1] = Ss(n), this.array[e + 2] = Ss(r), this;
  }
  setXYZW(e, t, n, r, o) {
    return e *= this.itemSize, this.normalized && (t = dn(t, this.array), n = dn(n, this.array), r = dn(r, this.array), o = dn(o, this.array)), this.array[e + 0] = Ss(t), this.array[e + 1] = Ss(n), this.array[e + 2] = Ss(r), this.array[e + 3] = Ss(o), this;
  }
}
class Ot extends Vn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class kI extends Vn {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let GI = 0;
const da = /* @__PURE__ */ new $t(), _S = /* @__PURE__ */ new Dn(), bd = /* @__PURE__ */ new j(), Bs = /* @__PURE__ */ new as(), Np = /* @__PURE__ */ new as(), cr = /* @__PURE__ */ new j();
class gn extends ul {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: GI++ }), this.uuid = ks(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (BP(e) ? kE : HE)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const o = new vn().getNormalMatrix(e);
      n.applyNormalMatrix(o), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return da.makeRotationFromQuaternion(e), this.applyMatrix4(da), this;
  }
  rotateX(e) {
    return da.makeRotationX(e), this.applyMatrix4(da), this;
  }
  rotateY(e) {
    return da.makeRotationY(e), this.applyMatrix4(da), this;
  }
  rotateZ(e) {
    return da.makeRotationZ(e), this.applyMatrix4(da), this;
  }
  translate(e, t, n) {
    return da.makeTranslation(e, t, n), this.applyMatrix4(da), this;
  }
  scale(e, t, n) {
    return da.makeScale(e, t, n), this.applyMatrix4(da), this;
  }
  lookAt(e) {
    return _S.lookAt(e), _S.updateMatrix(), this.applyMatrix4(_S.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(bd).negate(), this.translate(bd.x, bd.y, bd.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new Ot(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new as());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new j(-1 / 0, -1 / 0, -1 / 0),
        new j(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, r = t.length; n < r; n++) {
          const o = t[n];
          Bs.setFromBufferAttribute(o), this.morphTargetsRelative ? (cr.addVectors(this.boundingBox.min, Bs.min), this.boundingBox.expandByPoint(cr), cr.addVectors(this.boundingBox.max, Bs.max), this.boundingBox.expandByPoint(cr)) : (this.boundingBox.expandByPoint(Bs.min), this.boundingBox.expandByPoint(Bs.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new jr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new j(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Bs.setFromBufferAttribute(e), t)
        for (let o = 0, l = t.length; o < l; o++) {
          const u = t[o];
          Np.setFromBufferAttribute(u), this.morphTargetsRelative ? (cr.addVectors(Bs.min, Np.min), Bs.expandByPoint(cr), cr.addVectors(Bs.max, Np.max), Bs.expandByPoint(cr)) : (Bs.expandByPoint(Np.min), Bs.expandByPoint(Np.max));
        }
      Bs.getCenter(n);
      let r = 0;
      for (let o = 0, l = e.count; o < l; o++)
        cr.fromBufferAttribute(e, o), r = Math.max(r, n.distanceToSquared(cr));
      if (t)
        for (let o = 0, l = t.length; o < l; o++) {
          const u = t[o], d = this.morphTargetsRelative;
          for (let h = 0, m = u.count; h < m; h++)
            cr.fromBufferAttribute(u, h), d && (bd.fromBufferAttribute(e, h), cr.add(bd)), r = Math.max(r, n.distanceToSquared(cr));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, r = t.position.array, o = t.normal.array, l = t.uv.array, u = r.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Vn(new Float32Array(4 * u), 4));
    const d = this.getAttribute("tangent").array, h = [], m = [];
    for (let O = 0; O < u; O++)
      h[O] = new j(), m[O] = new j();
    const g = new j(), y = new j(), _ = new j(), E = new Oe(), w = new Oe(), T = new Oe(), M = new j(), C = new j();
    function A(O, q, le) {
      g.fromArray(r, O * 3), y.fromArray(r, q * 3), _.fromArray(r, le * 3), E.fromArray(l, O * 2), w.fromArray(l, q * 2), T.fromArray(l, le * 2), y.sub(g), _.sub(g), w.sub(E), T.sub(E);
      const ye = 1 / (w.x * T.y - T.x * w.y);
      isFinite(ye) && (M.copy(y).multiplyScalar(T.y).addScaledVector(_, -w.y).multiplyScalar(ye), C.copy(_).multiplyScalar(w.x).addScaledVector(y, -T.x).multiplyScalar(ye), h[O].add(M), h[q].add(M), h[le].add(M), m[O].add(C), m[q].add(C), m[le].add(C));
    }
    let N = this.groups;
    N.length === 0 && (N = [{
      start: 0,
      count: n.length
    }]);
    for (let O = 0, q = N.length; O < q; ++O) {
      const le = N[O], ye = le.start, K = le.count;
      for (let oe = ye, ie = ye + K; oe < ie; oe += 3)
        A(
          n[oe + 0],
          n[oe + 1],
          n[oe + 2]
        );
    }
    const z = new j(), I = new j(), V = new j(), W = new j();
    function U(O) {
      V.fromArray(o, O * 3), W.copy(V);
      const q = h[O];
      z.copy(q), z.sub(V.multiplyScalar(V.dot(q))).normalize(), I.crossVectors(W, q);
      const ye = I.dot(m[O]) < 0 ? -1 : 1;
      d[O * 4] = z.x, d[O * 4 + 1] = z.y, d[O * 4 + 2] = z.z, d[O * 4 + 3] = ye;
    }
    for (let O = 0, q = N.length; O < q; ++O) {
      const le = N[O], ye = le.start, K = le.count;
      for (let oe = ye, ie = ye + K; oe < ie; oe += 3)
        U(n[oe + 0]), U(n[oe + 1]), U(n[oe + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Vn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let y = 0, _ = n.count; y < _; y++)
          n.setXYZ(y, 0, 0, 0);
      const r = new j(), o = new j(), l = new j(), u = new j(), d = new j(), h = new j(), m = new j(), g = new j();
      if (e)
        for (let y = 0, _ = e.count; y < _; y += 3) {
          const E = e.getX(y + 0), w = e.getX(y + 1), T = e.getX(y + 2);
          r.fromBufferAttribute(t, E), o.fromBufferAttribute(t, w), l.fromBufferAttribute(t, T), m.subVectors(l, o), g.subVectors(r, o), m.cross(g), u.fromBufferAttribute(n, E), d.fromBufferAttribute(n, w), h.fromBufferAttribute(n, T), u.add(m), d.add(m), h.add(m), n.setXYZ(E, u.x, u.y, u.z), n.setXYZ(w, d.x, d.y, d.z), n.setXYZ(T, h.x, h.y, h.z);
        }
      else
        for (let y = 0, _ = t.count; y < _; y += 3)
          r.fromBufferAttribute(t, y + 0), o.fromBufferAttribute(t, y + 1), l.fromBufferAttribute(t, y + 2), m.subVectors(l, o), g.subVectors(r, o), m.cross(g), n.setXYZ(y + 0, m.x, m.y, m.z), n.setXYZ(y + 1, m.x, m.y, m.z), n.setXYZ(y + 2, m.x, m.y, m.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      cr.fromBufferAttribute(e, t), cr.normalize(), e.setXYZ(t, cr.x, cr.y, cr.z);
  }
  toNonIndexed() {
    function e(u, d) {
      const h = u.array, m = u.itemSize, g = u.normalized, y = new h.constructor(d.length * m);
      let _ = 0, E = 0;
      for (let w = 0, T = d.length; w < T; w++) {
        u.isInterleavedBufferAttribute ? _ = d[w] * u.data.stride + u.offset : _ = d[w] * m;
        for (let M = 0; M < m; M++)
          y[E++] = h[_++];
      }
      return new Vn(y, m, g);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new gn(), n = this.index.array, r = this.attributes;
    for (const u in r) {
      const d = r[u], h = e(d, n);
      t.setAttribute(u, h);
    }
    const o = this.morphAttributes;
    for (const u in o) {
      const d = [], h = o[u];
      for (let m = 0, g = h.length; m < g; m++) {
        const y = h[m], _ = e(y, n);
        d.push(_);
      }
      t.morphAttributes[u] = d;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let u = 0, d = l.length; u < d; u++) {
      const h = l[u];
      t.addGroup(h.start, h.count, h.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const d = this.parameters;
      for (const h in d)
        d[h] !== void 0 && (e[h] = d[h]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const d in n) {
      const h = n[d];
      e.data.attributes[d] = h.toJSON(e.data);
    }
    const r = {};
    let o = !1;
    for (const d in this.morphAttributes) {
      const h = this.morphAttributes[d], m = [];
      for (let g = 0, y = h.length; g < y; g++) {
        const _ = h[g];
        m.push(_.toJSON(e.data));
      }
      m.length > 0 && (r[d] = m, o = !0);
    }
    o && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const u = this.boundingSphere;
    return u !== null && (e.data.boundingSphere = {
      center: u.center.toArray(),
      radius: u.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const r = e.attributes;
    for (const h in r) {
      const m = r[h];
      this.setAttribute(h, m.clone(t));
    }
    const o = e.morphAttributes;
    for (const h in o) {
      const m = [], g = o[h];
      for (let y = 0, _ = g.length; y < _; y++)
        m.push(g[y].clone(t));
      this.morphAttributes[h] = m;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let h = 0, m = l.length; h < m; h++) {
      const g = l[h];
      this.addGroup(g.start, g.count, g.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const d = e.boundingSphere;
    return d !== null && (this.boundingSphere = d.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Xw = /* @__PURE__ */ new $t(), fc = /* @__PURE__ */ new Gc(), Yg = /* @__PURE__ */ new jr(), jw = /* @__PURE__ */ new j(), Td = /* @__PURE__ */ new j(), wd = /* @__PURE__ */ new j(), Ad = /* @__PURE__ */ new j(), SS = /* @__PURE__ */ new j(), qg = /* @__PURE__ */ new j(), Zg = /* @__PURE__ */ new Oe(), Kg = /* @__PURE__ */ new Oe(), Jg = /* @__PURE__ */ new Oe(), Yw = /* @__PURE__ */ new j(), qw = /* @__PURE__ */ new j(), Zw = /* @__PURE__ */ new j(), Qg = /* @__PURE__ */ new j(), $g = /* @__PURE__ */ new j();
class ir extends Dn {
  constructor(e = new gn(), t = new Mu()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = r.length; o < l; o++) {
          const u = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, r = n.attributes.position, o = n.morphAttributes.position, l = n.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const u = this.morphTargetInfluences;
    if (o && u) {
      qg.set(0, 0, 0);
      for (let d = 0, h = o.length; d < h; d++) {
        const m = u[d], g = o[d];
        m !== 0 && (SS.fromBufferAttribute(g, e), l ? qg.addScaledVector(SS, m) : qg.addScaledVector(SS.sub(t), m));
      }
      t.add(qg);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.material, o = this.matrixWorld;
    r !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Yg.copy(n.boundingSphere), Yg.applyMatrix4(o), fc.copy(e.ray).recast(e.near), !(Yg.containsPoint(fc.origin) === !1 && (fc.intersectSphere(Yg, jw) === null || fc.origin.distanceToSquared(jw) > (e.far - e.near) ** 2)) && (Xw.copy(o).invert(), fc.copy(e.ray).applyMatrix4(Xw), !(n.boundingBox !== null && fc.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, fc)));
  }
  _computeIntersections(e, t, n) {
    let r;
    const o = this.geometry, l = this.material, u = o.index, d = o.attributes.position, h = o.attributes.uv, m = o.attributes.uv1, g = o.attributes.normal, y = o.groups, _ = o.drawRange;
    if (u !== null)
      if (Array.isArray(l))
        for (let E = 0, w = y.length; E < w; E++) {
          const T = y[E], M = l[T.materialIndex], C = Math.max(T.start, _.start), A = Math.min(u.count, Math.min(T.start + T.count, _.start + _.count));
          for (let N = C, z = A; N < z; N += 3) {
            const I = u.getX(N), V = u.getX(N + 1), W = u.getX(N + 2);
            r = ey(this, M, e, n, h, m, g, I, V, W), r && (r.faceIndex = Math.floor(N / 3), r.face.materialIndex = T.materialIndex, t.push(r));
          }
        }
      else {
        const E = Math.max(0, _.start), w = Math.min(u.count, _.start + _.count);
        for (let T = E, M = w; T < M; T += 3) {
          const C = u.getX(T), A = u.getX(T + 1), N = u.getX(T + 2);
          r = ey(this, l, e, n, h, m, g, C, A, N), r && (r.faceIndex = Math.floor(T / 3), t.push(r));
        }
      }
    else if (d !== void 0)
      if (Array.isArray(l))
        for (let E = 0, w = y.length; E < w; E++) {
          const T = y[E], M = l[T.materialIndex], C = Math.max(T.start, _.start), A = Math.min(d.count, Math.min(T.start + T.count, _.start + _.count));
          for (let N = C, z = A; N < z; N += 3) {
            const I = N, V = N + 1, W = N + 2;
            r = ey(this, M, e, n, h, m, g, I, V, W), r && (r.faceIndex = Math.floor(N / 3), r.face.materialIndex = T.materialIndex, t.push(r));
          }
        }
      else {
        const E = Math.max(0, _.start), w = Math.min(d.count, _.start + _.count);
        for (let T = E, M = w; T < M; T += 3) {
          const C = T, A = T + 1, N = T + 2;
          r = ey(this, l, e, n, h, m, g, C, A, N), r && (r.faceIndex = Math.floor(T / 3), t.push(r));
        }
      }
  }
}
function WI(i, e, t, n, r, o, l, u) {
  let d;
  if (e.side === ss ? d = n.intersectTriangle(l, o, r, !0, u) : d = n.intersectTriangle(r, o, l, e.side === sl, u), d === null) return null;
  $g.copy(u), $g.applyMatrix4(i.matrixWorld);
  const h = t.ray.origin.distanceTo($g);
  return h < t.near || h > t.far ? null : {
    distance: h,
    point: $g.clone(),
    object: i
  };
}
function ey(i, e, t, n, r, o, l, u, d, h) {
  i.getVertexPosition(u, Td), i.getVertexPosition(d, wd), i.getVertexPosition(h, Ad);
  const m = WI(i, e, t, n, Td, wd, Ad, Qg);
  if (m) {
    r && (Zg.fromBufferAttribute(r, u), Kg.fromBufferAttribute(r, d), Jg.fromBufferAttribute(r, h), m.uv = Ms.getInterpolation(Qg, Td, wd, Ad, Zg, Kg, Jg, new Oe())), o && (Zg.fromBufferAttribute(o, u), Kg.fromBufferAttribute(o, d), Jg.fromBufferAttribute(o, h), m.uv1 = Ms.getInterpolation(Qg, Td, wd, Ad, Zg, Kg, Jg, new Oe()), m.uv2 = m.uv1), l && (Yw.fromBufferAttribute(l, u), qw.fromBufferAttribute(l, d), Zw.fromBufferAttribute(l, h), m.normal = Ms.getInterpolation(Qg, Td, wd, Ad, Yw, qw, Zw, new j()), m.normal.dot(n.direction) > 0 && m.normal.multiplyScalar(-1));
    const g = {
      a: u,
      b: d,
      c: h,
      normal: new j(),
      materialIndex: 0
    };
    Ms.getNormal(Td, wd, Ad, g.normal), m.face = g;
  }
  return m;
}
class Wc extends gn {
  constructor(e = 1, t = 1, n = 1, r = 1, o = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: r,
      heightSegments: o,
      depthSegments: l
    };
    const u = this;
    r = Math.floor(r), o = Math.floor(o), l = Math.floor(l);
    const d = [], h = [], m = [], g = [];
    let y = 0, _ = 0;
    E("z", "y", "x", -1, -1, n, t, e, l, o, 0), E("z", "y", "x", 1, -1, n, t, -e, l, o, 1), E("x", "z", "y", 1, 1, e, n, t, r, l, 2), E("x", "z", "y", 1, -1, e, n, -t, r, l, 3), E("x", "y", "z", 1, -1, e, t, n, r, o, 4), E("x", "y", "z", -1, -1, e, t, -n, r, o, 5), this.setIndex(d), this.setAttribute("position", new Ot(h, 3)), this.setAttribute("normal", new Ot(m, 3)), this.setAttribute("uv", new Ot(g, 2));
    function E(w, T, M, C, A, N, z, I, V, W, U) {
      const O = N / V, q = z / W, le = N / 2, ye = z / 2, K = I / 2, oe = V + 1, ie = W + 1;
      let Ee = 0, Q = 0;
      const se = new j();
      for (let re = 0; re < ie; re++) {
        const ue = re * q - ye;
        for (let Le = 0; Le < oe; Le++) {
          const pe = Le * O - le;
          se[w] = pe * C, se[T] = ue * A, se[M] = K, h.push(se.x, se.y, se.z), se[w] = 0, se[T] = 0, se[M] = I > 0 ? 1 : -1, m.push(se.x, se.y, se.z), g.push(Le / V), g.push(1 - re / W), Ee += 1;
        }
      }
      for (let re = 0; re < W; re++)
        for (let ue = 0; ue < V; ue++) {
          const Le = y + ue + oe * re, pe = y + ue + oe * (re + 1), Ae = y + (ue + 1) + oe * (re + 1), qe = y + (ue + 1) + oe * re;
          d.push(Le, pe, qe), d.push(pe, Ae, qe), Q += 6;
        }
      u.addGroup(_, Q, U), _ += Q, y += Ee;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wc(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function th(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const r = i[t][n];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r;
    }
  }
  return e;
}
function ts(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = th(i[t]);
    for (const r in n)
      e[r] = n[r];
  }
  return e;
}
function XI(i) {
  const e = [];
  for (let t = 0; t < i.length; t++)
    e.push(i[t].clone());
  return e;
}
function GP(i) {
  return i.getRenderTarget() === null ? i.outputColorSpace : zn.workingColorSpace;
}
const WP = { clone: th, merge: ts };
var jI = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, YI = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class _o extends Yr {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = jI, this.fragmentShader = YI, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1,
      // set to use shader texture LOD
      clipCullDistance: !1
      // set to use vertex shader clipping
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = th(e.uniforms), this.uniformsGroups = XI(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const l = this.uniforms[r].value;
      l && l.isTexture ? t.uniforms[r] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[r] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[r] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[r] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[r] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[r] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[r] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[r] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Nm extends Dn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new $t(), this.projectionMatrix = new $t(), this.projectionMatrixInverse = new $t(), this.coordinateSystem = Ha;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ii extends Nm {
  constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = eh * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(Uc * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return eh * 2 * Math.atan(
      Math.tan(Uc * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, r, o, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Uc * 0.5 * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, o = -0.5 * r;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const d = l.fullWidth, h = l.fullHeight;
      o += l.offsetX * r / d, t -= l.offsetY * n / h, r *= l.width / d, n *= l.height / h;
    }
    const u = this.filmOffset;
    u !== 0 && (o += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Rd = -90, Cd = 1;
class XP extends Dn {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new Ii(Rd, Cd, e, t);
    r.layers = this.layers, this.add(r);
    const o = new Ii(Rd, Cd, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Ii(Rd, Cd, e, t);
    l.layers = this.layers, this.add(l);
    const u = new Ii(Rd, Cd, e, t);
    u.layers = this.layers, this.add(u);
    const d = new Ii(Rd, Cd, e, t);
    d.layers = this.layers, this.add(d);
    const h = new Ii(Rd, Cd, e, t);
    h.layers = this.layers, this.add(h);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, r, o, l, u, d] = t;
    for (const h of t) this.remove(h);
    if (e === Ha)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), u.up.set(0, 1, 0), u.lookAt(0, 0, 1), d.up.set(0, 1, 0), d.lookAt(0, 0, -1);
    else if (e === $d)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), u.up.set(0, -1, 0), u.lookAt(0, 0, 1), d.up.set(0, -1, 0), d.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const h of t)
      this.add(h), h.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, l, u, d, h, m] = this.children, g = e.getRenderTarget(), y = e.getActiveCubeFace(), _ = e.getActiveMipmapLevel(), E = e.xr.enabled;
    e.xr.enabled = !1;
    const w = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, o), e.setRenderTarget(n, 1, r), e.render(t, l), e.setRenderTarget(n, 2, r), e.render(t, u), e.setRenderTarget(n, 3, r), e.render(t, d), e.setRenderTarget(n, 4, r), e.render(t, h), n.texture.generateMipmaps = w, e.setRenderTarget(n, 5, r), e.render(t, m), e.setRenderTarget(g, y, _), e.xr.enabled = E, n.texture.needsPMREMUpdate = !0;
  }
}
class Um extends Fi {
  constructor(e, t, n, r, o, l, u, d, h, m) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : al, super(e, t, n, r, o, l, u, d, h, m), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class jP extends ka {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, r = [n, n, n, n, n, n];
    t.encoding !== void 0 && (Qp("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === du ? nr : Vs), this.texture = new Um(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Oi;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new Wc(5, 5, 5), o = new _o({
      name: "CubemapFromEquirect",
      uniforms: th(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: ss,
      blending: nl
    });
    o.uniforms.tEquirect.value = t;
    const l = new ir(r, o), u = t.minFilter;
    return t.minFilter === gu && (t.minFilter = Oi), new XP(1, 10, this).update(e, l), t.minFilter = u, l.geometry.dispose(), l.material.dispose(), this;
  }
  clear(e, t, n, r) {
    const o = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, n, r);
    e.setRenderTarget(o);
  }
}
const MS = /* @__PURE__ */ new j(), qI = /* @__PURE__ */ new j(), ZI = /* @__PURE__ */ new vn();
class Jo {
  constructor(e = new j(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, r) {
    return this.normal.set(e, t, n), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const r = MS.subVectors(n, t).cross(qI.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(MS), r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / r;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(n, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || ZI.getNormalMatrix(e), r = this.coplanarPoint(MS).applyMatrix4(e), o = this.normal.applyMatrix3(n).normalize();
    return this.constant = -r.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const dc = /* @__PURE__ */ new jr(), ty = /* @__PURE__ */ new j();
class Om {
  constructor(e = new Jo(), t = new Jo(), n = new Jo(), r = new Jo(), o = new Jo(), l = new Jo()) {
    this.planes = [e, t, n, r, o, l];
  }
  set(e, t, n, r, o, l) {
    const u = this.planes;
    return u[0].copy(e), u[1].copy(t), u[2].copy(n), u[3].copy(r), u[4].copy(o), u[5].copy(l), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ha) {
    const n = this.planes, r = e.elements, o = r[0], l = r[1], u = r[2], d = r[3], h = r[4], m = r[5], g = r[6], y = r[7], _ = r[8], E = r[9], w = r[10], T = r[11], M = r[12], C = r[13], A = r[14], N = r[15];
    if (n[0].setComponents(d - o, y - h, T - _, N - M).normalize(), n[1].setComponents(d + o, y + h, T + _, N + M).normalize(), n[2].setComponents(d + l, y + m, T + E, N + C).normalize(), n[3].setComponents(d - l, y - m, T - E, N - C).normalize(), n[4].setComponents(d - u, y - g, T - w, N - A).normalize(), t === Ha)
      n[5].setComponents(d + u, y + g, T + w, N + A).normalize();
    else if (t === $d)
      n[5].setComponents(u, g, w, A).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), dc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), dc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(dc);
  }
  intersectsSprite(e) {
    return dc.center.set(0, 0, 0), dc.radius = 0.7071067811865476, dc.applyMatrix4(e.matrixWorld), this.intersectsSphere(dc);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, r = -e.radius;
    for (let o = 0; o < 6; o++)
      if (t[o].distanceToPoint(n) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = t[n];
      if (ty.x = r.normal.x > 0 ? e.max.x : e.min.x, ty.y = r.normal.y > 0 ? e.max.y : e.min.y, ty.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(ty) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function YP() {
  let i = null, e = !1, t = null, n = null;
  function r(o, l) {
    t(o, l), n = i.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = i.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      i.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(o) {
      t = o;
    },
    setContext: function(o) {
      i = o;
    }
  };
}
function KI(i, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function r(h, m) {
    const g = h.array, y = h.usage, _ = g.byteLength, E = i.createBuffer();
    i.bindBuffer(m, E), i.bufferData(m, g, y), h.onUploadCallback();
    let w;
    if (g instanceof Float32Array)
      w = i.FLOAT;
    else if (g instanceof Uint16Array)
      if (h.isFloat16BufferAttribute)
        if (t)
          w = i.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        w = i.UNSIGNED_SHORT;
    else if (g instanceof Int16Array)
      w = i.SHORT;
    else if (g instanceof Uint32Array)
      w = i.UNSIGNED_INT;
    else if (g instanceof Int32Array)
      w = i.INT;
    else if (g instanceof Int8Array)
      w = i.BYTE;
    else if (g instanceof Uint8Array)
      w = i.UNSIGNED_BYTE;
    else if (g instanceof Uint8ClampedArray)
      w = i.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + g);
    return {
      buffer: E,
      type: w,
      bytesPerElement: g.BYTES_PER_ELEMENT,
      version: h.version,
      size: _
    };
  }
  function o(h, m, g) {
    const y = m.array, _ = m._updateRange, E = m.updateRanges;
    if (i.bindBuffer(g, h), _.count === -1 && E.length === 0 && i.bufferSubData(g, 0, y), E.length !== 0) {
      for (let w = 0, T = E.length; w < T; w++) {
        const M = E[w];
        t ? i.bufferSubData(
          g,
          M.start * y.BYTES_PER_ELEMENT,
          y,
          M.start,
          M.count
        ) : i.bufferSubData(
          g,
          M.start * y.BYTES_PER_ELEMENT,
          y.subarray(M.start, M.start + M.count)
        );
      }
      m.clearUpdateRanges();
    }
    _.count !== -1 && (t ? i.bufferSubData(
      g,
      _.offset * y.BYTES_PER_ELEMENT,
      y,
      _.offset,
      _.count
    ) : i.bufferSubData(
      g,
      _.offset * y.BYTES_PER_ELEMENT,
      y.subarray(_.offset, _.offset + _.count)
    ), _.count = -1), m.onUploadCallback();
  }
  function l(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), n.get(h);
  }
  function u(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const m = n.get(h);
    m && (i.deleteBuffer(m.buffer), n.delete(h));
  }
  function d(h, m) {
    if (h.isGLBufferAttribute) {
      const y = n.get(h);
      (!y || y.version < h.version) && n.set(h, {
        buffer: h.buffer,
        type: h.type,
        bytesPerElement: h.elementSize,
        version: h.version
      });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const g = n.get(h);
    if (g === void 0)
      n.set(h, r(h, m));
    else if (g.version < h.version) {
      if (g.size !== h.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      o(g.buffer, h, m), g.version = h.version;
    }
  }
  return {
    get: l,
    remove: u,
    update: d
  };
}
class Im extends gn {
  constructor(e = 1, t = 1, n = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: r
    };
    const o = e / 2, l = t / 2, u = Math.floor(n), d = Math.floor(r), h = u + 1, m = d + 1, g = e / u, y = t / d, _ = [], E = [], w = [], T = [];
    for (let M = 0; M < m; M++) {
      const C = M * y - l;
      for (let A = 0; A < h; A++) {
        const N = A * g - o;
        E.push(N, -C, 0), w.push(0, 0, 1), T.push(A / u), T.push(1 - M / d);
      }
    }
    for (let M = 0; M < d; M++)
      for (let C = 0; C < u; C++) {
        const A = C + h * M, N = C + h * (M + 1), z = C + 1 + h * (M + 1), I = C + 1 + h * M;
        _.push(A, N, I), _.push(N, z, I);
      }
    this.setIndex(_), this.setAttribute("position", new Ot(E, 3)), this.setAttribute("normal", new Ot(w, 3)), this.setAttribute("uv", new Ot(T, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Im(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var JI = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, QI = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, $I = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, eF = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, tF = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, nF = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, iF = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, rF = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, sF = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, aF = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, oF = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, lF = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, uF = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, cF = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, fF = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, dF = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, hF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, pF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, mF = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, vF = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, gF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, yF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, xF = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, _F = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, SF = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, MF = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, EF = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, bF = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, TF = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, wF = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, AF = "gl_FragColor = linearToOutputTexel( gl_FragColor );", RF = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, CF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, PF = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, LF = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, DF = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, NF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, UF = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, OF = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, IF = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, FF = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, zF = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, BF = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, VF = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, HF = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, kF = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, GF = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, WF = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, XF = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, jF = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, YF = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, qF = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, ZF = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, KF = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, JF = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, QF = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, $F = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, ez = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, tz = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, nz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, iz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, rz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, sz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, az = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, oz = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, lz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, uz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, cz = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, fz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, dz = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, hz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, pz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, mz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, vz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, gz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, yz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, xz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, _z = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Sz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Mz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Ez = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, bz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Tz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, wz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Az = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Rz = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Cz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Pz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Lz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Dz = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, Nz = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Uz = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Oz = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Iz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Fz = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, zz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Bz = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Vz = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Hz = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, kz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Gz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Wz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Xz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, jz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Yz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, qz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Zz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Kz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Jz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Qz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, $z = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, eB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, tB = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, nB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, iB = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, rB = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, sB = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, aB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, oB = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, lB = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, uB = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, cB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, fB = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, dB = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hB = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, pB = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, mB = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, gB = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, yB = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, xB = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _B = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, SB = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, MB = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, EB = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bB = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, TB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, wB = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, AB = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, RB = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, CB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, fn = {
  alphahash_fragment: JI,
  alphahash_pars_fragment: QI,
  alphamap_fragment: $I,
  alphamap_pars_fragment: eF,
  alphatest_fragment: tF,
  alphatest_pars_fragment: nF,
  aomap_fragment: iF,
  aomap_pars_fragment: rF,
  batching_pars_vertex: sF,
  batching_vertex: aF,
  begin_vertex: oF,
  beginnormal_vertex: lF,
  bsdfs: uF,
  iridescence_fragment: cF,
  bumpmap_pars_fragment: fF,
  clipping_planes_fragment: dF,
  clipping_planes_pars_fragment: hF,
  clipping_planes_pars_vertex: pF,
  clipping_planes_vertex: mF,
  color_fragment: vF,
  color_pars_fragment: gF,
  color_pars_vertex: yF,
  color_vertex: xF,
  common: _F,
  cube_uv_reflection_fragment: SF,
  defaultnormal_vertex: MF,
  displacementmap_pars_vertex: EF,
  displacementmap_vertex: bF,
  emissivemap_fragment: TF,
  emissivemap_pars_fragment: wF,
  colorspace_fragment: AF,
  colorspace_pars_fragment: RF,
  envmap_fragment: CF,
  envmap_common_pars_fragment: PF,
  envmap_pars_fragment: LF,
  envmap_pars_vertex: DF,
  envmap_physical_pars_fragment: WF,
  envmap_vertex: NF,
  fog_vertex: UF,
  fog_pars_vertex: OF,
  fog_fragment: IF,
  fog_pars_fragment: FF,
  gradientmap_pars_fragment: zF,
  lightmap_fragment: BF,
  lightmap_pars_fragment: VF,
  lights_lambert_fragment: HF,
  lights_lambert_pars_fragment: kF,
  lights_pars_begin: GF,
  lights_toon_fragment: XF,
  lights_toon_pars_fragment: jF,
  lights_phong_fragment: YF,
  lights_phong_pars_fragment: qF,
  lights_physical_fragment: ZF,
  lights_physical_pars_fragment: KF,
  lights_fragment_begin: JF,
  lights_fragment_maps: QF,
  lights_fragment_end: $F,
  logdepthbuf_fragment: ez,
  logdepthbuf_pars_fragment: tz,
  logdepthbuf_pars_vertex: nz,
  logdepthbuf_vertex: iz,
  map_fragment: rz,
  map_pars_fragment: sz,
  map_particle_fragment: az,
  map_particle_pars_fragment: oz,
  metalnessmap_fragment: lz,
  metalnessmap_pars_fragment: uz,
  morphcolor_vertex: cz,
  morphnormal_vertex: fz,
  morphtarget_pars_vertex: dz,
  morphtarget_vertex: hz,
  normal_fragment_begin: pz,
  normal_fragment_maps: mz,
  normal_pars_fragment: vz,
  normal_pars_vertex: gz,
  normal_vertex: yz,
  normalmap_pars_fragment: xz,
  clearcoat_normal_fragment_begin: _z,
  clearcoat_normal_fragment_maps: Sz,
  clearcoat_pars_fragment: Mz,
  iridescence_pars_fragment: Ez,
  opaque_fragment: bz,
  packing: Tz,
  premultiplied_alpha_fragment: wz,
  project_vertex: Az,
  dithering_fragment: Rz,
  dithering_pars_fragment: Cz,
  roughnessmap_fragment: Pz,
  roughnessmap_pars_fragment: Lz,
  shadowmap_pars_fragment: Dz,
  shadowmap_pars_vertex: Nz,
  shadowmap_vertex: Uz,
  shadowmask_pars_fragment: Oz,
  skinbase_vertex: Iz,
  skinning_pars_vertex: Fz,
  skinning_vertex: zz,
  skinnormal_vertex: Bz,
  specularmap_fragment: Vz,
  specularmap_pars_fragment: Hz,
  tonemapping_fragment: kz,
  tonemapping_pars_fragment: Gz,
  transmission_fragment: Wz,
  transmission_pars_fragment: Xz,
  uv_pars_fragment: jz,
  uv_pars_vertex: Yz,
  uv_vertex: qz,
  worldpos_vertex: Zz,
  background_vert: Kz,
  background_frag: Jz,
  backgroundCube_vert: Qz,
  backgroundCube_frag: $z,
  cube_vert: eB,
  cube_frag: tB,
  depth_vert: nB,
  depth_frag: iB,
  distanceRGBA_vert: rB,
  distanceRGBA_frag: sB,
  equirect_vert: aB,
  equirect_frag: oB,
  linedashed_vert: lB,
  linedashed_frag: uB,
  meshbasic_vert: cB,
  meshbasic_frag: fB,
  meshlambert_vert: dB,
  meshlambert_frag: hB,
  meshmatcap_vert: pB,
  meshmatcap_frag: mB,
  meshnormal_vert: vB,
  meshnormal_frag: gB,
  meshphong_vert: yB,
  meshphong_frag: xB,
  meshphysical_vert: _B,
  meshphysical_frag: SB,
  meshtoon_vert: MB,
  meshtoon_frag: EB,
  points_vert: bB,
  points_frag: TB,
  shadow_vert: wB,
  shadow_frag: AB,
  sprite_vert: RB,
  sprite_frag: CB
}, ft = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new vn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new vn() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new vn() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new vn() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new vn() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new vn() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new vn() },
    normalScale: { value: /* @__PURE__ */ new Oe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new vn() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new vn() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new vn() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new vn() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Tt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new vn() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new vn() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Oe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new vn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new vn() },
    alphaTest: { value: 0 }
  }
}, Ba = {
  basic: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.specularmap,
      ft.envmap,
      ft.aomap,
      ft.lightmap,
      ft.fog
    ]),
    vertexShader: fn.meshbasic_vert,
    fragmentShader: fn.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.specularmap,
      ft.envmap,
      ft.aomap,
      ft.lightmap,
      ft.emissivemap,
      ft.bumpmap,
      ft.normalmap,
      ft.displacementmap,
      ft.fog,
      ft.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) }
      }
    ]),
    vertexShader: fn.meshlambert_vert,
    fragmentShader: fn.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.specularmap,
      ft.envmap,
      ft.aomap,
      ft.lightmap,
      ft.emissivemap,
      ft.bumpmap,
      ft.normalmap,
      ft.displacementmap,
      ft.fog,
      ft.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) },
        specular: { value: /* @__PURE__ */ new Tt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: fn.meshphong_vert,
    fragmentShader: fn.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.envmap,
      ft.aomap,
      ft.lightmap,
      ft.emissivemap,
      ft.bumpmap,
      ft.normalmap,
      ft.displacementmap,
      ft.roughnessmap,
      ft.metalnessmap,
      ft.fog,
      ft.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: fn.meshphysical_vert,
    fragmentShader: fn.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.aomap,
      ft.lightmap,
      ft.emissivemap,
      ft.bumpmap,
      ft.normalmap,
      ft.displacementmap,
      ft.gradientmap,
      ft.fog,
      ft.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) }
      }
    ]),
    vertexShader: fn.meshtoon_vert,
    fragmentShader: fn.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.bumpmap,
      ft.normalmap,
      ft.displacementmap,
      ft.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: fn.meshmatcap_vert,
    fragmentShader: fn.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ ts([
      ft.points,
      ft.fog
    ]),
    vertexShader: fn.points_vert,
    fragmentShader: fn.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: fn.linedashed_vert,
    fragmentShader: fn.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.displacementmap
    ]),
    vertexShader: fn.depth_vert,
    fragmentShader: fn.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.bumpmap,
      ft.normalmap,
      ft.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: fn.meshnormal_vert,
    fragmentShader: fn.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ ts([
      ft.sprite,
      ft.fog
    ]),
    vertexShader: fn.sprite_vert,
    fragmentShader: fn.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new vn() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: fn.background_vert,
    fragmentShader: fn.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: fn.backgroundCube_vert,
    fragmentShader: fn.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: fn.cube_vert,
    fragmentShader: fn.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: fn.equirect_vert,
    fragmentShader: fn.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ ts([
      ft.common,
      ft.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new j() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: fn.distanceRGBA_vert,
    fragmentShader: fn.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ ts([
      ft.lights,
      ft.fog,
      {
        color: { value: /* @__PURE__ */ new Tt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: fn.shadow_vert,
    fragmentShader: fn.shadow_frag
  }
};
Ba.physical = {
  uniforms: /* @__PURE__ */ ts([
    Ba.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new vn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new vn() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Oe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new vn() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new vn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new vn() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Tt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new vn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new vn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new vn() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Oe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new vn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Tt(0) },
      specularColor: { value: /* @__PURE__ */ new Tt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new vn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new vn() },
      anisotropyVector: { value: /* @__PURE__ */ new Oe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new vn() }
    }
  ]),
  vertexShader: fn.meshphysical_vert,
  fragmentShader: fn.meshphysical_frag
};
const ny = { r: 0, b: 0, g: 0 };
function PB(i, e, t, n, r, o, l) {
  const u = new Tt(0);
  let d = o === !0 ? 0 : 1, h, m, g = null, y = 0, _ = null;
  function E(T, M) {
    let C = !1, A = M.isScene === !0 ? M.background : null;
    A && A.isTexture && (A = (M.backgroundBlurriness > 0 ? t : e).get(A)), A === null ? w(u, d) : A && A.isColor && (w(A, 1), C = !0);
    const N = i.xr.getEnvironmentBlendMode();
    N === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, l) : N === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, l), (i.autoClear || C) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), A && (A.isCubeTexture || A.mapping === oh) ? (m === void 0 && (m = new ir(
      new Wc(1, 1, 1),
      new _o({
        name: "BackgroundCubeMaterial",
        uniforms: th(Ba.backgroundCube.uniforms),
        vertexShader: Ba.backgroundCube.vertexShader,
        fragmentShader: Ba.backgroundCube.fragmentShader,
        side: ss,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), m.geometry.deleteAttribute("normal"), m.geometry.deleteAttribute("uv"), m.onBeforeRender = function(z, I, V) {
      this.matrixWorld.copyPosition(V.matrixWorld);
    }, Object.defineProperty(m.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(m)), m.material.uniforms.envMap.value = A, m.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, m.material.uniforms.backgroundBlurriness.value = M.backgroundBlurriness, m.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, m.material.toneMapped = zn.getTransfer(A.colorSpace) !== Yn, (g !== A || y !== A.version || _ !== i.toneMapping) && (m.material.needsUpdate = !0, g = A, y = A.version, _ = i.toneMapping), m.layers.enableAll(), T.unshift(m, m.geometry, m.material, 0, 0, null)) : A && A.isTexture && (h === void 0 && (h = new ir(
      new Im(2, 2),
      new _o({
        name: "BackgroundMaterial",
        uniforms: th(Ba.background.uniforms),
        vertexShader: Ba.background.vertexShader,
        fragmentShader: Ba.background.fragmentShader,
        side: sl,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(h)), h.material.uniforms.t2D.value = A, h.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, h.material.toneMapped = zn.getTransfer(A.colorSpace) !== Yn, A.matrixAutoUpdate === !0 && A.updateMatrix(), h.material.uniforms.uvTransform.value.copy(A.matrix), (g !== A || y !== A.version || _ !== i.toneMapping) && (h.material.needsUpdate = !0, g = A, y = A.version, _ = i.toneMapping), h.layers.enableAll(), T.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function w(T, M) {
    T.getRGB(ny, GP(i)), n.buffers.color.setClear(ny.r, ny.g, ny.b, M, l);
  }
  return {
    getClearColor: function() {
      return u;
    },
    setClearColor: function(T, M = 1) {
      u.set(T), d = M, w(u, d);
    },
    getClearAlpha: function() {
      return d;
    },
    setClearAlpha: function(T) {
      d = T, w(u, d);
    },
    render: E
  };
}
function LB(i, e, t, n) {
  const r = i.getParameter(i.MAX_VERTEX_ATTRIBS), o = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), l = n.isWebGL2 || o !== null, u = {}, d = T(null);
  let h = d, m = !1;
  function g(K, oe, ie, Ee, Q) {
    let se = !1;
    if (l) {
      const re = w(Ee, ie, oe);
      h !== re && (h = re, _(h.object)), se = M(K, Ee, ie, Q), se && C(K, Ee, ie, Q);
    } else {
      const re = oe.wireframe === !0;
      (h.geometry !== Ee.id || h.program !== ie.id || h.wireframe !== re) && (h.geometry = Ee.id, h.program = ie.id, h.wireframe = re, se = !0);
    }
    Q !== null && t.update(Q, i.ELEMENT_ARRAY_BUFFER), (se || m) && (m = !1, W(K, oe, ie, Ee), Q !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(Q).buffer));
  }
  function y() {
    return n.isWebGL2 ? i.createVertexArray() : o.createVertexArrayOES();
  }
  function _(K) {
    return n.isWebGL2 ? i.bindVertexArray(K) : o.bindVertexArrayOES(K);
  }
  function E(K) {
    return n.isWebGL2 ? i.deleteVertexArray(K) : o.deleteVertexArrayOES(K);
  }
  function w(K, oe, ie) {
    const Ee = ie.wireframe === !0;
    let Q = u[K.id];
    Q === void 0 && (Q = {}, u[K.id] = Q);
    let se = Q[oe.id];
    se === void 0 && (se = {}, Q[oe.id] = se);
    let re = se[Ee];
    return re === void 0 && (re = T(y()), se[Ee] = re), re;
  }
  function T(K) {
    const oe = [], ie = [], Ee = [];
    for (let Q = 0; Q < r; Q++)
      oe[Q] = 0, ie[Q] = 0, Ee[Q] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: oe,
      enabledAttributes: ie,
      attributeDivisors: Ee,
      object: K,
      attributes: {},
      index: null
    };
  }
  function M(K, oe, ie, Ee) {
    const Q = h.attributes, se = oe.attributes;
    let re = 0;
    const ue = ie.getAttributes();
    for (const Le in ue)
      if (ue[Le].location >= 0) {
        const Ae = Q[Le];
        let qe = se[Le];
        if (qe === void 0 && (Le === "instanceMatrix" && K.instanceMatrix && (qe = K.instanceMatrix), Le === "instanceColor" && K.instanceColor && (qe = K.instanceColor)), Ae === void 0 || Ae.attribute !== qe || qe && Ae.data !== qe.data) return !0;
        re++;
      }
    return h.attributesNum !== re || h.index !== Ee;
  }
  function C(K, oe, ie, Ee) {
    const Q = {}, se = oe.attributes;
    let re = 0;
    const ue = ie.getAttributes();
    for (const Le in ue)
      if (ue[Le].location >= 0) {
        let Ae = se[Le];
        Ae === void 0 && (Le === "instanceMatrix" && K.instanceMatrix && (Ae = K.instanceMatrix), Le === "instanceColor" && K.instanceColor && (Ae = K.instanceColor));
        const qe = {};
        qe.attribute = Ae, Ae && Ae.data && (qe.data = Ae.data), Q[Le] = qe, re++;
      }
    h.attributes = Q, h.attributesNum = re, h.index = Ee;
  }
  function A() {
    const K = h.newAttributes;
    for (let oe = 0, ie = K.length; oe < ie; oe++)
      K[oe] = 0;
  }
  function N(K) {
    z(K, 0);
  }
  function z(K, oe) {
    const ie = h.newAttributes, Ee = h.enabledAttributes, Q = h.attributeDivisors;
    ie[K] = 1, Ee[K] === 0 && (i.enableVertexAttribArray(K), Ee[K] = 1), Q[K] !== oe && ((n.isWebGL2 ? i : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](K, oe), Q[K] = oe);
  }
  function I() {
    const K = h.newAttributes, oe = h.enabledAttributes;
    for (let ie = 0, Ee = oe.length; ie < Ee; ie++)
      oe[ie] !== K[ie] && (i.disableVertexAttribArray(ie), oe[ie] = 0);
  }
  function V(K, oe, ie, Ee, Q, se, re) {
    re === !0 ? i.vertexAttribIPointer(K, oe, ie, Q, se) : i.vertexAttribPointer(K, oe, ie, Ee, Q, se);
  }
  function W(K, oe, ie, Ee) {
    if (n.isWebGL2 === !1 && (K.isInstancedMesh || Ee.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    A();
    const Q = Ee.attributes, se = ie.getAttributes(), re = oe.defaultAttributeValues;
    for (const ue in se) {
      const Le = se[ue];
      if (Le.location >= 0) {
        let pe = Q[ue];
        if (pe === void 0 && (ue === "instanceMatrix" && K.instanceMatrix && (pe = K.instanceMatrix), ue === "instanceColor" && K.instanceColor && (pe = K.instanceColor)), pe !== void 0) {
          const Ae = pe.normalized, qe = pe.itemSize, je = t.get(pe);
          if (je === void 0) continue;
          const $e = je.buffer, Rt = je.type, Ut = je.bytesPerElement, ot = n.isWebGL2 === !0 && (Rt === i.INT || Rt === i.UNSIGNED_INT || pe.gpuType === RE);
          if (pe.isInterleavedBufferAttribute) {
            const pt = pe.data, J = pt.stride, Be = pe.offset;
            if (pt.isInstancedInterleavedBuffer) {
              for (let Pe = 0; Pe < Le.locationSize; Pe++)
                z(Le.location + Pe, pt.meshPerAttribute);
              K.isInstancedMesh !== !0 && Ee._maxInstanceCount === void 0 && (Ee._maxInstanceCount = pt.meshPerAttribute * pt.count);
            } else
              for (let Pe = 0; Pe < Le.locationSize; Pe++)
                N(Le.location + Pe);
            i.bindBuffer(i.ARRAY_BUFFER, $e);
            for (let Pe = 0; Pe < Le.locationSize; Pe++)
              V(
                Le.location + Pe,
                qe / Le.locationSize,
                Rt,
                Ae,
                J * Ut,
                (Be + qe / Le.locationSize * Pe) * Ut,
                ot
              );
          } else {
            if (pe.isInstancedBufferAttribute) {
              for (let pt = 0; pt < Le.locationSize; pt++)
                z(Le.location + pt, pe.meshPerAttribute);
              K.isInstancedMesh !== !0 && Ee._maxInstanceCount === void 0 && (Ee._maxInstanceCount = pe.meshPerAttribute * pe.count);
            } else
              for (let pt = 0; pt < Le.locationSize; pt++)
                N(Le.location + pt);
            i.bindBuffer(i.ARRAY_BUFFER, $e);
            for (let pt = 0; pt < Le.locationSize; pt++)
              V(
                Le.location + pt,
                qe / Le.locationSize,
                Rt,
                Ae,
                qe * Ut,
                qe / Le.locationSize * pt * Ut,
                ot
              );
          }
        } else if (re !== void 0) {
          const Ae = re[ue];
          if (Ae !== void 0)
            switch (Ae.length) {
              case 2:
                i.vertexAttrib2fv(Le.location, Ae);
                break;
              case 3:
                i.vertexAttrib3fv(Le.location, Ae);
                break;
              case 4:
                i.vertexAttrib4fv(Le.location, Ae);
                break;
              default:
                i.vertexAttrib1fv(Le.location, Ae);
            }
        }
      }
    }
    I();
  }
  function U() {
    le();
    for (const K in u) {
      const oe = u[K];
      for (const ie in oe) {
        const Ee = oe[ie];
        for (const Q in Ee)
          E(Ee[Q].object), delete Ee[Q];
        delete oe[ie];
      }
      delete u[K];
    }
  }
  function O(K) {
    if (u[K.id] === void 0) return;
    const oe = u[K.id];
    for (const ie in oe) {
      const Ee = oe[ie];
      for (const Q in Ee)
        E(Ee[Q].object), delete Ee[Q];
      delete oe[ie];
    }
    delete u[K.id];
  }
  function q(K) {
    for (const oe in u) {
      const ie = u[oe];
      if (ie[K.id] === void 0) continue;
      const Ee = ie[K.id];
      for (const Q in Ee)
        E(Ee[Q].object), delete Ee[Q];
      delete ie[K.id];
    }
  }
  function le() {
    ye(), m = !0, h !== d && (h = d, _(h.object));
  }
  function ye() {
    d.geometry = null, d.program = null, d.wireframe = !1;
  }
  return {
    setup: g,
    reset: le,
    resetDefaultState: ye,
    dispose: U,
    releaseStatesOfGeometry: O,
    releaseStatesOfProgram: q,
    initAttributes: A,
    enableAttribute: N,
    disableUnusedAttributes: I
  };
}
function DB(i, e, t, n) {
  const r = n.isWebGL2;
  let o;
  function l(m) {
    o = m;
  }
  function u(m, g) {
    i.drawArrays(o, m, g), t.update(g, o, 1);
  }
  function d(m, g, y) {
    if (y === 0) return;
    let _, E;
    if (r)
      _ = i, E = "drawArraysInstanced";
    else if (_ = e.get("ANGLE_instanced_arrays"), E = "drawArraysInstancedANGLE", _ === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    _[E](o, m, g, y), t.update(g, o, y);
  }
  function h(m, g, y) {
    if (y === 0) return;
    const _ = e.get("WEBGL_multi_draw");
    if (_ === null)
      for (let E = 0; E < y; E++)
        this.render(m[E], g[E]);
    else {
      _.multiDrawArraysWEBGL(o, m, 0, g, 0, y);
      let E = 0;
      for (let w = 0; w < y; w++)
        E += g[w];
      t.update(E, o, 1);
    }
  }
  this.setMode = l, this.render = u, this.renderInstances = d, this.renderMultiDraw = h;
}
function NB(i, e, t) {
  let n;
  function r() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const V = e.get("EXT_texture_filter_anisotropic");
      n = i.getParameter(V.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function o(V) {
    if (V === "highp") {
      if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
        return "highp";
      V = "mediump";
    }
    return V === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const l = typeof WebGL2RenderingContext < "u" && i.constructor.name === "WebGL2RenderingContext";
  let u = t.precision !== void 0 ? t.precision : "highp";
  const d = o(u);
  d !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", d, "instead."), u = d);
  const h = l || e.has("WEBGL_draw_buffers"), m = t.logarithmicDepthBuffer === !0, g = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), y = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = i.getParameter(i.MAX_TEXTURE_SIZE), E = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), w = i.getParameter(i.MAX_VERTEX_ATTRIBS), T = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), M = i.getParameter(i.MAX_VARYING_VECTORS), C = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), A = y > 0, N = l || e.has("OES_texture_float"), z = A && N, I = l ? i.getParameter(i.MAX_SAMPLES) : 0;
  return {
    isWebGL2: l,
    drawBuffers: h,
    getMaxAnisotropy: r,
    getMaxPrecision: o,
    precision: u,
    logarithmicDepthBuffer: m,
    maxTextures: g,
    maxVertexTextures: y,
    maxTextureSize: _,
    maxCubemapSize: E,
    maxAttributes: w,
    maxVertexUniforms: T,
    maxVaryings: M,
    maxFragmentUniforms: C,
    vertexTextures: A,
    floatFragmentTextures: N,
    floatVertexTextures: z,
    maxSamples: I
  };
}
function UB(i) {
  const e = this;
  let t = null, n = 0, r = !1, o = !1;
  const l = new Jo(), u = new vn(), d = { value: null, needsUpdate: !1 };
  this.uniform = d, this.numPlanes = 0, this.numIntersection = 0, this.init = function(g, y) {
    const _ = g.length !== 0 || y || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || r;
    return r = y, n = g.length, _;
  }, this.beginShadows = function() {
    o = !0, m(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(g, y) {
    t = m(g, y, 0);
  }, this.setState = function(g, y, _) {
    const E = g.clippingPlanes, w = g.clipIntersection, T = g.clipShadows, M = i.get(g);
    if (!r || E === null || E.length === 0 || o && !T)
      o ? m(null) : h();
    else {
      const C = o ? 0 : n, A = C * 4;
      let N = M.clippingState || null;
      d.value = N, N = m(E, y, A, _);
      for (let z = 0; z !== A; ++z)
        N[z] = t[z];
      M.clippingState = N, this.numIntersection = w ? this.numPlanes : 0, this.numPlanes += C;
    }
  };
  function h() {
    d.value !== t && (d.value = t, d.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function m(g, y, _, E) {
    const w = g !== null ? g.length : 0;
    let T = null;
    if (w !== 0) {
      if (T = d.value, E !== !0 || T === null) {
        const M = _ + w * 4, C = y.matrixWorldInverse;
        u.getNormalMatrix(C), (T === null || T.length < M) && (T = new Float32Array(M));
        for (let A = 0, N = _; A !== w; ++A, N += 4)
          l.copy(g[A]).applyMatrix4(C, u), l.normal.toArray(T, N), T[N + 3] = l.constant;
      }
      d.value = T, d.needsUpdate = !0;
    }
    return e.numPlanes = w, e.numIntersection = 0, T;
  }
}
function OB(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(l, u) {
    return u === am ? l.mapping = al : u === om && (l.mapping = vu), l;
  }
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping;
      if (u === am || u === om)
        if (e.has(l)) {
          const d = e.get(l).texture;
          return t(d, l.mapping);
        } else {
          const d = l.image;
          if (d && d.height > 0) {
            const h = new jP(d.height / 2);
            return h.fromEquirectangularTexture(i, l), e.set(l, h), l.addEventListener("dispose", r), t(h.texture, l.mapping);
          } else
            return null;
        }
    }
    return l;
  }
  function r(l) {
    const u = l.target;
    u.removeEventListener("dispose", r);
    const d = e.get(u);
    d !== void 0 && (e.delete(u), d.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: o
  };
}
class hu extends Nm {
  constructor(e = -1, t = 1, n = 1, r = -1, o = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = o, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, r, o, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let o = n - e, l = n + e, u = r + t, d = r - t;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom, m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += h * this.view.offsetX, l = o + h * this.view.width, u -= m * this.view.offsetY, d = u - m * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, l, u, d, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const kd = 4, Kw = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Ac = 20, ES = /* @__PURE__ */ new hu(), Jw = /* @__PURE__ */ new Tt();
let bS = null, TS = 0, wS = 0;
const Ec = (1 + Math.sqrt(5)) / 2, Pd = 1 / Ec, Qw = [
  /* @__PURE__ */ new j(1, 1, 1),
  /* @__PURE__ */ new j(-1, 1, 1),
  /* @__PURE__ */ new j(1, 1, -1),
  /* @__PURE__ */ new j(-1, 1, -1),
  /* @__PURE__ */ new j(0, Ec, Pd),
  /* @__PURE__ */ new j(0, Ec, -Pd),
  /* @__PURE__ */ new j(Pd, 0, Ec),
  /* @__PURE__ */ new j(-Pd, 0, Ec),
  /* @__PURE__ */ new j(Ec, Pd, 0),
  /* @__PURE__ */ new j(-Ec, Pd, 0)
];
class JM {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, r = 100) {
    bS = this._renderer.getRenderTarget(), TS = this._renderer.getActiveCubeFace(), wS = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, n, r, o), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = tA(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = eA(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(bS, TS, wS), e.scissorTest = !1, iy(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === al || e.mapping === vu ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), bS = this._renderer.getRenderTarget(), TS = this._renderer.getActiveCubeFace(), wS = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: Oi,
      minFilter: Oi,
      generateMipmaps: !1,
      type: Qd,
      format: is,
      colorSpace: xo,
      depthBuffer: !1
    }, r = $w(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = $w(e, t, n);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = IB(o)), this._blurMaterial = FB(o, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new ir(this._lodPlanes[0], e);
    this._renderer.compile(t, ES);
  }
  _sceneToCubeUV(e, t, n, r) {
    const u = new Ii(90, 1, t, n), d = [1, -1, 1, 1, 1, 1], h = [1, 1, 1, -1, -1, -1], m = this._renderer, g = m.autoClear, y = m.toneMapping;
    m.getClearColor(Jw), m.toneMapping = mo, m.autoClear = !1;
    const _ = new Mu({
      name: "PMREM.Background",
      side: ss,
      depthWrite: !1,
      depthTest: !1
    }), E = new ir(new Wc(), _);
    let w = !1;
    const T = e.background;
    T ? T.isColor && (_.color.copy(T), e.background = null, w = !0) : (_.color.copy(Jw), w = !0);
    for (let M = 0; M < 6; M++) {
      const C = M % 3;
      C === 0 ? (u.up.set(0, d[M], 0), u.lookAt(h[M], 0, 0)) : C === 1 ? (u.up.set(0, 0, d[M]), u.lookAt(0, h[M], 0)) : (u.up.set(0, d[M], 0), u.lookAt(0, 0, h[M]));
      const A = this._cubeSize;
      iy(r, C * A, M > 2 ? A : 0, A, A), m.setRenderTarget(r), w && m.render(E, u), m.render(e, u);
    }
    E.geometry.dispose(), E.material.dispose(), m.toneMapping = y, m.autoClear = g, e.background = T;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, r = e.mapping === al || e.mapping === vu;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = tA()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = eA());
    const o = r ? this._cubemapMaterial : this._equirectMaterial, l = new ir(this._lodPlanes[0], o), u = o.uniforms;
    u.envMap.value = e;
    const d = this._cubeSize;
    iy(t, 0, 0, 3 * d, 2 * d), n.setRenderTarget(t), n.render(l, ES);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), l = Qw[(r - 1) % Qw.length];
      this._blur(e, r - 1, r, o, l);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, r, o) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      n,
      r,
      "latitudinal",
      o
    ), this._halfBlur(
      l,
      e,
      n,
      n,
      r,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, t, n, r, o, l, u) {
    const d = this._renderer, h = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const m = 3, g = new ir(this._lodPlanes[r], h), y = h.uniforms, _ = this._sizeLods[n] - 1, E = isFinite(o) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * Ac - 1), w = o / E, T = isFinite(o) ? 1 + Math.floor(m * w) : Ac;
    T > Ac && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${T} samples when the maximum is set to ${Ac}`);
    const M = [];
    let C = 0;
    for (let V = 0; V < Ac; ++V) {
      const W = V / w, U = Math.exp(-W * W / 2);
      M.push(U), V === 0 ? C += U : V < T && (C += 2 * U);
    }
    for (let V = 0; V < M.length; V++)
      M[V] = M[V] / C;
    y.envMap.value = e.texture, y.samples.value = T, y.weights.value = M, y.latitudinal.value = l === "latitudinal", u && (y.poleAxis.value = u);
    const { _lodMax: A } = this;
    y.dTheta.value = E, y.mipInt.value = A - n;
    const N = this._sizeLods[r], z = 3 * N * (r > A - kd ? r - A + kd : 0), I = 4 * (this._cubeSize - N);
    iy(t, z, I, 3 * N, 2 * N), d.setRenderTarget(t), d.render(g, ES);
  }
}
function IB(i) {
  const e = [], t = [], n = [];
  let r = i;
  const o = i - kd + 1 + Kw.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, r);
    t.push(u);
    let d = 1 / u;
    l > i - kd ? d = Kw[l - i + kd - 1] : l === 0 && (d = 0), n.push(d);
    const h = 1 / (u - 2), m = -h, g = 1 + h, y = [m, m, g, m, g, g, m, m, g, g, m, g], _ = 6, E = 6, w = 3, T = 2, M = 1, C = new Float32Array(w * E * _), A = new Float32Array(T * E * _), N = new Float32Array(M * E * _);
    for (let I = 0; I < _; I++) {
      const V = I % 3 * 2 / 3 - 1, W = I > 2 ? 0 : -1, U = [
        V,
        W,
        0,
        V + 2 / 3,
        W,
        0,
        V + 2 / 3,
        W + 1,
        0,
        V,
        W,
        0,
        V + 2 / 3,
        W + 1,
        0,
        V,
        W + 1,
        0
      ];
      C.set(U, w * E * I), A.set(y, T * E * I);
      const O = [I, I, I, I, I, I];
      N.set(O, M * E * I);
    }
    const z = new gn();
    z.setAttribute("position", new Vn(C, w)), z.setAttribute("uv", new Vn(A, T)), z.setAttribute("faceIndex", new Vn(N, M)), e.push(z), r > kd && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function $w(i, e, t) {
  const n = new ka(i, e, t);
  return n.texture.mapping = oh, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function iy(i, e, t, n, r) {
  i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
}
function FB(i, e, t) {
  const n = new Float32Array(Ac), r = new j(0, 1, 0);
  return new _o({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ac,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: GE(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: nl,
    depthTest: !1,
    depthWrite: !1
  });
}
function eA() {
  return new _o({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: GE(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: nl,
    depthTest: !1,
    depthWrite: !1
  });
}
function tA() {
  return new _o({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: GE(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: nl,
    depthTest: !1,
    depthWrite: !1
  });
}
function GE() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function zB(i) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(u) {
    if (u && u.isTexture) {
      const d = u.mapping, h = d === am || d === om, m = d === al || d === vu;
      if (h || m)
        if (u.isRenderTargetTexture && u.needsPMREMUpdate === !0) {
          u.needsPMREMUpdate = !1;
          let g = e.get(u);
          return t === null && (t = new JM(i)), g = h ? t.fromEquirectangular(u, g) : t.fromCubemap(u, g), e.set(u, g), g.texture;
        } else {
          if (e.has(u))
            return e.get(u).texture;
          {
            const g = u.image;
            if (h && g && g.height > 0 || m && g && r(g)) {
              t === null && (t = new JM(i));
              const y = h ? t.fromEquirectangular(u) : t.fromCubemap(u);
              return e.set(u, y), u.addEventListener("dispose", o), y.texture;
            } else
              return null;
          }
        }
    }
    return u;
  }
  function r(u) {
    let d = 0;
    const h = 6;
    for (let m = 0; m < h; m++)
      u[m] !== void 0 && d++;
    return d === h;
  }
  function o(u) {
    const d = u.target;
    d.removeEventListener("dispose", o);
    const h = e.get(d);
    h !== void 0 && (e.delete(d), h.dispose());
  }
  function l() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: l
  };
}
function BB(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let r;
    switch (n) {
      case "WEBGL_depth_texture":
        r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = i.getExtension(n);
    }
    return e[n] = r, r;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const r = t(n);
      return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r;
    }
  };
}
function VB(i, e, t, n) {
  const r = {}, o = /* @__PURE__ */ new WeakMap();
  function l(g) {
    const y = g.target;
    y.index !== null && e.remove(y.index);
    for (const E in y.attributes)
      e.remove(y.attributes[E]);
    for (const E in y.morphAttributes) {
      const w = y.morphAttributes[E];
      for (let T = 0, M = w.length; T < M; T++)
        e.remove(w[T]);
    }
    y.removeEventListener("dispose", l), delete r[y.id];
    const _ = o.get(y);
    _ && (e.remove(_), o.delete(y)), n.releaseStatesOfGeometry(y), y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount, t.memory.geometries--;
  }
  function u(g, y) {
    return r[y.id] === !0 || (y.addEventListener("dispose", l), r[y.id] = !0, t.memory.geometries++), y;
  }
  function d(g) {
    const y = g.attributes;
    for (const E in y)
      e.update(y[E], i.ARRAY_BUFFER);
    const _ = g.morphAttributes;
    for (const E in _) {
      const w = _[E];
      for (let T = 0, M = w.length; T < M; T++)
        e.update(w[T], i.ARRAY_BUFFER);
    }
  }
  function h(g) {
    const y = [], _ = g.index, E = g.attributes.position;
    let w = 0;
    if (_ !== null) {
      const C = _.array;
      w = _.version;
      for (let A = 0, N = C.length; A < N; A += 3) {
        const z = C[A + 0], I = C[A + 1], V = C[A + 2];
        y.push(z, I, I, V, V, z);
      }
    } else if (E !== void 0) {
      const C = E.array;
      w = E.version;
      for (let A = 0, N = C.length / 3 - 1; A < N; A += 3) {
        const z = A + 0, I = A + 1, V = A + 2;
        y.push(z, I, I, V, V, z);
      }
    } else
      return;
    const T = new (BP(y) ? kE : HE)(y, 1);
    T.version = w;
    const M = o.get(g);
    M && e.remove(M), o.set(g, T);
  }
  function m(g) {
    const y = o.get(g);
    if (y) {
      const _ = g.index;
      _ !== null && y.version < _.version && h(g);
    } else
      h(g);
    return o.get(g);
  }
  return {
    get: u,
    update: d,
    getWireframeAttribute: m
  };
}
function HB(i, e, t, n) {
  const r = n.isWebGL2;
  let o;
  function l(_) {
    o = _;
  }
  let u, d;
  function h(_) {
    u = _.type, d = _.bytesPerElement;
  }
  function m(_, E) {
    i.drawElements(o, E, u, _ * d), t.update(E, o, 1);
  }
  function g(_, E, w) {
    if (w === 0) return;
    let T, M;
    if (r)
      T = i, M = "drawElementsInstanced";
    else if (T = e.get("ANGLE_instanced_arrays"), M = "drawElementsInstancedANGLE", T === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    T[M](o, E, u, _ * d, w), t.update(E, o, w);
  }
  function y(_, E, w) {
    if (w === 0) return;
    const T = e.get("WEBGL_multi_draw");
    if (T === null)
      for (let M = 0; M < w; M++)
        this.render(_[M] / d, E[M]);
    else {
      T.multiDrawElementsWEBGL(o, E, 0, u, _, 0, w);
      let M = 0;
      for (let C = 0; C < w; C++)
        M += E[C];
      t.update(M, o, 1);
    }
  }
  this.setMode = l, this.setIndex = h, this.render = m, this.renderInstances = g, this.renderMultiDraw = y;
}
function kB(i) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(o, l, u) {
    switch (t.calls++, l) {
      case i.TRIANGLES:
        t.triangles += u * (o / 3);
        break;
      case i.LINES:
        t.lines += u * (o / 2);
        break;
      case i.LINE_STRIP:
        t.lines += u * (o - 1);
        break;
      case i.LINE_LOOP:
        t.lines += u * o;
        break;
      case i.POINTS:
        t.points += u * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function r() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n
  };
}
function GB(i, e) {
  return i[0] - e[0];
}
function WB(i, e) {
  return Math.abs(e[1]) - Math.abs(i[1]);
}
function XB(i, e, t) {
  const n = {}, r = new Float32Array(8), o = /* @__PURE__ */ new WeakMap(), l = new Bn(), u = [];
  for (let h = 0; h < 8; h++)
    u[h] = [h, 0];
  function d(h, m, g) {
    const y = h.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const _ = m.morphAttributes.position || m.morphAttributes.normal || m.morphAttributes.color, E = _ !== void 0 ? _.length : 0;
      let w = o.get(m);
      if (w === void 0 || w.count !== E) {
        let K = function() {
          le.dispose(), o.delete(m), m.removeEventListener("dispose", K);
        };
        w !== void 0 && w.texture.dispose();
        const C = m.morphAttributes.position !== void 0, A = m.morphAttributes.normal !== void 0, N = m.morphAttributes.color !== void 0, z = m.morphAttributes.position || [], I = m.morphAttributes.normal || [], V = m.morphAttributes.color || [];
        let W = 0;
        C === !0 && (W = 1), A === !0 && (W = 2), N === !0 && (W = 3);
        let U = m.attributes.position.count * W, O = 1;
        U > e.maxTextureSize && (O = Math.ceil(U / e.maxTextureSize), U = e.maxTextureSize);
        const q = new Float32Array(U * O * 4 * E), le = new p0(q, U, O, E);
        le.type = Va, le.needsUpdate = !0;
        const ye = W * 4;
        for (let oe = 0; oe < E; oe++) {
          const ie = z[oe], Ee = I[oe], Q = V[oe], se = U * O * 4 * oe;
          for (let re = 0; re < ie.count; re++) {
            const ue = re * ye;
            C === !0 && (l.fromBufferAttribute(ie, re), q[se + ue + 0] = l.x, q[se + ue + 1] = l.y, q[se + ue + 2] = l.z, q[se + ue + 3] = 0), A === !0 && (l.fromBufferAttribute(Ee, re), q[se + ue + 4] = l.x, q[se + ue + 5] = l.y, q[se + ue + 6] = l.z, q[se + ue + 7] = 0), N === !0 && (l.fromBufferAttribute(Q, re), q[se + ue + 8] = l.x, q[se + ue + 9] = l.y, q[se + ue + 10] = l.z, q[se + ue + 11] = Q.itemSize === 4 ? l.w : 1);
          }
        }
        w = {
          count: E,
          texture: le,
          size: new Oe(U, O)
        }, o.set(m, w), m.addEventListener("dispose", K);
      }
      let T = 0;
      for (let C = 0; C < y.length; C++)
        T += y[C];
      const M = m.morphTargetsRelative ? 1 : 1 - T;
      g.getUniforms().setValue(i, "morphTargetBaseInfluence", M), g.getUniforms().setValue(i, "morphTargetInfluences", y), g.getUniforms().setValue(i, "morphTargetsTexture", w.texture, t), g.getUniforms().setValue(i, "morphTargetsTextureSize", w.size);
    } else {
      const _ = y === void 0 ? 0 : y.length;
      let E = n[m.id];
      if (E === void 0 || E.length !== _) {
        E = [];
        for (let A = 0; A < _; A++)
          E[A] = [A, 0];
        n[m.id] = E;
      }
      for (let A = 0; A < _; A++) {
        const N = E[A];
        N[0] = A, N[1] = y[A];
      }
      E.sort(WB);
      for (let A = 0; A < 8; A++)
        A < _ && E[A][1] ? (u[A][0] = E[A][0], u[A][1] = E[A][1]) : (u[A][0] = Number.MAX_SAFE_INTEGER, u[A][1] = 0);
      u.sort(GB);
      const w = m.morphAttributes.position, T = m.morphAttributes.normal;
      let M = 0;
      for (let A = 0; A < 8; A++) {
        const N = u[A], z = N[0], I = N[1];
        z !== Number.MAX_SAFE_INTEGER && I ? (w && m.getAttribute("morphTarget" + A) !== w[z] && m.setAttribute("morphTarget" + A, w[z]), T && m.getAttribute("morphNormal" + A) !== T[z] && m.setAttribute("morphNormal" + A, T[z]), r[A] = I, M += I) : (w && m.hasAttribute("morphTarget" + A) === !0 && m.deleteAttribute("morphTarget" + A), T && m.hasAttribute("morphNormal" + A) === !0 && m.deleteAttribute("morphNormal" + A), r[A] = 0);
      }
      const C = m.morphTargetsRelative ? 1 : 1 - M;
      g.getUniforms().setValue(i, "morphTargetBaseInfluence", C), g.getUniforms().setValue(i, "morphTargetInfluences", r);
    }
  }
  return {
    update: d
  };
}
function jB(i, e, t, n) {
  let r = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const h = n.render.frame, m = d.geometry, g = e.get(d, m);
    if (r.get(g) !== h && (e.update(g), r.set(g, h)), d.isInstancedMesh && (d.hasEventListener("dispose", u) === !1 && d.addEventListener("dispose", u), r.get(d) !== h && (t.update(d.instanceMatrix, i.ARRAY_BUFFER), d.instanceColor !== null && t.update(d.instanceColor, i.ARRAY_BUFFER), r.set(d, h))), d.isSkinnedMesh) {
      const y = d.skeleton;
      r.get(y) !== h && (y.update(), r.set(y, h));
    }
    return g;
  }
  function l() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function u(d) {
    const h = d.target;
    h.removeEventListener("dispose", u), t.remove(h.instanceMatrix), h.instanceColor !== null && t.remove(h.instanceColor);
  }
  return {
    update: o,
    dispose: l
  };
}
class WE extends Fi {
  constructor(e, t, n, r, o, l, u, d, h, m) {
    if (m = m !== void 0 ? m : fu, m !== fu && m !== Bc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && m === fu && (n = $o), n === void 0 && m === Bc && (n = cu), super(null, r, o, l, u, d, m, n, h), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = u !== void 0 ? u : Ui, this.minFilter = d !== void 0 ? d : Ui, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const qP = /* @__PURE__ */ new Fi(), ZP = /* @__PURE__ */ new WE(1, 1);
ZP.compareFunction = FE;
const KP = /* @__PURE__ */ new p0(), JP = /* @__PURE__ */ new VE(), QP = /* @__PURE__ */ new Um(), nA = [], iA = [], rA = new Float32Array(16), sA = new Float32Array(9), aA = new Float32Array(4);
function lh(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const r = e * t;
  let o = nA[r];
  if (o === void 0 && (o = new Float32Array(r), nA[r] = o), e !== 0) {
    n.toArray(o, 0);
    for (let l = 1, u = 0; l !== e; ++l)
      u += t, i[l].toArray(o, u);
  }
  return o;
}
function rr(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0, n = i.length; t < n; t++)
    if (i[t] !== e[t]) return !1;
  return !0;
}
function sr(i, e) {
  for (let t = 0, n = e.length; t < n; t++)
    i[t] = e[t];
}
function m0(i, e) {
  let t = iA[e];
  t === void 0 && (t = new Int32Array(e), iA[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = i.allocateTextureUnit();
  return t;
}
function YB(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
}
function qB(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (rr(t, e)) return;
    i.uniform2fv(this.addr, e), sr(t, e);
  }
}
function ZB(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (rr(t, e)) return;
    i.uniform3fv(this.addr, e), sr(t, e);
  }
}
function KB(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (rr(t, e)) return;
    i.uniform4fv(this.addr, e), sr(t, e);
  }
}
function JB(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (rr(t, e)) return;
    i.uniformMatrix2fv(this.addr, !1, e), sr(t, e);
  } else {
    if (rr(t, n)) return;
    aA.set(n), i.uniformMatrix2fv(this.addr, !1, aA), sr(t, n);
  }
}
function QB(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (rr(t, e)) return;
    i.uniformMatrix3fv(this.addr, !1, e), sr(t, e);
  } else {
    if (rr(t, n)) return;
    sA.set(n), i.uniformMatrix3fv(this.addr, !1, sA), sr(t, n);
  }
}
function $B(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (rr(t, e)) return;
    i.uniformMatrix4fv(this.addr, !1, e), sr(t, e);
  } else {
    if (rr(t, n)) return;
    rA.set(n), i.uniformMatrix4fv(this.addr, !1, rA), sr(t, n);
  }
}
function eV(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
}
function tV(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (rr(t, e)) return;
    i.uniform2iv(this.addr, e), sr(t, e);
  }
}
function nV(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (rr(t, e)) return;
    i.uniform3iv(this.addr, e), sr(t, e);
  }
}
function iV(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (rr(t, e)) return;
    i.uniform4iv(this.addr, e), sr(t, e);
  }
}
function rV(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
}
function sV(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (rr(t, e)) return;
    i.uniform2uiv(this.addr, e), sr(t, e);
  }
}
function aV(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (rr(t, e)) return;
    i.uniform3uiv(this.addr, e), sr(t, e);
  }
}
function oV(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (rr(t, e)) return;
    i.uniform4uiv(this.addr, e), sr(t, e);
  }
}
function lV(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r);
  const o = this.type === i.SAMPLER_2D_SHADOW ? ZP : qP;
  t.setTexture2D(e || o, r);
}
function uV(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || JP, r);
}
function cV(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || QP, r);
}
function fV(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || KP, r);
}
function dV(i) {
  switch (i) {
    case 5126:
      return YB;
    case 35664:
      return qB;
    case 35665:
      return ZB;
    case 35666:
      return KB;
    case 35674:
      return JB;
    case 35675:
      return QB;
    case 35676:
      return $B;
    case 5124:
    case 35670:
      return eV;
    case 35667:
    case 35671:
      return tV;
    case 35668:
    case 35672:
      return nV;
    case 35669:
    case 35673:
      return iV;
    case 5125:
      return rV;
    case 36294:
      return sV;
    case 36295:
      return aV;
    case 36296:
      return oV;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return lV;
    case 35679:
    case 36299:
    case 36307:
      return uV;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return cV;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return fV;
  }
}
function hV(i, e) {
  i.uniform1fv(this.addr, e);
}
function pV(i, e) {
  const t = lh(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function mV(i, e) {
  const t = lh(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function vV(i, e) {
  const t = lh(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function gV(i, e) {
  const t = lh(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function yV(i, e) {
  const t = lh(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function xV(i, e) {
  const t = lh(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function _V(i, e) {
  i.uniform1iv(this.addr, e);
}
function SV(i, e) {
  i.uniform2iv(this.addr, e);
}
function MV(i, e) {
  i.uniform3iv(this.addr, e);
}
function EV(i, e) {
  i.uniform4iv(this.addr, e);
}
function bV(i, e) {
  i.uniform1uiv(this.addr, e);
}
function TV(i, e) {
  i.uniform2uiv(this.addr, e);
}
function wV(i, e) {
  i.uniform3uiv(this.addr, e);
}
function AV(i, e) {
  i.uniform4uiv(this.addr, e);
}
function RV(i, e, t) {
  const n = this.cache, r = e.length, o = m0(t, r);
  rr(n, o) || (i.uniform1iv(this.addr, o), sr(n, o));
  for (let l = 0; l !== r; ++l)
    t.setTexture2D(e[l] || qP, o[l]);
}
function CV(i, e, t) {
  const n = this.cache, r = e.length, o = m0(t, r);
  rr(n, o) || (i.uniform1iv(this.addr, o), sr(n, o));
  for (let l = 0; l !== r; ++l)
    t.setTexture3D(e[l] || JP, o[l]);
}
function PV(i, e, t) {
  const n = this.cache, r = e.length, o = m0(t, r);
  rr(n, o) || (i.uniform1iv(this.addr, o), sr(n, o));
  for (let l = 0; l !== r; ++l)
    t.setTextureCube(e[l] || QP, o[l]);
}
function LV(i, e, t) {
  const n = this.cache, r = e.length, o = m0(t, r);
  rr(n, o) || (i.uniform1iv(this.addr, o), sr(n, o));
  for (let l = 0; l !== r; ++l)
    t.setTexture2DArray(e[l] || KP, o[l]);
}
function DV(i) {
  switch (i) {
    case 5126:
      return hV;
    case 35664:
      return pV;
    case 35665:
      return mV;
    case 35666:
      return vV;
    case 35674:
      return gV;
    case 35675:
      return yV;
    case 35676:
      return xV;
    case 5124:
    case 35670:
      return _V;
    case 35667:
    case 35671:
      return SV;
    case 35668:
    case 35672:
      return MV;
    case 35669:
    case 35673:
      return EV;
    case 5125:
      return bV;
    case 36294:
      return TV;
    case 36295:
      return wV;
    case 36296:
      return AV;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return RV;
    case 35679:
    case 36299:
    case 36307:
      return CV;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return PV;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return LV;
  }
}
class NV {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = dV(t.type);
  }
}
class UV {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = DV(t.type);
  }
}
class OV {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const r = this.seq;
    for (let o = 0, l = r.length; o !== l; ++o) {
      const u = r[o];
      u.setValue(e, t[u.id], n);
    }
  }
}
const AS = /(\w+)(\])?(\[|\.)?/g;
function oA(i, e) {
  i.seq.push(e), i.map[e.id] = e;
}
function IV(i, e, t) {
  const n = i.name, r = n.length;
  for (AS.lastIndex = 0; ; ) {
    const o = AS.exec(n), l = AS.lastIndex;
    let u = o[1];
    const d = o[2] === "]", h = o[3];
    if (d && (u = u | 0), h === void 0 || h === "[" && l + 2 === r) {
      oA(t, h === void 0 ? new NV(u, i, e) : new UV(u, i, e));
      break;
    } else {
      let g = t.map[u];
      g === void 0 && (g = new OV(u), oA(t, g)), t = g;
    }
  }
}
class ky {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < n; ++r) {
      const o = e.getActiveUniform(t, r), l = e.getUniformLocation(t, o.name);
      IV(o, l, this);
    }
  }
  setValue(e, t, n, r) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, n, r);
  }
  setOptional(e, t, n) {
    const r = t[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, t, n, r) {
    for (let o = 0, l = t.length; o !== l; ++o) {
      const u = t[o], d = n[u.id];
      d.needsUpdate !== !1 && u.setValue(e, d.value, r);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let r = 0, o = e.length; r !== o; ++r) {
      const l = e[r];
      l.id in t && n.push(l);
    }
    return n;
  }
}
function lA(i, e, t) {
  const n = i.createShader(e);
  return i.shaderSource(n, t), i.compileShader(n), n;
}
const FV = 37297;
let zV = 0;
function BV(i, e) {
  const t = i.split(`
`), n = [], r = Math.max(e - 6, 0), o = Math.min(e + 6, t.length);
  for (let l = r; l < o; l++) {
    const u = l + 1;
    n.push(`${u === e ? ">" : " "} ${u}: ${t[l]}`);
  }
  return n.join(`
`);
}
function VV(i) {
  const e = zn.getPrimaries(zn.workingColorSpace), t = zn.getPrimaries(i);
  let n;
  switch (e === t ? n = "" : e === mm && t === pm ? n = "LinearDisplayP3ToLinearSRGB" : e === pm && t === mm && (n = "LinearSRGBToLinearDisplayP3"), i) {
    case xo:
    case Lm:
      return [n, "LinearTransferOETF"];
    case nr:
    case h0:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", i), [n, "LinearTransferOETF"];
  }
}
function uA(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS), r = i.getShaderInfoLog(e).trim();
  if (n && r === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(r);
  if (o) {
    const l = parseInt(o[1]);
    return t.toUpperCase() + `

` + r + `

` + BV(i.getShaderSource(e), l);
  } else
    return r;
}
function HV(i, e) {
  const t = VV(e);
  return `vec4 ${i}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function kV(i, e) {
  let t;
  switch (e) {
    case dP:
      t = "Linear";
      break;
    case hP:
      t = "Reinhard";
      break;
    case pP:
      t = "OptimizedCineon";
      break;
    case wE:
      t = "ACESFilmic";
      break;
    case vP:
      t = "AgX";
      break;
    case mP:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function GV(i) {
  return [
    i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.normalMapTangentSpace || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Gd).join(`
`);
}
function WV(i) {
  return [
    i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""
  ].filter(Gd).join(`
`);
}
function XV(i) {
  const e = [];
  for (const t in i) {
    const n = i[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function jV(i, e) {
  const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < n; r++) {
    const o = i.getActiveAttrib(e, r), l = o.name;
    let u = 1;
    o.type === i.FLOAT_MAT2 && (u = 2), o.type === i.FLOAT_MAT3 && (u = 3), o.type === i.FLOAT_MAT4 && (u = 4), t[l] = {
      type: o.type,
      location: i.getAttribLocation(e, l),
      locationSize: u
    };
  }
  return t;
}
function Gd(i) {
  return i !== "";
}
function cA(i, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function fA(i, e) {
  return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const YV = /^[ \t]*#include +<([\w\d./]+)>/gm;
function QM(i) {
  return i.replace(YV, ZV);
}
const qV = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function ZV(i, e) {
  let t = fn[e];
  if (t === void 0) {
    const n = qV.get(e);
    if (n !== void 0)
      t = fn[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return QM(t);
}
const KV = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function dA(i) {
  return i.replace(KV, JV);
}
function JV(i, e, t, n) {
  let r = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    r += n.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return r;
}
function hA(i) {
  let e = "precision " + i.precision + ` float;
precision ` + i.precision + " int;";
  return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function QV(i) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return i.shadowMapType === u0 ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === Zp ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === za && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function $V(i) {
  let e = "ENVMAP_TYPE_CUBE";
  if (i.envMap)
    switch (i.envMapMode) {
      case al:
      case vu:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case oh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function eH(i) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (i.envMap)
    switch (i.envMapMode) {
      case vu:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function tH(i) {
  let e = "ENVMAP_BLENDING_NONE";
  if (i.envMap)
    switch (i.combine) {
      case Pm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case cP:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case fP:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function nH(i) {
  const e = i.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function iH(i, e, t, n) {
  const r = i.getContext(), o = t.defines;
  let l = t.vertexShader, u = t.fragmentShader;
  const d = QV(t), h = $V(t), m = eH(t), g = tH(t), y = nH(t), _ = t.isWebGL2 ? "" : GV(t), E = WV(t), w = XV(o), T = r.createProgram();
  let M, C, A = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (M = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    w
  ].filter(Gd).join(`
`), M.length > 0 && (M += `
`), C = [
    _,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    w
  ].filter(Gd).join(`
`), C.length > 0 && (C += `
`)) : (M = [
    hA(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    w,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + m : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + d : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Gd).join(`
`), C = [
    _,
    hA(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    w,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + m : "",
    t.envMap ? "#define " + g : "",
    y ? "#define CUBEUV_TEXEL_WIDTH " + y.texelWidth : "",
    y ? "#define CUBEUV_TEXEL_HEIGHT " + y.texelHeight : "",
    y ? "#define CUBEUV_MAX_MIP " + y.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + d : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== mo ? "#define TONE_MAPPING" : "",
    t.toneMapping !== mo ? fn.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== mo ? kV("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    fn.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    HV("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Gd).join(`
`)), l = QM(l), l = cA(l, t), l = fA(l, t), u = QM(u), u = cA(u, t), u = fA(u, t), l = dA(l), u = dA(u), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`, M = [
    E,
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + M, C = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    t.glslVersion === ZM ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === ZM ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + C);
  const N = A + M + l, z = A + C + u, I = lA(r, r.VERTEX_SHADER, N), V = lA(r, r.FRAGMENT_SHADER, z);
  r.attachShader(T, I), r.attachShader(T, V), t.index0AttributeName !== void 0 ? r.bindAttribLocation(T, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(T, 0, "position"), r.linkProgram(T);
  function W(le) {
    if (i.debug.checkShaderErrors) {
      const ye = r.getProgramInfoLog(T).trim(), K = r.getShaderInfoLog(I).trim(), oe = r.getShaderInfoLog(V).trim();
      let ie = !0, Ee = !0;
      if (r.getProgramParameter(T, r.LINK_STATUS) === !1)
        if (ie = !1, typeof i.debug.onShaderError == "function")
          i.debug.onShaderError(r, T, I, V);
        else {
          const Q = uA(r, I, "vertex"), se = uA(r, V, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(T, r.VALIDATE_STATUS) + `

Program Info Log: ` + ye + `
` + Q + `
` + se
          );
        }
      else ye !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", ye) : (K === "" || oe === "") && (Ee = !1);
      Ee && (le.diagnostics = {
        runnable: ie,
        programLog: ye,
        vertexShader: {
          log: K,
          prefix: M
        },
        fragmentShader: {
          log: oe,
          prefix: C
        }
      });
    }
    r.deleteShader(I), r.deleteShader(V), U = new ky(r, T), O = jV(r, T);
  }
  let U;
  this.getUniforms = function() {
    return U === void 0 && W(this), U;
  };
  let O;
  this.getAttributes = function() {
    return O === void 0 && W(this), O;
  };
  let q = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return q === !1 && (q = r.getProgramParameter(T, FV)), q;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), r.deleteProgram(T), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = zV++, this.cacheKey = e, this.usedTimes = 1, this.program = T, this.vertexShader = I, this.fragmentShader = V, this;
}
let rH = 0;
class sH {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, r = this._getShaderStage(t), o = this._getShaderStage(n), l = this._getShaderCacheForMaterial(e);
    return l.has(r) === !1 && (l.add(r), r.usedTimes++), l.has(o) === !1 && (l.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new aH(e), t.set(e, n)), n;
  }
}
class aH {
  constructor(e) {
    this.id = rH++, this.code = e, this.usedTimes = 0;
  }
}
function oH(i, e, t, n, r, o, l) {
  const u = new Oc(), d = new sH(), h = [], m = r.isWebGL2, g = r.logarithmicDepthBuffer, y = r.vertexTextures;
  let _ = r.precision;
  const E = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function w(U) {
    return U === 0 ? "uv" : `uv${U}`;
  }
  function T(U, O, q, le, ye) {
    const K = le.fog, oe = ye.geometry, ie = U.isMeshStandardMaterial ? le.environment : null, Ee = (U.isMeshStandardMaterial ? t : e).get(U.envMap || ie), Q = Ee && Ee.mapping === oh ? Ee.image.height : null, se = E[U.type];
    U.precision !== null && (_ = r.getMaxPrecision(U.precision), _ !== U.precision && console.warn("THREE.WebGLProgram.getParameters:", U.precision, "not supported, using", _, "instead."));
    const re = oe.morphAttributes.position || oe.morphAttributes.normal || oe.morphAttributes.color, ue = re !== void 0 ? re.length : 0;
    let Le = 0;
    oe.morphAttributes.position !== void 0 && (Le = 1), oe.morphAttributes.normal !== void 0 && (Le = 2), oe.morphAttributes.color !== void 0 && (Le = 3);
    let pe, Ae, qe, je;
    if (se) {
      const bn = Ba[se];
      pe = bn.vertexShader, Ae = bn.fragmentShader;
    } else
      pe = U.vertexShader, Ae = U.fragmentShader, d.update(U), qe = d.getVertexShaderID(U), je = d.getFragmentShaderID(U);
    const $e = i.getRenderTarget(), Rt = ye.isInstancedMesh === !0, Ut = ye.isBatchedMesh === !0, ot = !!U.map, pt = !!U.matcap, J = !!Ee, Be = !!U.aoMap, Pe = !!U.lightMap, He = !!U.bumpMap, Re = !!U.normalMap, _t = !!U.displacementMap, rt = !!U.emissiveMap, G = !!U.metalnessMap, B = !!U.roughnessMap, ce = U.anisotropy > 0, Fe = U.clearcoat > 0, ze = U.iridescence > 0, Ie = U.sheen > 0, Mt = U.transmission > 0, it = ce && !!U.anisotropyMap, mt = Fe && !!U.clearcoatMap, Dt = Fe && !!U.clearcoatNormalMap, Ht = Fe && !!U.clearcoatRoughnessMap, de = ze && !!U.iridescenceMap, nt = ze && !!U.iridescenceThicknessMap, lt = Ie && !!U.sheenColorMap, Xe = Ie && !!U.sheenRoughnessMap, dt = !!U.specularMap, at = !!U.specularColorMap, Y = !!U.specularIntensityMap, he = Mt && !!U.transmissionMap, Ze = Mt && !!U.thicknessMap, Ve = !!U.gradientMap, Te = !!U.alphaMap, ee = U.alphaTest > 0, Ke = !!U.alphaHash, st = !!U.extensions, zt = !!oe.attributes.uv1, Ye = !!oe.attributes.uv2, qt = !!oe.attributes.uv3;
    let tn = mo;
    return U.toneMapped && ($e === null || $e.isXRRenderTarget === !0) && (tn = i.toneMapping), {
      isWebGL2: m,
      shaderID: se,
      shaderType: U.type,
      shaderName: U.name,
      vertexShader: pe,
      fragmentShader: Ae,
      defines: U.defines,
      customVertexShaderID: qe,
      customFragmentShaderID: je,
      isRawShaderMaterial: U.isRawShaderMaterial === !0,
      glslVersion: U.glslVersion,
      precision: _,
      batching: Ut,
      instancing: Rt,
      instancingColor: Rt && ye.instanceColor !== null,
      supportsVertexTextures: y,
      outputColorSpace: $e === null ? i.outputColorSpace : $e.isXRRenderTarget === !0 ? $e.texture.colorSpace : xo,
      map: ot,
      matcap: pt,
      envMap: J,
      envMapMode: J && Ee.mapping,
      envMapCubeUVHeight: Q,
      aoMap: Be,
      lightMap: Pe,
      bumpMap: He,
      normalMap: Re,
      displacementMap: y && _t,
      emissiveMap: rt,
      normalMapObjectSpace: Re && U.normalMapType === LP,
      normalMapTangentSpace: Re && U.normalMapType === Su,
      metalnessMap: G,
      roughnessMap: B,
      anisotropy: ce,
      anisotropyMap: it,
      clearcoat: Fe,
      clearcoatMap: mt,
      clearcoatNormalMap: Dt,
      clearcoatRoughnessMap: Ht,
      iridescence: ze,
      iridescenceMap: de,
      iridescenceThicknessMap: nt,
      sheen: Ie,
      sheenColorMap: lt,
      sheenRoughnessMap: Xe,
      specularMap: dt,
      specularColorMap: at,
      specularIntensityMap: Y,
      transmission: Mt,
      transmissionMap: he,
      thicknessMap: Ze,
      gradientMap: Ve,
      opaque: U.transparent === !1 && U.blending === Nc,
      alphaMap: Te,
      alphaTest: ee,
      alphaHash: Ke,
      combine: U.combine,
      //
      mapUv: ot && w(U.map.channel),
      aoMapUv: Be && w(U.aoMap.channel),
      lightMapUv: Pe && w(U.lightMap.channel),
      bumpMapUv: He && w(U.bumpMap.channel),
      normalMapUv: Re && w(U.normalMap.channel),
      displacementMapUv: _t && w(U.displacementMap.channel),
      emissiveMapUv: rt && w(U.emissiveMap.channel),
      metalnessMapUv: G && w(U.metalnessMap.channel),
      roughnessMapUv: B && w(U.roughnessMap.channel),
      anisotropyMapUv: it && w(U.anisotropyMap.channel),
      clearcoatMapUv: mt && w(U.clearcoatMap.channel),
      clearcoatNormalMapUv: Dt && w(U.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ht && w(U.clearcoatRoughnessMap.channel),
      iridescenceMapUv: de && w(U.iridescenceMap.channel),
      iridescenceThicknessMapUv: nt && w(U.iridescenceThicknessMap.channel),
      sheenColorMapUv: lt && w(U.sheenColorMap.channel),
      sheenRoughnessMapUv: Xe && w(U.sheenRoughnessMap.channel),
      specularMapUv: dt && w(U.specularMap.channel),
      specularColorMapUv: at && w(U.specularColorMap.channel),
      specularIntensityMapUv: Y && w(U.specularIntensityMap.channel),
      transmissionMapUv: he && w(U.transmissionMap.channel),
      thicknessMapUv: Ze && w(U.thicknessMap.channel),
      alphaMapUv: Te && w(U.alphaMap.channel),
      //
      vertexTangents: !!oe.attributes.tangent && (Re || ce),
      vertexColors: U.vertexColors,
      vertexAlphas: U.vertexColors === !0 && !!oe.attributes.color && oe.attributes.color.itemSize === 4,
      vertexUv1s: zt,
      vertexUv2s: Ye,
      vertexUv3s: qt,
      pointsUvs: ye.isPoints === !0 && !!oe.attributes.uv && (ot || Te),
      fog: !!K,
      useFog: U.fog === !0,
      fogExp2: K && K.isFogExp2,
      flatShading: U.flatShading === !0,
      sizeAttenuation: U.sizeAttenuation === !0,
      logarithmicDepthBuffer: g,
      skinning: ye.isSkinnedMesh === !0,
      morphTargets: oe.morphAttributes.position !== void 0,
      morphNormals: oe.morphAttributes.normal !== void 0,
      morphColors: oe.morphAttributes.color !== void 0,
      morphTargetsCount: ue,
      morphTextureStride: Le,
      numDirLights: O.directional.length,
      numPointLights: O.point.length,
      numSpotLights: O.spot.length,
      numSpotLightMaps: O.spotLightMap.length,
      numRectAreaLights: O.rectArea.length,
      numHemiLights: O.hemi.length,
      numDirLightShadows: O.directionalShadowMap.length,
      numPointLightShadows: O.pointShadowMap.length,
      numSpotLightShadows: O.spotShadowMap.length,
      numSpotLightShadowsWithMaps: O.numSpotLightShadowsWithMaps,
      numLightProbes: O.numLightProbes,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: U.dithering,
      shadowMapEnabled: i.shadowMap.enabled && q.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: tn,
      useLegacyLights: i._useLegacyLights,
      decodeVideoTexture: ot && U.map.isVideoTexture === !0 && zn.getTransfer(U.map.colorSpace) === Yn,
      premultipliedAlpha: U.premultipliedAlpha,
      doubleSided: U.side === po,
      flipSided: U.side === ss,
      useDepthPacking: U.depthPacking >= 0,
      depthPacking: U.depthPacking || 0,
      index0AttributeName: U.index0AttributeName,
      extensionDerivatives: st && U.extensions.derivatives === !0,
      extensionFragDepth: st && U.extensions.fragDepth === !0,
      extensionDrawBuffers: st && U.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: st && U.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance: st && U.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"),
      rendererExtensionFragDepth: m || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: m || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: m || n.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: U.customProgramCacheKey()
    };
  }
  function M(U) {
    const O = [];
    if (U.shaderID ? O.push(U.shaderID) : (O.push(U.customVertexShaderID), O.push(U.customFragmentShaderID)), U.defines !== void 0)
      for (const q in U.defines)
        O.push(q), O.push(U.defines[q]);
    return U.isRawShaderMaterial === !1 && (C(O, U), A(O, U), O.push(i.outputColorSpace)), O.push(U.customProgramCacheKey), O.join();
  }
  function C(U, O) {
    U.push(O.precision), U.push(O.outputColorSpace), U.push(O.envMapMode), U.push(O.envMapCubeUVHeight), U.push(O.mapUv), U.push(O.alphaMapUv), U.push(O.lightMapUv), U.push(O.aoMapUv), U.push(O.bumpMapUv), U.push(O.normalMapUv), U.push(O.displacementMapUv), U.push(O.emissiveMapUv), U.push(O.metalnessMapUv), U.push(O.roughnessMapUv), U.push(O.anisotropyMapUv), U.push(O.clearcoatMapUv), U.push(O.clearcoatNormalMapUv), U.push(O.clearcoatRoughnessMapUv), U.push(O.iridescenceMapUv), U.push(O.iridescenceThicknessMapUv), U.push(O.sheenColorMapUv), U.push(O.sheenRoughnessMapUv), U.push(O.specularMapUv), U.push(O.specularColorMapUv), U.push(O.specularIntensityMapUv), U.push(O.transmissionMapUv), U.push(O.thicknessMapUv), U.push(O.combine), U.push(O.fogExp2), U.push(O.sizeAttenuation), U.push(O.morphTargetsCount), U.push(O.morphAttributeCount), U.push(O.numDirLights), U.push(O.numPointLights), U.push(O.numSpotLights), U.push(O.numSpotLightMaps), U.push(O.numHemiLights), U.push(O.numRectAreaLights), U.push(O.numDirLightShadows), U.push(O.numPointLightShadows), U.push(O.numSpotLightShadows), U.push(O.numSpotLightShadowsWithMaps), U.push(O.numLightProbes), U.push(O.shadowMapType), U.push(O.toneMapping), U.push(O.numClippingPlanes), U.push(O.numClipIntersection), U.push(O.depthPacking);
  }
  function A(U, O) {
    u.disableAll(), O.isWebGL2 && u.enable(0), O.supportsVertexTextures && u.enable(1), O.instancing && u.enable(2), O.instancingColor && u.enable(3), O.matcap && u.enable(4), O.envMap && u.enable(5), O.normalMapObjectSpace && u.enable(6), O.normalMapTangentSpace && u.enable(7), O.clearcoat && u.enable(8), O.iridescence && u.enable(9), O.alphaTest && u.enable(10), O.vertexColors && u.enable(11), O.vertexAlphas && u.enable(12), O.vertexUv1s && u.enable(13), O.vertexUv2s && u.enable(14), O.vertexUv3s && u.enable(15), O.vertexTangents && u.enable(16), O.anisotropy && u.enable(17), O.alphaHash && u.enable(18), O.batching && u.enable(19), U.push(u.mask), u.disableAll(), O.fog && u.enable(0), O.useFog && u.enable(1), O.flatShading && u.enable(2), O.logarithmicDepthBuffer && u.enable(3), O.skinning && u.enable(4), O.morphTargets && u.enable(5), O.morphNormals && u.enable(6), O.morphColors && u.enable(7), O.premultipliedAlpha && u.enable(8), O.shadowMapEnabled && u.enable(9), O.useLegacyLights && u.enable(10), O.doubleSided && u.enable(11), O.flipSided && u.enable(12), O.useDepthPacking && u.enable(13), O.dithering && u.enable(14), O.transmission && u.enable(15), O.sheen && u.enable(16), O.opaque && u.enable(17), O.pointsUvs && u.enable(18), O.decodeVideoTexture && u.enable(19), U.push(u.mask);
  }
  function N(U) {
    const O = E[U.type];
    let q;
    if (O) {
      const le = Ba[O];
      q = WP.clone(le.uniforms);
    } else
      q = U.uniforms;
    return q;
  }
  function z(U, O) {
    let q;
    for (let le = 0, ye = h.length; le < ye; le++) {
      const K = h[le];
      if (K.cacheKey === O) {
        q = K, ++q.usedTimes;
        break;
      }
    }
    return q === void 0 && (q = new iH(i, O, U, o), h.push(q)), q;
  }
  function I(U) {
    if (--U.usedTimes === 0) {
      const O = h.indexOf(U);
      h[O] = h[h.length - 1], h.pop(), U.destroy();
    }
  }
  function V(U) {
    d.remove(U);
  }
  function W() {
    d.dispose();
  }
  return {
    getParameters: T,
    getProgramCacheKey: M,
    getUniforms: N,
    acquireProgram: z,
    releaseProgram: I,
    releaseShaderCache: V,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: W
  };
}
function lH() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let l = i.get(o);
    return l === void 0 && (l = {}, i.set(o, l)), l;
  }
  function t(o) {
    i.delete(o);
  }
  function n(o, l, u) {
    i.get(o)[l] = u;
  }
  function r() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: r
  };
}
function uH(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function pA(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function mA() {
  const i = [];
  let e = 0;
  const t = [], n = [], r = [];
  function o() {
    e = 0, t.length = 0, n.length = 0, r.length = 0;
  }
  function l(g, y, _, E, w, T) {
    let M = i[e];
    return M === void 0 ? (M = {
      id: g.id,
      object: g,
      geometry: y,
      material: _,
      groupOrder: E,
      renderOrder: g.renderOrder,
      z: w,
      group: T
    }, i[e] = M) : (M.id = g.id, M.object = g, M.geometry = y, M.material = _, M.groupOrder = E, M.renderOrder = g.renderOrder, M.z = w, M.group = T), e++, M;
  }
  function u(g, y, _, E, w, T) {
    const M = l(g, y, _, E, w, T);
    _.transmission > 0 ? n.push(M) : _.transparent === !0 ? r.push(M) : t.push(M);
  }
  function d(g, y, _, E, w, T) {
    const M = l(g, y, _, E, w, T);
    _.transmission > 0 ? n.unshift(M) : _.transparent === !0 ? r.unshift(M) : t.unshift(M);
  }
  function h(g, y) {
    t.length > 1 && t.sort(g || uH), n.length > 1 && n.sort(y || pA), r.length > 1 && r.sort(y || pA);
  }
  function m() {
    for (let g = e, y = i.length; g < y; g++) {
      const _ = i[g];
      if (_.id === null) break;
      _.id = null, _.object = null, _.geometry = null, _.material = null, _.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: r,
    init: o,
    push: u,
    unshift: d,
    finish: m,
    sort: h
  };
}
function cH() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(n, r) {
    const o = i.get(n);
    let l;
    return o === void 0 ? (l = new mA(), i.set(n, [l])) : r >= o.length ? (l = new mA(), o.push(l)) : l = o[r], l;
  }
  function t() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function fH() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new j(),
            color: new Tt()
          };
          break;
        case "SpotLight":
          t = {
            position: new j(),
            direction: new j(),
            color: new Tt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new j(),
            color: new Tt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new j(),
            skyColor: new Tt(),
            groundColor: new Tt()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Tt(),
            position: new j(),
            halfWidth: new j(),
            halfHeight: new j()
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
function dH() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Oe()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Oe()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Oe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
let hH = 0;
function pH(i, e) {
  return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
}
function mH(i, e) {
  const t = new fH(), n = dH(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let m = 0; m < 9; m++) r.probe.push(new j());
  const o = new j(), l = new $t(), u = new $t();
  function d(m, g) {
    let y = 0, _ = 0, E = 0;
    for (let le = 0; le < 9; le++) r.probe[le].set(0, 0, 0);
    let w = 0, T = 0, M = 0, C = 0, A = 0, N = 0, z = 0, I = 0, V = 0, W = 0, U = 0;
    m.sort(pH);
    const O = g === !0 ? Math.PI : 1;
    for (let le = 0, ye = m.length; le < ye; le++) {
      const K = m[le], oe = K.color, ie = K.intensity, Ee = K.distance, Q = K.shadow && K.shadow.map ? K.shadow.map.texture : null;
      if (K.isAmbientLight)
        y += oe.r * ie * O, _ += oe.g * ie * O, E += oe.b * ie * O;
      else if (K.isLightProbe) {
        for (let se = 0; se < 9; se++)
          r.probe[se].addScaledVector(K.sh.coefficients[se], ie);
        U++;
      } else if (K.isDirectionalLight) {
        const se = t.get(K);
        if (se.color.copy(K.color).multiplyScalar(K.intensity * O), K.castShadow) {
          const re = K.shadow, ue = n.get(K);
          ue.shadowBias = re.bias, ue.shadowNormalBias = re.normalBias, ue.shadowRadius = re.radius, ue.shadowMapSize = re.mapSize, r.directionalShadow[w] = ue, r.directionalShadowMap[w] = Q, r.directionalShadowMatrix[w] = K.shadow.matrix, N++;
        }
        r.directional[w] = se, w++;
      } else if (K.isSpotLight) {
        const se = t.get(K);
        se.position.setFromMatrixPosition(K.matrixWorld), se.color.copy(oe).multiplyScalar(ie * O), se.distance = Ee, se.coneCos = Math.cos(K.angle), se.penumbraCos = Math.cos(K.angle * (1 - K.penumbra)), se.decay = K.decay, r.spot[M] = se;
        const re = K.shadow;
        if (K.map && (r.spotLightMap[V] = K.map, V++, re.updateMatrices(K), K.castShadow && W++), r.spotLightMatrix[M] = re.matrix, K.castShadow) {
          const ue = n.get(K);
          ue.shadowBias = re.bias, ue.shadowNormalBias = re.normalBias, ue.shadowRadius = re.radius, ue.shadowMapSize = re.mapSize, r.spotShadow[M] = ue, r.spotShadowMap[M] = Q, I++;
        }
        M++;
      } else if (K.isRectAreaLight) {
        const se = t.get(K);
        se.color.copy(oe).multiplyScalar(ie), se.halfWidth.set(K.width * 0.5, 0, 0), se.halfHeight.set(0, K.height * 0.5, 0), r.rectArea[C] = se, C++;
      } else if (K.isPointLight) {
        const se = t.get(K);
        if (se.color.copy(K.color).multiplyScalar(K.intensity * O), se.distance = K.distance, se.decay = K.decay, K.castShadow) {
          const re = K.shadow, ue = n.get(K);
          ue.shadowBias = re.bias, ue.shadowNormalBias = re.normalBias, ue.shadowRadius = re.radius, ue.shadowMapSize = re.mapSize, ue.shadowCameraNear = re.camera.near, ue.shadowCameraFar = re.camera.far, r.pointShadow[T] = ue, r.pointShadowMap[T] = Q, r.pointShadowMatrix[T] = K.shadow.matrix, z++;
        }
        r.point[T] = se, T++;
      } else if (K.isHemisphereLight) {
        const se = t.get(K);
        se.skyColor.copy(K.color).multiplyScalar(ie * O), se.groundColor.copy(K.groundColor).multiplyScalar(ie * O), r.hemi[A] = se, A++;
      }
    }
    C > 0 && (e.isWebGL2 ? i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = ft.LTC_FLOAT_1, r.rectAreaLTC2 = ft.LTC_FLOAT_2) : (r.rectAreaLTC1 = ft.LTC_HALF_1, r.rectAreaLTC2 = ft.LTC_HALF_2) : i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = ft.LTC_FLOAT_1, r.rectAreaLTC2 = ft.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = ft.LTC_HALF_1, r.rectAreaLTC2 = ft.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = y, r.ambient[1] = _, r.ambient[2] = E;
    const q = r.hash;
    (q.directionalLength !== w || q.pointLength !== T || q.spotLength !== M || q.rectAreaLength !== C || q.hemiLength !== A || q.numDirectionalShadows !== N || q.numPointShadows !== z || q.numSpotShadows !== I || q.numSpotMaps !== V || q.numLightProbes !== U) && (r.directional.length = w, r.spot.length = M, r.rectArea.length = C, r.point.length = T, r.hemi.length = A, r.directionalShadow.length = N, r.directionalShadowMap.length = N, r.pointShadow.length = z, r.pointShadowMap.length = z, r.spotShadow.length = I, r.spotShadowMap.length = I, r.directionalShadowMatrix.length = N, r.pointShadowMatrix.length = z, r.spotLightMatrix.length = I + V - W, r.spotLightMap.length = V, r.numSpotLightShadowsWithMaps = W, r.numLightProbes = U, q.directionalLength = w, q.pointLength = T, q.spotLength = M, q.rectAreaLength = C, q.hemiLength = A, q.numDirectionalShadows = N, q.numPointShadows = z, q.numSpotShadows = I, q.numSpotMaps = V, q.numLightProbes = U, r.version = hH++);
  }
  function h(m, g) {
    let y = 0, _ = 0, E = 0, w = 0, T = 0;
    const M = g.matrixWorldInverse;
    for (let C = 0, A = m.length; C < A; C++) {
      const N = m[C];
      if (N.isDirectionalLight) {
        const z = r.directional[y];
        z.direction.setFromMatrixPosition(N.matrixWorld), o.setFromMatrixPosition(N.target.matrixWorld), z.direction.sub(o), z.direction.transformDirection(M), y++;
      } else if (N.isSpotLight) {
        const z = r.spot[E];
        z.position.setFromMatrixPosition(N.matrixWorld), z.position.applyMatrix4(M), z.direction.setFromMatrixPosition(N.matrixWorld), o.setFromMatrixPosition(N.target.matrixWorld), z.direction.sub(o), z.direction.transformDirection(M), E++;
      } else if (N.isRectAreaLight) {
        const z = r.rectArea[w];
        z.position.setFromMatrixPosition(N.matrixWorld), z.position.applyMatrix4(M), u.identity(), l.copy(N.matrixWorld), l.premultiply(M), u.extractRotation(l), z.halfWidth.set(N.width * 0.5, 0, 0), z.halfHeight.set(0, N.height * 0.5, 0), z.halfWidth.applyMatrix4(u), z.halfHeight.applyMatrix4(u), w++;
      } else if (N.isPointLight) {
        const z = r.point[_];
        z.position.setFromMatrixPosition(N.matrixWorld), z.position.applyMatrix4(M), _++;
      } else if (N.isHemisphereLight) {
        const z = r.hemi[T];
        z.direction.setFromMatrixPosition(N.matrixWorld), z.direction.transformDirection(M), T++;
      }
    }
  }
  return {
    setup: d,
    setupView: h,
    state: r
  };
}
function vA(i, e) {
  const t = new mH(i, e), n = [], r = [];
  function o() {
    n.length = 0, r.length = 0;
  }
  function l(g) {
    n.push(g);
  }
  function u(g) {
    r.push(g);
  }
  function d(g) {
    t.setup(n, g);
  }
  function h(g) {
    t.setupView(n, g);
  }
  return {
    init: o,
    state: {
      lightsArray: n,
      shadowsArray: r,
      lights: t
    },
    setupLights: d,
    setupLightsView: h,
    pushLight: l,
    pushShadow: u
  };
}
function vH(i, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(o, l = 0) {
    const u = t.get(o);
    let d;
    return u === void 0 ? (d = new vA(i, e), t.set(o, [d])) : l >= u.length ? (d = new vA(i, e), u.push(d)) : d = u[l], d;
  }
  function r() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class XE extends Yr {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = CP, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class jE extends Yr {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const gH = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, yH = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function xH(i, e, t) {
  let n = new Om();
  const r = new Oe(), o = new Oe(), l = new Bn(), u = new XE({ depthPacking: PP }), d = new jE(), h = {}, m = t.maxTextureSize, g = { [sl]: ss, [ss]: sl, [po]: po }, y = new _o({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Oe() },
      radius: { value: 4 }
    },
    vertexShader: gH,
    fragmentShader: yH
  }), _ = y.clone();
  _.defines.HORIZONTAL_PASS = 1;
  const E = new gn();
  E.setAttribute(
    "position",
    new Vn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const w = new ir(E, y), T = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = u0;
  let M = this.type;
  this.render = function(I, V, W) {
    if (T.enabled === !1 || T.autoUpdate === !1 && T.needsUpdate === !1 || I.length === 0) return;
    const U = i.getRenderTarget(), O = i.getActiveCubeFace(), q = i.getActiveMipmapLevel(), le = i.state;
    le.setBlending(nl), le.buffers.color.setClear(1, 1, 1, 1), le.buffers.depth.setTest(!0), le.setScissorTest(!1);
    const ye = M !== za && this.type === za, K = M === za && this.type !== za;
    for (let oe = 0, ie = I.length; oe < ie; oe++) {
      const Ee = I[oe], Q = Ee.shadow;
      if (Q === void 0) {
        console.warn("THREE.WebGLShadowMap:", Ee, "has no shadow.");
        continue;
      }
      if (Q.autoUpdate === !1 && Q.needsUpdate === !1) continue;
      r.copy(Q.mapSize);
      const se = Q.getFrameExtents();
      if (r.multiply(se), o.copy(Q.mapSize), (r.x > m || r.y > m) && (r.x > m && (o.x = Math.floor(m / se.x), r.x = o.x * se.x, Q.mapSize.x = o.x), r.y > m && (o.y = Math.floor(m / se.y), r.y = o.y * se.y, Q.mapSize.y = o.y)), Q.map === null || ye === !0 || K === !0) {
        const ue = this.type !== za ? { minFilter: Ui, magFilter: Ui } : {};
        Q.map !== null && Q.map.dispose(), Q.map = new ka(r.x, r.y, ue), Q.map.texture.name = Ee.name + ".shadowMap", Q.camera.updateProjectionMatrix();
      }
      i.setRenderTarget(Q.map), i.clear();
      const re = Q.getViewportCount();
      for (let ue = 0; ue < re; ue++) {
        const Le = Q.getViewport(ue);
        l.set(
          o.x * Le.x,
          o.y * Le.y,
          o.x * Le.z,
          o.y * Le.w
        ), le.viewport(l), Q.updateMatrices(Ee, ue), n = Q.getFrustum(), N(V, W, Q.camera, Ee, this.type);
      }
      Q.isPointLightShadow !== !0 && this.type === za && C(Q, W), Q.needsUpdate = !1;
    }
    M = this.type, T.needsUpdate = !1, i.setRenderTarget(U, O, q);
  };
  function C(I, V) {
    const W = e.update(w);
    y.defines.VSM_SAMPLES !== I.blurSamples && (y.defines.VSM_SAMPLES = I.blurSamples, _.defines.VSM_SAMPLES = I.blurSamples, y.needsUpdate = !0, _.needsUpdate = !0), I.mapPass === null && (I.mapPass = new ka(r.x, r.y)), y.uniforms.shadow_pass.value = I.map.texture, y.uniforms.resolution.value = I.mapSize, y.uniforms.radius.value = I.radius, i.setRenderTarget(I.mapPass), i.clear(), i.renderBufferDirect(V, null, W, y, w, null), _.uniforms.shadow_pass.value = I.mapPass.texture, _.uniforms.resolution.value = I.mapSize, _.uniforms.radius.value = I.radius, i.setRenderTarget(I.map), i.clear(), i.renderBufferDirect(V, null, W, _, w, null);
  }
  function A(I, V, W, U) {
    let O = null;
    const q = W.isPointLight === !0 ? I.customDistanceMaterial : I.customDepthMaterial;
    if (q !== void 0)
      O = q;
    else if (O = W.isPointLight === !0 ? d : u, i.localClippingEnabled && V.clipShadows === !0 && Array.isArray(V.clippingPlanes) && V.clippingPlanes.length !== 0 || V.displacementMap && V.displacementScale !== 0 || V.alphaMap && V.alphaTest > 0 || V.map && V.alphaTest > 0) {
      const le = O.uuid, ye = V.uuid;
      let K = h[le];
      K === void 0 && (K = {}, h[le] = K);
      let oe = K[ye];
      oe === void 0 && (oe = O.clone(), K[ye] = oe, V.addEventListener("dispose", z)), O = oe;
    }
    if (O.visible = V.visible, O.wireframe = V.wireframe, U === za ? O.side = V.shadowSide !== null ? V.shadowSide : V.side : O.side = V.shadowSide !== null ? V.shadowSide : g[V.side], O.alphaMap = V.alphaMap, O.alphaTest = V.alphaTest, O.map = V.map, O.clipShadows = V.clipShadows, O.clippingPlanes = V.clippingPlanes, O.clipIntersection = V.clipIntersection, O.displacementMap = V.displacementMap, O.displacementScale = V.displacementScale, O.displacementBias = V.displacementBias, O.wireframeLinewidth = V.wireframeLinewidth, O.linewidth = V.linewidth, W.isPointLight === !0 && O.isMeshDistanceMaterial === !0) {
      const le = i.properties.get(O);
      le.light = W;
    }
    return O;
  }
  function N(I, V, W, U, O) {
    if (I.visible === !1) return;
    if (I.layers.test(V.layers) && (I.isMesh || I.isLine || I.isPoints) && (I.castShadow || I.receiveShadow && O === za) && (!I.frustumCulled || n.intersectsObject(I))) {
      I.modelViewMatrix.multiplyMatrices(W.matrixWorldInverse, I.matrixWorld);
      const ye = e.update(I), K = I.material;
      if (Array.isArray(K)) {
        const oe = ye.groups;
        for (let ie = 0, Ee = oe.length; ie < Ee; ie++) {
          const Q = oe[ie], se = K[Q.materialIndex];
          if (se && se.visible) {
            const re = A(I, se, U, O);
            I.onBeforeShadow(i, I, V, W, ye, re, Q), i.renderBufferDirect(W, null, ye, re, I, Q), I.onAfterShadow(i, I, V, W, ye, re, Q);
          }
        }
      } else if (K.visible) {
        const oe = A(I, K, U, O);
        I.onBeforeShadow(i, I, V, W, ye, oe, null), i.renderBufferDirect(W, null, ye, oe, I, null), I.onAfterShadow(i, I, V, W, ye, oe, null);
      }
    }
    const le = I.children;
    for (let ye = 0, K = le.length; ye < K; ye++)
      N(le[ye], V, W, U, O);
  }
  function z(I) {
    I.target.removeEventListener("dispose", z);
    for (const W in h) {
      const U = h[W], O = I.target.uuid;
      O in U && (U[O].dispose(), delete U[O]);
    }
  }
}
function _H(i, e, t) {
  const n = t.isWebGL2;
  function r() {
    let ee = !1;
    const Ke = new Bn();
    let st = null;
    const zt = new Bn(0, 0, 0, 0);
    return {
      setMask: function(Ye) {
        st !== Ye && !ee && (i.colorMask(Ye, Ye, Ye, Ye), st = Ye);
      },
      setLocked: function(Ye) {
        ee = Ye;
      },
      setClear: function(Ye, qt, tn, Sn, bn) {
        bn === !0 && (Ye *= Sn, qt *= Sn, tn *= Sn), Ke.set(Ye, qt, tn, Sn), zt.equals(Ke) === !1 && (i.clearColor(Ye, qt, tn, Sn), zt.copy(Ke));
      },
      reset: function() {
        ee = !1, st = null, zt.set(-1, 0, 0, 0);
      }
    };
  }
  function o() {
    let ee = !1, Ke = null, st = null, zt = null;
    return {
      setTest: function(Ye) {
        Ye ? Ut(i.DEPTH_TEST) : ot(i.DEPTH_TEST);
      },
      setMask: function(Ye) {
        Ke !== Ye && !ee && (i.depthMask(Ye), Ke = Ye);
      },
      setFunc: function(Ye) {
        if (st !== Ye) {
          switch (Ye) {
            case iP:
              i.depthFunc(i.NEVER);
              break;
            case rP:
              i.depthFunc(i.ALWAYS);
              break;
            case sP:
              i.depthFunc(i.LESS);
              break;
            case sm:
              i.depthFunc(i.LEQUAL);
              break;
            case aP:
              i.depthFunc(i.EQUAL);
              break;
            case oP:
              i.depthFunc(i.GEQUAL);
              break;
            case lP:
              i.depthFunc(i.GREATER);
              break;
            case uP:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          st = Ye;
        }
      },
      setLocked: function(Ye) {
        ee = Ye;
      },
      setClear: function(Ye) {
        zt !== Ye && (i.clearDepth(Ye), zt = Ye);
      },
      reset: function() {
        ee = !1, Ke = null, st = null, zt = null;
      }
    };
  }
  function l() {
    let ee = !1, Ke = null, st = null, zt = null, Ye = null, qt = null, tn = null, Sn = null, bn = null;
    return {
      setTest: function(Jt) {
        ee || (Jt ? Ut(i.STENCIL_TEST) : ot(i.STENCIL_TEST));
      },
      setMask: function(Jt) {
        Ke !== Jt && !ee && (i.stencilMask(Jt), Ke = Jt);
      },
      setFunc: function(Jt, di, hi) {
        (st !== Jt || zt !== di || Ye !== hi) && (i.stencilFunc(Jt, di, hi), st = Jt, zt = di, Ye = hi);
      },
      setOp: function(Jt, di, hi) {
        (qt !== Jt || tn !== di || Sn !== hi) && (i.stencilOp(Jt, di, hi), qt = Jt, tn = di, Sn = hi);
      },
      setLocked: function(Jt) {
        ee = Jt;
      },
      setClear: function(Jt) {
        bn !== Jt && (i.clearStencil(Jt), bn = Jt);
      },
      reset: function() {
        ee = !1, Ke = null, st = null, zt = null, Ye = null, qt = null, tn = null, Sn = null, bn = null;
      }
    };
  }
  const u = new r(), d = new o(), h = new l(), m = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
  let y = {}, _ = {}, E = /* @__PURE__ */ new WeakMap(), w = [], T = null, M = !1, C = null, A = null, N = null, z = null, I = null, V = null, W = null, U = new Tt(0, 0, 0), O = 0, q = !1, le = null, ye = null, K = null, oe = null, ie = null;
  const Ee = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Q = !1, se = 0;
  const re = i.getParameter(i.VERSION);
  re.indexOf("WebGL") !== -1 ? (se = parseFloat(/^WebGL (\d)/.exec(re)[1]), Q = se >= 1) : re.indexOf("OpenGL ES") !== -1 && (se = parseFloat(/^OpenGL ES (\d)/.exec(re)[1]), Q = se >= 2);
  let ue = null, Le = {};
  const pe = i.getParameter(i.SCISSOR_BOX), Ae = i.getParameter(i.VIEWPORT), qe = new Bn().fromArray(pe), je = new Bn().fromArray(Ae);
  function $e(ee, Ke, st, zt) {
    const Ye = new Uint8Array(4), qt = i.createTexture();
    i.bindTexture(ee, qt), i.texParameteri(ee, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(ee, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let tn = 0; tn < st; tn++)
      n && (ee === i.TEXTURE_3D || ee === i.TEXTURE_2D_ARRAY) ? i.texImage3D(Ke, 0, i.RGBA, 1, 1, zt, 0, i.RGBA, i.UNSIGNED_BYTE, Ye) : i.texImage2D(Ke + tn, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, Ye);
    return qt;
  }
  const Rt = {};
  Rt[i.TEXTURE_2D] = $e(i.TEXTURE_2D, i.TEXTURE_2D, 1), Rt[i.TEXTURE_CUBE_MAP] = $e(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (Rt[i.TEXTURE_2D_ARRAY] = $e(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), Rt[i.TEXTURE_3D] = $e(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)), u.setClear(0, 0, 0, 1), d.setClear(1), h.setClear(0), Ut(i.DEPTH_TEST), d.setFunc(sm), rt(!1), G(vM), Ut(i.CULL_FACE), Re(nl);
  function Ut(ee) {
    y[ee] !== !0 && (i.enable(ee), y[ee] = !0);
  }
  function ot(ee) {
    y[ee] !== !1 && (i.disable(ee), y[ee] = !1);
  }
  function pt(ee, Ke) {
    return _[ee] !== Ke ? (i.bindFramebuffer(ee, Ke), _[ee] = Ke, n && (ee === i.DRAW_FRAMEBUFFER && (_[i.FRAMEBUFFER] = Ke), ee === i.FRAMEBUFFER && (_[i.DRAW_FRAMEBUFFER] = Ke)), !0) : !1;
  }
  function J(ee, Ke) {
    let st = w, zt = !1;
    if (ee)
      if (st = E.get(Ke), st === void 0 && (st = [], E.set(Ke, st)), ee.isWebGLMultipleRenderTargets) {
        const Ye = ee.texture;
        if (st.length !== Ye.length || st[0] !== i.COLOR_ATTACHMENT0) {
          for (let qt = 0, tn = Ye.length; qt < tn; qt++)
            st[qt] = i.COLOR_ATTACHMENT0 + qt;
          st.length = Ye.length, zt = !0;
        }
      } else
        st[0] !== i.COLOR_ATTACHMENT0 && (st[0] = i.COLOR_ATTACHMENT0, zt = !0);
    else
      st[0] !== i.BACK && (st[0] = i.BACK, zt = !0);
    zt && (t.isWebGL2 ? i.drawBuffers(st) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(st));
  }
  function Be(ee) {
    return T !== ee ? (i.useProgram(ee), T = ee, !0) : !1;
  }
  const Pe = {
    [uu]: i.FUNC_ADD,
    [kC]: i.FUNC_SUBTRACT,
    [GC]: i.FUNC_REVERSE_SUBTRACT
  };
  if (n)
    Pe[_M] = i.MIN, Pe[SM] = i.MAX;
  else {
    const ee = e.get("EXT_blend_minmax");
    ee !== null && (Pe[_M] = ee.MIN_EXT, Pe[SM] = ee.MAX_EXT);
  }
  const He = {
    [WC]: i.ZERO,
    [XC]: i.ONE,
    [jC]: i.SRC_COLOR,
    [jy]: i.SRC_ALPHA,
    [QC]: i.SRC_ALPHA_SATURATE,
    [KC]: i.DST_COLOR,
    [qC]: i.DST_ALPHA,
    [YC]: i.ONE_MINUS_SRC_COLOR,
    [Yy]: i.ONE_MINUS_SRC_ALPHA,
    [JC]: i.ONE_MINUS_DST_COLOR,
    [ZC]: i.ONE_MINUS_DST_ALPHA,
    [$C]: i.CONSTANT_COLOR,
    [eP]: i.ONE_MINUS_CONSTANT_COLOR,
    [tP]: i.CONSTANT_ALPHA,
    [nP]: i.ONE_MINUS_CONSTANT_ALPHA
  };
  function Re(ee, Ke, st, zt, Ye, qt, tn, Sn, bn, Jt) {
    if (ee === nl) {
      M === !0 && (ot(i.BLEND), M = !1);
      return;
    }
    if (M === !1 && (Ut(i.BLEND), M = !0), ee !== HC) {
      if (ee !== C || Jt !== q) {
        if ((A !== uu || I !== uu) && (i.blendEquation(i.FUNC_ADD), A = uu, I = uu), Jt)
          switch (ee) {
            case Nc:
              i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case gM:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case yM:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case xM:
              i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        else
          switch (ee) {
            case Nc:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case gM:
              i.blendFunc(i.SRC_ALPHA, i.ONE);
              break;
            case yM:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case xM:
              i.blendFunc(i.ZERO, i.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        N = null, z = null, V = null, W = null, U.set(0, 0, 0), O = 0, C = ee, q = Jt;
      }
      return;
    }
    Ye = Ye || Ke, qt = qt || st, tn = tn || zt, (Ke !== A || Ye !== I) && (i.blendEquationSeparate(Pe[Ke], Pe[Ye]), A = Ke, I = Ye), (st !== N || zt !== z || qt !== V || tn !== W) && (i.blendFuncSeparate(He[st], He[zt], He[qt], He[tn]), N = st, z = zt, V = qt, W = tn), (Sn.equals(U) === !1 || bn !== O) && (i.blendColor(Sn.r, Sn.g, Sn.b, bn), U.copy(Sn), O = bn), C = ee, q = !1;
  }
  function _t(ee, Ke) {
    ee.side === po ? ot(i.CULL_FACE) : Ut(i.CULL_FACE);
    let st = ee.side === ss;
    Ke && (st = !st), rt(st), ee.blending === Nc && ee.transparent === !1 ? Re(nl) : Re(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.blendColor, ee.blendAlpha, ee.premultipliedAlpha), d.setFunc(ee.depthFunc), d.setTest(ee.depthTest), d.setMask(ee.depthWrite), u.setMask(ee.colorWrite);
    const zt = ee.stencilWrite;
    h.setTest(zt), zt && (h.setMask(ee.stencilWriteMask), h.setFunc(ee.stencilFunc, ee.stencilRef, ee.stencilFuncMask), h.setOp(ee.stencilFail, ee.stencilZFail, ee.stencilZPass)), ce(ee.polygonOffset, ee.polygonOffsetFactor, ee.polygonOffsetUnits), ee.alphaToCoverage === !0 ? Ut(i.SAMPLE_ALPHA_TO_COVERAGE) : ot(i.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function rt(ee) {
    le !== ee && (ee ? i.frontFace(i.CW) : i.frontFace(i.CCW), le = ee);
  }
  function G(ee) {
    ee !== zC ? (Ut(i.CULL_FACE), ee !== ye && (ee === vM ? i.cullFace(i.BACK) : ee === BC ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : ot(i.CULL_FACE), ye = ee;
  }
  function B(ee) {
    ee !== K && (Q && i.lineWidth(ee), K = ee);
  }
  function ce(ee, Ke, st) {
    ee ? (Ut(i.POLYGON_OFFSET_FILL), (oe !== Ke || ie !== st) && (i.polygonOffset(Ke, st), oe = Ke, ie = st)) : ot(i.POLYGON_OFFSET_FILL);
  }
  function Fe(ee) {
    ee ? Ut(i.SCISSOR_TEST) : ot(i.SCISSOR_TEST);
  }
  function ze(ee) {
    ee === void 0 && (ee = i.TEXTURE0 + Ee - 1), ue !== ee && (i.activeTexture(ee), ue = ee);
  }
  function Ie(ee, Ke, st) {
    st === void 0 && (ue === null ? st = i.TEXTURE0 + Ee - 1 : st = ue);
    let zt = Le[st];
    zt === void 0 && (zt = { type: void 0, texture: void 0 }, Le[st] = zt), (zt.type !== ee || zt.texture !== Ke) && (ue !== st && (i.activeTexture(st), ue = st), i.bindTexture(ee, Ke || Rt[ee]), zt.type = ee, zt.texture = Ke);
  }
  function Mt() {
    const ee = Le[ue];
    ee !== void 0 && ee.type !== void 0 && (i.bindTexture(ee.type, null), ee.type = void 0, ee.texture = void 0);
  }
  function it() {
    try {
      i.compressedTexImage2D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function mt() {
    try {
      i.compressedTexImage3D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Dt() {
    try {
      i.texSubImage2D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ht() {
    try {
      i.texSubImage3D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function de() {
    try {
      i.compressedTexSubImage2D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function nt() {
    try {
      i.compressedTexSubImage3D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function lt() {
    try {
      i.texStorage2D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Xe() {
    try {
      i.texStorage3D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function dt() {
    try {
      i.texImage2D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function at() {
    try {
      i.texImage3D.apply(i, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Y(ee) {
    qe.equals(ee) === !1 && (i.scissor(ee.x, ee.y, ee.z, ee.w), qe.copy(ee));
  }
  function he(ee) {
    je.equals(ee) === !1 && (i.viewport(ee.x, ee.y, ee.z, ee.w), je.copy(ee));
  }
  function Ze(ee, Ke) {
    let st = g.get(Ke);
    st === void 0 && (st = /* @__PURE__ */ new WeakMap(), g.set(Ke, st));
    let zt = st.get(ee);
    zt === void 0 && (zt = i.getUniformBlockIndex(Ke, ee.name), st.set(ee, zt));
  }
  function Ve(ee, Ke) {
    const zt = g.get(Ke).get(ee);
    m.get(Ke) !== zt && (i.uniformBlockBinding(Ke, zt, ee.__bindingPointIndex), m.set(Ke, zt));
  }
  function Te() {
    i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), n === !0 && (i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), y = {}, ue = null, Le = {}, _ = {}, E = /* @__PURE__ */ new WeakMap(), w = [], T = null, M = !1, C = null, A = null, N = null, z = null, I = null, V = null, W = null, U = new Tt(0, 0, 0), O = 0, q = !1, le = null, ye = null, K = null, oe = null, ie = null, qe.set(0, 0, i.canvas.width, i.canvas.height), je.set(0, 0, i.canvas.width, i.canvas.height), u.reset(), d.reset(), h.reset();
  }
  return {
    buffers: {
      color: u,
      depth: d,
      stencil: h
    },
    enable: Ut,
    disable: ot,
    bindFramebuffer: pt,
    drawBuffers: J,
    useProgram: Be,
    setBlending: Re,
    setMaterial: _t,
    setFlipSided: rt,
    setCullFace: G,
    setLineWidth: B,
    setPolygonOffset: ce,
    setScissorTest: Fe,
    activeTexture: ze,
    bindTexture: Ie,
    unbindTexture: Mt,
    compressedTexImage2D: it,
    compressedTexImage3D: mt,
    texImage2D: dt,
    texImage3D: at,
    updateUBOMapping: Ze,
    uniformBlockBinding: Ve,
    texStorage2D: lt,
    texStorage3D: Xe,
    texSubImage2D: Dt,
    texSubImage3D: Ht,
    compressedTexSubImage2D: de,
    compressedTexSubImage3D: nt,
    scissor: Y,
    viewport: he,
    reset: Te
  };
}
function SH(i, e, t, n, r, o, l) {
  const u = r.isWebGL2, d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, h = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), m = /* @__PURE__ */ new WeakMap();
  let g;
  const y = /* @__PURE__ */ new WeakMap();
  let _ = !1;
  try {
    _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function E(G, B) {
    return _ ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(G, B)
    ) : gm("canvas");
  }
  function w(G, B, ce, Fe) {
    let ze = 1;
    if ((G.width > Fe || G.height > Fe) && (ze = Fe / Math.max(G.width, G.height)), ze < 1 || B === !0)
      if (typeof HTMLImageElement < "u" && G instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && G instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && G instanceof ImageBitmap) {
        const Ie = B ? Ky : Math.floor, Mt = Ie(ze * G.width), it = Ie(ze * G.height);
        g === void 0 && (g = E(Mt, it));
        const mt = ce ? E(Mt, it) : g;
        return mt.width = Mt, mt.height = it, mt.getContext("2d").drawImage(G, 0, 0, Mt, it), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + G.width + "x" + G.height + ") to (" + Mt + "x" + it + ")."), mt;
      } else
        return "data" in G && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + G.width + "x" + G.height + ")."), G;
    return G;
  }
  function T(G) {
    return KM(G.width) && KM(G.height);
  }
  function M(G) {
    return u ? !1 : G.wrapS !== Wr || G.wrapT !== Wr || G.minFilter !== Ui && G.minFilter !== Oi;
  }
  function C(G, B) {
    return G.generateMipmaps && B && G.minFilter !== Ui && G.minFilter !== Oi;
  }
  function A(G) {
    i.generateMipmap(G);
  }
  function N(G, B, ce, Fe, ze = !1) {
    if (u === !1) return B;
    if (G !== null) {
      if (i[G] !== void 0) return i[G];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + G + "'");
    }
    let Ie = B;
    if (B === i.RED && (ce === i.FLOAT && (Ie = i.R32F), ce === i.HALF_FLOAT && (Ie = i.R16F), ce === i.UNSIGNED_BYTE && (Ie = i.R8)), B === i.RED_INTEGER && (ce === i.UNSIGNED_BYTE && (Ie = i.R8UI), ce === i.UNSIGNED_SHORT && (Ie = i.R16UI), ce === i.UNSIGNED_INT && (Ie = i.R32UI), ce === i.BYTE && (Ie = i.R8I), ce === i.SHORT && (Ie = i.R16I), ce === i.INT && (Ie = i.R32I)), B === i.RG && (ce === i.FLOAT && (Ie = i.RG32F), ce === i.HALF_FLOAT && (Ie = i.RG16F), ce === i.UNSIGNED_BYTE && (Ie = i.RG8)), B === i.RGBA) {
      const Mt = ze ? hm : zn.getTransfer(Fe);
      ce === i.FLOAT && (Ie = i.RGBA32F), ce === i.HALF_FLOAT && (Ie = i.RGBA16F), ce === i.UNSIGNED_BYTE && (Ie = Mt === Yn ? i.SRGB8_ALPHA8 : i.RGBA8), ce === i.UNSIGNED_SHORT_4_4_4_4 && (Ie = i.RGBA4), ce === i.UNSIGNED_SHORT_5_5_5_1 && (Ie = i.RGB5_A1);
    }
    return (Ie === i.R16F || Ie === i.R32F || Ie === i.RG16F || Ie === i.RG32F || Ie === i.RGBA16F || Ie === i.RGBA32F) && e.get("EXT_color_buffer_float"), Ie;
  }
  function z(G, B, ce) {
    return C(G, ce) === !0 || G.isFramebufferTexture && G.minFilter !== Ui && G.minFilter !== Oi ? Math.log2(Math.max(B.width, B.height)) + 1 : G.mipmaps !== void 0 && G.mipmaps.length > 0 ? G.mipmaps.length : G.isCompressedTexture && Array.isArray(G.image) ? B.mipmaps.length : 1;
  }
  function I(G) {
    return G === Ui || G === qy || G === Kp ? i.NEAREST : i.LINEAR;
  }
  function V(G) {
    const B = G.target;
    B.removeEventListener("dispose", V), U(B), B.isVideoTexture && m.delete(B);
  }
  function W(G) {
    const B = G.target;
    B.removeEventListener("dispose", W), q(B);
  }
  function U(G) {
    const B = n.get(G);
    if (B.__webglInit === void 0) return;
    const ce = G.source, Fe = y.get(ce);
    if (Fe) {
      const ze = Fe[B.__cacheKey];
      ze.usedTimes--, ze.usedTimes === 0 && O(G), Object.keys(Fe).length === 0 && y.delete(ce);
    }
    n.remove(G);
  }
  function O(G) {
    const B = n.get(G);
    i.deleteTexture(B.__webglTexture);
    const ce = G.source, Fe = y.get(ce);
    delete Fe[B.__cacheKey], l.memory.textures--;
  }
  function q(G) {
    const B = G.texture, ce = n.get(G), Fe = n.get(B);
    if (Fe.__webglTexture !== void 0 && (i.deleteTexture(Fe.__webglTexture), l.memory.textures--), G.depthTexture && G.depthTexture.dispose(), G.isWebGLCubeRenderTarget)
      for (let ze = 0; ze < 6; ze++) {
        if (Array.isArray(ce.__webglFramebuffer[ze]))
          for (let Ie = 0; Ie < ce.__webglFramebuffer[ze].length; Ie++) i.deleteFramebuffer(ce.__webglFramebuffer[ze][Ie]);
        else
          i.deleteFramebuffer(ce.__webglFramebuffer[ze]);
        ce.__webglDepthbuffer && i.deleteRenderbuffer(ce.__webglDepthbuffer[ze]);
      }
    else {
      if (Array.isArray(ce.__webglFramebuffer))
        for (let ze = 0; ze < ce.__webglFramebuffer.length; ze++) i.deleteFramebuffer(ce.__webglFramebuffer[ze]);
      else
        i.deleteFramebuffer(ce.__webglFramebuffer);
      if (ce.__webglDepthbuffer && i.deleteRenderbuffer(ce.__webglDepthbuffer), ce.__webglMultisampledFramebuffer && i.deleteFramebuffer(ce.__webglMultisampledFramebuffer), ce.__webglColorRenderbuffer)
        for (let ze = 0; ze < ce.__webglColorRenderbuffer.length; ze++)
          ce.__webglColorRenderbuffer[ze] && i.deleteRenderbuffer(ce.__webglColorRenderbuffer[ze]);
      ce.__webglDepthRenderbuffer && i.deleteRenderbuffer(ce.__webglDepthRenderbuffer);
    }
    if (G.isWebGLMultipleRenderTargets)
      for (let ze = 0, Ie = B.length; ze < Ie; ze++) {
        const Mt = n.get(B[ze]);
        Mt.__webglTexture && (i.deleteTexture(Mt.__webglTexture), l.memory.textures--), n.remove(B[ze]);
      }
    n.remove(B), n.remove(G);
  }
  let le = 0;
  function ye() {
    le = 0;
  }
  function K() {
    const G = le;
    return G >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + G + " texture units while this GPU supports only " + r.maxTextures), le += 1, G;
  }
  function oe(G) {
    const B = [];
    return B.push(G.wrapS), B.push(G.wrapT), B.push(G.wrapR || 0), B.push(G.magFilter), B.push(G.minFilter), B.push(G.anisotropy), B.push(G.internalFormat), B.push(G.format), B.push(G.type), B.push(G.generateMipmaps), B.push(G.premultiplyAlpha), B.push(G.flipY), B.push(G.unpackAlignment), B.push(G.colorSpace), B.join();
  }
  function ie(G, B) {
    const ce = n.get(G);
    if (G.isVideoTexture && _t(G), G.isRenderTargetTexture === !1 && G.version > 0 && ce.__version !== G.version) {
      const Fe = G.image;
      if (Fe === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Fe.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        qe(ce, G, B);
        return;
      }
    }
    t.bindTexture(i.TEXTURE_2D, ce.__webglTexture, i.TEXTURE0 + B);
  }
  function Ee(G, B) {
    const ce = n.get(G);
    if (G.version > 0 && ce.__version !== G.version) {
      qe(ce, G, B);
      return;
    }
    t.bindTexture(i.TEXTURE_2D_ARRAY, ce.__webglTexture, i.TEXTURE0 + B);
  }
  function Q(G, B) {
    const ce = n.get(G);
    if (G.version > 0 && ce.__version !== G.version) {
      qe(ce, G, B);
      return;
    }
    t.bindTexture(i.TEXTURE_3D, ce.__webglTexture, i.TEXTURE0 + B);
  }
  function se(G, B) {
    const ce = n.get(G);
    if (G.version > 0 && ce.__version !== G.version) {
      je(ce, G, B);
      return;
    }
    t.bindTexture(i.TEXTURE_CUBE_MAP, ce.__webglTexture, i.TEXTURE0 + B);
  }
  const re = {
    [lm]: i.REPEAT,
    [Wr]: i.CLAMP_TO_EDGE,
    [um]: i.MIRRORED_REPEAT
  }, ue = {
    [Ui]: i.NEAREST,
    [qy]: i.NEAREST_MIPMAP_NEAREST,
    [Kp]: i.NEAREST_MIPMAP_LINEAR,
    [Oi]: i.LINEAR,
    [AE]: i.LINEAR_MIPMAP_NEAREST,
    [gu]: i.LINEAR_MIPMAP_LINEAR
  }, Le = {
    [DP]: i.NEVER,
    [zP]: i.ALWAYS,
    [NP]: i.LESS,
    [FE]: i.LEQUAL,
    [UP]: i.EQUAL,
    [FP]: i.GEQUAL,
    [OP]: i.GREATER,
    [IP]: i.NOTEQUAL
  };
  function pe(G, B, ce) {
    if (ce ? (i.texParameteri(G, i.TEXTURE_WRAP_S, re[B.wrapS]), i.texParameteri(G, i.TEXTURE_WRAP_T, re[B.wrapT]), (G === i.TEXTURE_3D || G === i.TEXTURE_2D_ARRAY) && i.texParameteri(G, i.TEXTURE_WRAP_R, re[B.wrapR]), i.texParameteri(G, i.TEXTURE_MAG_FILTER, ue[B.magFilter]), i.texParameteri(G, i.TEXTURE_MIN_FILTER, ue[B.minFilter])) : (i.texParameteri(G, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(G, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), (G === i.TEXTURE_3D || G === i.TEXTURE_2D_ARRAY) && i.texParameteri(G, i.TEXTURE_WRAP_R, i.CLAMP_TO_EDGE), (B.wrapS !== Wr || B.wrapT !== Wr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(G, i.TEXTURE_MAG_FILTER, I(B.magFilter)), i.texParameteri(G, i.TEXTURE_MIN_FILTER, I(B.minFilter)), B.minFilter !== Ui && B.minFilter !== Oi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), B.compareFunction && (i.texParameteri(G, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(G, i.TEXTURE_COMPARE_FUNC, Le[B.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const Fe = e.get("EXT_texture_filter_anisotropic");
      if (B.magFilter === Ui || B.minFilter !== Kp && B.minFilter !== gu || B.type === Va && e.has("OES_texture_float_linear") === !1 || u === !1 && B.type === Qd && e.has("OES_texture_half_float_linear") === !1) return;
      (B.anisotropy > 1 || n.get(B).__currentAnisotropy) && (i.texParameterf(G, Fe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(B.anisotropy, r.getMaxAnisotropy())), n.get(B).__currentAnisotropy = B.anisotropy);
    }
  }
  function Ae(G, B) {
    let ce = !1;
    G.__webglInit === void 0 && (G.__webglInit = !0, B.addEventListener("dispose", V));
    const Fe = B.source;
    let ze = y.get(Fe);
    ze === void 0 && (ze = {}, y.set(Fe, ze));
    const Ie = oe(B);
    if (Ie !== G.__cacheKey) {
      ze[Ie] === void 0 && (ze[Ie] = {
        texture: i.createTexture(),
        usedTimes: 0
      }, l.memory.textures++, ce = !0), ze[Ie].usedTimes++;
      const Mt = ze[G.__cacheKey];
      Mt !== void 0 && (ze[G.__cacheKey].usedTimes--, Mt.usedTimes === 0 && O(B)), G.__cacheKey = Ie, G.__webglTexture = ze[Ie].texture;
    }
    return ce;
  }
  function qe(G, B, ce) {
    let Fe = i.TEXTURE_2D;
    (B.isDataArrayTexture || B.isCompressedArrayTexture) && (Fe = i.TEXTURE_2D_ARRAY), B.isData3DTexture && (Fe = i.TEXTURE_3D);
    const ze = Ae(G, B), Ie = B.source;
    t.bindTexture(Fe, G.__webglTexture, i.TEXTURE0 + ce);
    const Mt = n.get(Ie);
    if (Ie.version !== Mt.__version || ze === !0) {
      t.activeTexture(i.TEXTURE0 + ce);
      const it = zn.getPrimaries(zn.workingColorSpace), mt = B.colorSpace === Vs ? null : zn.getPrimaries(B.colorSpace), Dt = B.colorSpace === Vs || it === mt ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, B.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, B.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Dt);
      const Ht = M(B) && T(B.image) === !1;
      let de = w(B.image, Ht, !1, r.maxTextureSize);
      de = rt(B, de);
      const nt = T(de) || u, lt = o.convert(B.format, B.colorSpace);
      let Xe = o.convert(B.type), dt = N(B.internalFormat, lt, Xe, B.colorSpace, B.isVideoTexture);
      pe(Fe, B, nt);
      let at;
      const Y = B.mipmaps, he = u && B.isVideoTexture !== !0 && dt !== UE, Ze = Mt.__version === void 0 || ze === !0, Ve = z(B, de, nt);
      if (B.isDepthTexture)
        dt = i.DEPTH_COMPONENT, u ? B.type === Va ? dt = i.DEPTH_COMPONENT32F : B.type === $o ? dt = i.DEPTH_COMPONENT24 : B.type === cu ? dt = i.DEPTH24_STENCIL8 : dt = i.DEPTH_COMPONENT16 : B.type === Va && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), B.format === fu && dt === i.DEPTH_COMPONENT && B.type !== f0 && B.type !== $o && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), B.type = $o, Xe = o.convert(B.type)), B.format === Bc && dt === i.DEPTH_COMPONENT && (dt = i.DEPTH_STENCIL, B.type !== cu && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), B.type = cu, Xe = o.convert(B.type))), Ze && (he ? t.texStorage2D(i.TEXTURE_2D, 1, dt, de.width, de.height) : t.texImage2D(i.TEXTURE_2D, 0, dt, de.width, de.height, 0, lt, Xe, null));
      else if (B.isDataTexture)
        if (Y.length > 0 && nt) {
          he && Ze && t.texStorage2D(i.TEXTURE_2D, Ve, dt, Y[0].width, Y[0].height);
          for (let Te = 0, ee = Y.length; Te < ee; Te++)
            at = Y[Te], he ? t.texSubImage2D(i.TEXTURE_2D, Te, 0, 0, at.width, at.height, lt, Xe, at.data) : t.texImage2D(i.TEXTURE_2D, Te, dt, at.width, at.height, 0, lt, Xe, at.data);
          B.generateMipmaps = !1;
        } else
          he ? (Ze && t.texStorage2D(i.TEXTURE_2D, Ve, dt, de.width, de.height), t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, de.width, de.height, lt, Xe, de.data)) : t.texImage2D(i.TEXTURE_2D, 0, dt, de.width, de.height, 0, lt, Xe, de.data);
      else if (B.isCompressedTexture)
        if (B.isCompressedArrayTexture) {
          he && Ze && t.texStorage3D(i.TEXTURE_2D_ARRAY, Ve, dt, Y[0].width, Y[0].height, de.depth);
          for (let Te = 0, ee = Y.length; Te < ee; Te++)
            at = Y[Te], B.format !== is ? lt !== null ? he ? t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, Te, 0, 0, 0, at.width, at.height, de.depth, lt, at.data, 0, 0) : t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, Te, dt, at.width, at.height, de.depth, 0, at.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : he ? t.texSubImage3D(i.TEXTURE_2D_ARRAY, Te, 0, 0, 0, at.width, at.height, de.depth, lt, Xe, at.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, Te, dt, at.width, at.height, de.depth, 0, lt, Xe, at.data);
        } else {
          he && Ze && t.texStorage2D(i.TEXTURE_2D, Ve, dt, Y[0].width, Y[0].height);
          for (let Te = 0, ee = Y.length; Te < ee; Te++)
            at = Y[Te], B.format !== is ? lt !== null ? he ? t.compressedTexSubImage2D(i.TEXTURE_2D, Te, 0, 0, at.width, at.height, lt, at.data) : t.compressedTexImage2D(i.TEXTURE_2D, Te, dt, at.width, at.height, 0, at.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : he ? t.texSubImage2D(i.TEXTURE_2D, Te, 0, 0, at.width, at.height, lt, Xe, at.data) : t.texImage2D(i.TEXTURE_2D, Te, dt, at.width, at.height, 0, lt, Xe, at.data);
        }
      else if (B.isDataArrayTexture)
        he ? (Ze && t.texStorage3D(i.TEXTURE_2D_ARRAY, Ve, dt, de.width, de.height, de.depth), t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, de.width, de.height, de.depth, lt, Xe, de.data)) : t.texImage3D(i.TEXTURE_2D_ARRAY, 0, dt, de.width, de.height, de.depth, 0, lt, Xe, de.data);
      else if (B.isData3DTexture)
        he ? (Ze && t.texStorage3D(i.TEXTURE_3D, Ve, dt, de.width, de.height, de.depth), t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, de.width, de.height, de.depth, lt, Xe, de.data)) : t.texImage3D(i.TEXTURE_3D, 0, dt, de.width, de.height, de.depth, 0, lt, Xe, de.data);
      else if (B.isFramebufferTexture) {
        if (Ze)
          if (he)
            t.texStorage2D(i.TEXTURE_2D, Ve, dt, de.width, de.height);
          else {
            let Te = de.width, ee = de.height;
            for (let Ke = 0; Ke < Ve; Ke++)
              t.texImage2D(i.TEXTURE_2D, Ke, dt, Te, ee, 0, lt, Xe, null), Te >>= 1, ee >>= 1;
          }
      } else if (Y.length > 0 && nt) {
        he && Ze && t.texStorage2D(i.TEXTURE_2D, Ve, dt, Y[0].width, Y[0].height);
        for (let Te = 0, ee = Y.length; Te < ee; Te++)
          at = Y[Te], he ? t.texSubImage2D(i.TEXTURE_2D, Te, 0, 0, lt, Xe, at) : t.texImage2D(i.TEXTURE_2D, Te, dt, lt, Xe, at);
        B.generateMipmaps = !1;
      } else
        he ? (Ze && t.texStorage2D(i.TEXTURE_2D, Ve, dt, de.width, de.height), t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, lt, Xe, de)) : t.texImage2D(i.TEXTURE_2D, 0, dt, lt, Xe, de);
      C(B, nt) && A(Fe), Mt.__version = Ie.version, B.onUpdate && B.onUpdate(B);
    }
    G.__version = B.version;
  }
  function je(G, B, ce) {
    if (B.image.length !== 6) return;
    const Fe = Ae(G, B), ze = B.source;
    t.bindTexture(i.TEXTURE_CUBE_MAP, G.__webglTexture, i.TEXTURE0 + ce);
    const Ie = n.get(ze);
    if (ze.version !== Ie.__version || Fe === !0) {
      t.activeTexture(i.TEXTURE0 + ce);
      const Mt = zn.getPrimaries(zn.workingColorSpace), it = B.colorSpace === Vs ? null : zn.getPrimaries(B.colorSpace), mt = B.colorSpace === Vs || Mt === it ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, B.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, B.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, mt);
      const Dt = B.isCompressedTexture || B.image[0].isCompressedTexture, Ht = B.image[0] && B.image[0].isDataTexture, de = [];
      for (let Te = 0; Te < 6; Te++)
        !Dt && !Ht ? de[Te] = w(B.image[Te], !1, !0, r.maxCubemapSize) : de[Te] = Ht ? B.image[Te].image : B.image[Te], de[Te] = rt(B, de[Te]);
      const nt = de[0], lt = T(nt) || u, Xe = o.convert(B.format, B.colorSpace), dt = o.convert(B.type), at = N(B.internalFormat, Xe, dt, B.colorSpace), Y = u && B.isVideoTexture !== !0, he = Ie.__version === void 0 || Fe === !0;
      let Ze = z(B, nt, lt);
      pe(i.TEXTURE_CUBE_MAP, B, lt);
      let Ve;
      if (Dt) {
        Y && he && t.texStorage2D(i.TEXTURE_CUBE_MAP, Ze, at, nt.width, nt.height);
        for (let Te = 0; Te < 6; Te++) {
          Ve = de[Te].mipmaps;
          for (let ee = 0; ee < Ve.length; ee++) {
            const Ke = Ve[ee];
            B.format !== is ? Xe !== null ? Y ? t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee, 0, 0, Ke.width, Ke.height, Xe, Ke.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee, at, Ke.width, Ke.height, 0, Ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Y ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee, 0, 0, Ke.width, Ke.height, Xe, dt, Ke.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee, at, Ke.width, Ke.height, 0, Xe, dt, Ke.data);
          }
        }
      } else {
        Ve = B.mipmaps, Y && he && (Ve.length > 0 && Ze++, t.texStorage2D(i.TEXTURE_CUBE_MAP, Ze, at, de[0].width, de[0].height));
        for (let Te = 0; Te < 6; Te++)
          if (Ht) {
            Y ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, 0, 0, de[Te].width, de[Te].height, Xe, dt, de[Te].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, at, de[Te].width, de[Te].height, 0, Xe, dt, de[Te].data);
            for (let ee = 0; ee < Ve.length; ee++) {
              const st = Ve[ee].image[Te].image;
              Y ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee + 1, 0, 0, st.width, st.height, Xe, dt, st.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee + 1, at, st.width, st.height, 0, Xe, dt, st.data);
            }
          } else {
            Y ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, 0, 0, Xe, dt, de[Te]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, at, Xe, dt, de[Te]);
            for (let ee = 0; ee < Ve.length; ee++) {
              const Ke = Ve[ee];
              Y ? t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee + 1, 0, 0, Xe, dt, Ke.image[Te]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Te, ee + 1, at, Xe, dt, Ke.image[Te]);
            }
          }
      }
      C(B, lt) && A(i.TEXTURE_CUBE_MAP), Ie.__version = ze.version, B.onUpdate && B.onUpdate(B);
    }
    G.__version = B.version;
  }
  function $e(G, B, ce, Fe, ze, Ie) {
    const Mt = o.convert(ce.format, ce.colorSpace), it = o.convert(ce.type), mt = N(ce.internalFormat, Mt, it, ce.colorSpace);
    if (!n.get(B).__hasExternalTextures) {
      const Ht = Math.max(1, B.width >> Ie), de = Math.max(1, B.height >> Ie);
      ze === i.TEXTURE_3D || ze === i.TEXTURE_2D_ARRAY ? t.texImage3D(ze, Ie, mt, Ht, de, B.depth, 0, Mt, it, null) : t.texImage2D(ze, Ie, mt, Ht, de, 0, Mt, it, null);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, G), Re(B) ? d.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Fe, ze, n.get(ce).__webglTexture, 0, He(B)) : (ze === i.TEXTURE_2D || ze >= i.TEXTURE_CUBE_MAP_POSITIVE_X && ze <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Fe, ze, n.get(ce).__webglTexture, Ie), t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function Rt(G, B, ce) {
    if (i.bindRenderbuffer(i.RENDERBUFFER, G), B.depthBuffer && !B.stencilBuffer) {
      let Fe = u === !0 ? i.DEPTH_COMPONENT24 : i.DEPTH_COMPONENT16;
      if (ce || Re(B)) {
        const ze = B.depthTexture;
        ze && ze.isDepthTexture && (ze.type === Va ? Fe = i.DEPTH_COMPONENT32F : ze.type === $o && (Fe = i.DEPTH_COMPONENT24));
        const Ie = He(B);
        Re(B) ? d.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Ie, Fe, B.width, B.height) : i.renderbufferStorageMultisample(i.RENDERBUFFER, Ie, Fe, B.width, B.height);
      } else
        i.renderbufferStorage(i.RENDERBUFFER, Fe, B.width, B.height);
      i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, G);
    } else if (B.depthBuffer && B.stencilBuffer) {
      const Fe = He(B);
      ce && Re(B) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Fe, i.DEPTH24_STENCIL8, B.width, B.height) : Re(B) ? d.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Fe, i.DEPTH24_STENCIL8, B.width, B.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, B.width, B.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, G);
    } else {
      const Fe = B.isWebGLMultipleRenderTargets === !0 ? B.texture : [B.texture];
      for (let ze = 0; ze < Fe.length; ze++) {
        const Ie = Fe[ze], Mt = o.convert(Ie.format, Ie.colorSpace), it = o.convert(Ie.type), mt = N(Ie.internalFormat, Mt, it, Ie.colorSpace), Dt = He(B);
        ce && Re(B) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Dt, mt, B.width, B.height) : Re(B) ? d.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Dt, mt, B.width, B.height) : i.renderbufferStorage(i.RENDERBUFFER, mt, B.width, B.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function Ut(G, B) {
    if (B && B.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(i.FRAMEBUFFER, G), !(B.depthTexture && B.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(B.depthTexture).__webglTexture || B.depthTexture.image.width !== B.width || B.depthTexture.image.height !== B.height) && (B.depthTexture.image.width = B.width, B.depthTexture.image.height = B.height, B.depthTexture.needsUpdate = !0), ie(B.depthTexture, 0);
    const Fe = n.get(B.depthTexture).__webglTexture, ze = He(B);
    if (B.depthTexture.format === fu)
      Re(B) ? d.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Fe, 0, ze) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Fe, 0);
    else if (B.depthTexture.format === Bc)
      Re(B) ? d.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Fe, 0, ze) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Fe, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function ot(G) {
    const B = n.get(G), ce = G.isWebGLCubeRenderTarget === !0;
    if (G.depthTexture && !B.__autoAllocateDepthBuffer) {
      if (ce) throw new Error("target.depthTexture not supported in Cube render targets");
      Ut(B.__webglFramebuffer, G);
    } else if (ce) {
      B.__webglDepthbuffer = [];
      for (let Fe = 0; Fe < 6; Fe++)
        t.bindFramebuffer(i.FRAMEBUFFER, B.__webglFramebuffer[Fe]), B.__webglDepthbuffer[Fe] = i.createRenderbuffer(), Rt(B.__webglDepthbuffer[Fe], G, !1);
    } else
      t.bindFramebuffer(i.FRAMEBUFFER, B.__webglFramebuffer), B.__webglDepthbuffer = i.createRenderbuffer(), Rt(B.__webglDepthbuffer, G, !1);
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function pt(G, B, ce) {
    const Fe = n.get(G);
    B !== void 0 && $e(Fe.__webglFramebuffer, G, G.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), ce !== void 0 && ot(G);
  }
  function J(G) {
    const B = G.texture, ce = n.get(G), Fe = n.get(B);
    G.addEventListener("dispose", W), G.isWebGLMultipleRenderTargets !== !0 && (Fe.__webglTexture === void 0 && (Fe.__webglTexture = i.createTexture()), Fe.__version = B.version, l.memory.textures++);
    const ze = G.isWebGLCubeRenderTarget === !0, Ie = G.isWebGLMultipleRenderTargets === !0, Mt = T(G) || u;
    if (ze) {
      ce.__webglFramebuffer = [];
      for (let it = 0; it < 6; it++)
        if (u && B.mipmaps && B.mipmaps.length > 0) {
          ce.__webglFramebuffer[it] = [];
          for (let mt = 0; mt < B.mipmaps.length; mt++)
            ce.__webglFramebuffer[it][mt] = i.createFramebuffer();
        } else
          ce.__webglFramebuffer[it] = i.createFramebuffer();
    } else {
      if (u && B.mipmaps && B.mipmaps.length > 0) {
        ce.__webglFramebuffer = [];
        for (let it = 0; it < B.mipmaps.length; it++)
          ce.__webglFramebuffer[it] = i.createFramebuffer();
      } else
        ce.__webglFramebuffer = i.createFramebuffer();
      if (Ie)
        if (r.drawBuffers) {
          const it = G.texture;
          for (let mt = 0, Dt = it.length; mt < Dt; mt++) {
            const Ht = n.get(it[mt]);
            Ht.__webglTexture === void 0 && (Ht.__webglTexture = i.createTexture(), l.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (u && G.samples > 0 && Re(G) === !1) {
        const it = Ie ? B : [B];
        ce.__webglMultisampledFramebuffer = i.createFramebuffer(), ce.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, ce.__webglMultisampledFramebuffer);
        for (let mt = 0; mt < it.length; mt++) {
          const Dt = it[mt];
          ce.__webglColorRenderbuffer[mt] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, ce.__webglColorRenderbuffer[mt]);
          const Ht = o.convert(Dt.format, Dt.colorSpace), de = o.convert(Dt.type), nt = N(Dt.internalFormat, Ht, de, Dt.colorSpace, G.isXRRenderTarget === !0), lt = He(G);
          i.renderbufferStorageMultisample(i.RENDERBUFFER, lt, nt, G.width, G.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + mt, i.RENDERBUFFER, ce.__webglColorRenderbuffer[mt]);
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null), G.depthBuffer && (ce.__webglDepthRenderbuffer = i.createRenderbuffer(), Rt(ce.__webglDepthRenderbuffer, G, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (ze) {
      t.bindTexture(i.TEXTURE_CUBE_MAP, Fe.__webglTexture), pe(i.TEXTURE_CUBE_MAP, B, Mt);
      for (let it = 0; it < 6; it++)
        if (u && B.mipmaps && B.mipmaps.length > 0)
          for (let mt = 0; mt < B.mipmaps.length; mt++)
            $e(ce.__webglFramebuffer[it][mt], G, B, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + it, mt);
        else
          $e(ce.__webglFramebuffer[it], G, B, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + it, 0);
      C(B, Mt) && A(i.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Ie) {
      const it = G.texture;
      for (let mt = 0, Dt = it.length; mt < Dt; mt++) {
        const Ht = it[mt], de = n.get(Ht);
        t.bindTexture(i.TEXTURE_2D, de.__webglTexture), pe(i.TEXTURE_2D, Ht, Mt), $e(ce.__webglFramebuffer, G, Ht, i.COLOR_ATTACHMENT0 + mt, i.TEXTURE_2D, 0), C(Ht, Mt) && A(i.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let it = i.TEXTURE_2D;
      if ((G.isWebGL3DRenderTarget || G.isWebGLArrayRenderTarget) && (u ? it = G.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(it, Fe.__webglTexture), pe(it, B, Mt), u && B.mipmaps && B.mipmaps.length > 0)
        for (let mt = 0; mt < B.mipmaps.length; mt++)
          $e(ce.__webglFramebuffer[mt], G, B, i.COLOR_ATTACHMENT0, it, mt);
      else
        $e(ce.__webglFramebuffer, G, B, i.COLOR_ATTACHMENT0, it, 0);
      C(B, Mt) && A(it), t.unbindTexture();
    }
    G.depthBuffer && ot(G);
  }
  function Be(G) {
    const B = T(G) || u, ce = G.isWebGLMultipleRenderTargets === !0 ? G.texture : [G.texture];
    for (let Fe = 0, ze = ce.length; Fe < ze; Fe++) {
      const Ie = ce[Fe];
      if (C(Ie, B)) {
        const Mt = G.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D, it = n.get(Ie).__webglTexture;
        t.bindTexture(Mt, it), A(Mt), t.unbindTexture();
      }
    }
  }
  function Pe(G) {
    if (u && G.samples > 0 && Re(G) === !1) {
      const B = G.isWebGLMultipleRenderTargets ? G.texture : [G.texture], ce = G.width, Fe = G.height;
      let ze = i.COLOR_BUFFER_BIT;
      const Ie = [], Mt = G.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, it = n.get(G), mt = G.isWebGLMultipleRenderTargets === !0;
      if (mt)
        for (let Dt = 0; Dt < B.length; Dt++)
          t.bindFramebuffer(i.FRAMEBUFFER, it.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + Dt, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, it.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + Dt, i.TEXTURE_2D, null, 0);
      t.bindFramebuffer(i.READ_FRAMEBUFFER, it.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, it.__webglFramebuffer);
      for (let Dt = 0; Dt < B.length; Dt++) {
        Ie.push(i.COLOR_ATTACHMENT0 + Dt), G.depthBuffer && Ie.push(Mt);
        const Ht = it.__ignoreDepthValues !== void 0 ? it.__ignoreDepthValues : !1;
        if (Ht === !1 && (G.depthBuffer && (ze |= i.DEPTH_BUFFER_BIT), G.stencilBuffer && (ze |= i.STENCIL_BUFFER_BIT)), mt && i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, it.__webglColorRenderbuffer[Dt]), Ht === !0 && (i.invalidateFramebuffer(i.READ_FRAMEBUFFER, [Mt]), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [Mt])), mt) {
          const de = n.get(B[Dt]).__webglTexture;
          i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, de, 0);
        }
        i.blitFramebuffer(0, 0, ce, Fe, 0, 0, ce, Fe, ze, i.NEAREST), h && i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Ie);
      }
      if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), mt)
        for (let Dt = 0; Dt < B.length; Dt++) {
          t.bindFramebuffer(i.FRAMEBUFFER, it.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + Dt, i.RENDERBUFFER, it.__webglColorRenderbuffer[Dt]);
          const Ht = n.get(B[Dt]).__webglTexture;
          t.bindFramebuffer(i.FRAMEBUFFER, it.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + Dt, i.TEXTURE_2D, Ht, 0);
        }
      t.bindFramebuffer(i.DRAW_FRAMEBUFFER, it.__webglMultisampledFramebuffer);
    }
  }
  function He(G) {
    return Math.min(r.maxSamples, G.samples);
  }
  function Re(G) {
    const B = n.get(G);
    return u && G.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && B.__useRenderToTexture !== !1;
  }
  function _t(G) {
    const B = l.render.frame;
    m.get(G) !== B && (m.set(G, B), G.update());
  }
  function rt(G, B) {
    const ce = G.colorSpace, Fe = G.format, ze = G.type;
    return G.isCompressedTexture === !0 || G.isVideoTexture === !0 || G.format === Zy || ce !== xo && ce !== Vs && (zn.getTransfer(ce) === Yn ? u === !1 ? e.has("EXT_sRGB") === !0 && Fe === is ? (G.format = Zy, G.minFilter = Oi, G.generateMipmaps = !1) : B = BE.sRGBToLinear(B) : (Fe !== is || ze !== vo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ce)), B;
  }
  this.allocateTextureUnit = K, this.resetTextureUnits = ye, this.setTexture2D = ie, this.setTexture2DArray = Ee, this.setTexture3D = Q, this.setTextureCube = se, this.rebindTextures = pt, this.setupRenderTarget = J, this.updateRenderTargetMipmap = Be, this.updateMultisampleRenderTarget = Pe, this.setupDepthRenderbuffer = ot, this.setupFrameBufferTexture = $e, this.useMultisampledRTT = Re;
}
function $P(i, e, t) {
  const n = t.isWebGL2;
  function r(o, l = Vs) {
    let u;
    const d = zn.getTransfer(l);
    if (o === vo) return i.UNSIGNED_BYTE;
    if (o === CE) return i.UNSIGNED_SHORT_4_4_4_4;
    if (o === PE) return i.UNSIGNED_SHORT_5_5_5_1;
    if (o === yP) return i.BYTE;
    if (o === xP) return i.SHORT;
    if (o === f0) return i.UNSIGNED_SHORT;
    if (o === RE) return i.INT;
    if (o === $o) return i.UNSIGNED_INT;
    if (o === Va) return i.FLOAT;
    if (o === Qd)
      return n ? i.HALF_FLOAT : (u = e.get("OES_texture_half_float"), u !== null ? u.HALF_FLOAT_OES : null);
    if (o === _P) return i.ALPHA;
    if (o === is) return i.RGBA;
    if (o === SP) return i.LUMINANCE;
    if (o === MP) return i.LUMINANCE_ALPHA;
    if (o === fu) return i.DEPTH_COMPONENT;
    if (o === Bc) return i.DEPTH_STENCIL;
    if (o === Zy)
      return u = e.get("EXT_sRGB"), u !== null ? u.SRGB_ALPHA_EXT : null;
    if (o === EP) return i.RED;
    if (o === LE) return i.RED_INTEGER;
    if (o === bP) return i.RG;
    if (o === DE) return i.RG_INTEGER;
    if (o === NE) return i.RGBA_INTEGER;
    if (o === Iy || o === Fy || o === zy || o === By)
      if (d === Yn)
        if (u = e.get("WEBGL_compressed_texture_s3tc_srgb"), u !== null) {
          if (o === Iy) return u.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (o === Fy) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (o === zy) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (o === By) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (u = e.get("WEBGL_compressed_texture_s3tc"), u !== null) {
        if (o === Iy) return u.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === Fy) return u.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === zy) return u.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === By) return u.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (o === EM || o === bM || o === TM || o === wM)
      if (u = e.get("WEBGL_compressed_texture_pvrtc"), u !== null) {
        if (o === EM) return u.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === bM) return u.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === TM) return u.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === wM) return u.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (o === UE)
      return u = e.get("WEBGL_compressed_texture_etc1"), u !== null ? u.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (o === AM || o === RM)
      if (u = e.get("WEBGL_compressed_texture_etc"), u !== null) {
        if (o === AM) return d === Yn ? u.COMPRESSED_SRGB8_ETC2 : u.COMPRESSED_RGB8_ETC2;
        if (o === RM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : u.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (o === CM || o === PM || o === LM || o === DM || o === NM || o === UM || o === OM || o === IM || o === FM || o === zM || o === BM || o === VM || o === HM || o === kM)
      if (u = e.get("WEBGL_compressed_texture_astc"), u !== null) {
        if (o === CM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : u.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (o === PM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : u.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (o === LM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : u.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (o === DM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : u.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (o === NM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : u.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (o === UM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : u.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (o === OM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : u.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (o === IM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : u.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (o === FM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : u.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (o === zM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : u.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (o === BM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : u.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (o === VM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : u.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (o === HM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : u.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (o === kM) return d === Yn ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : u.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (o === Vy || o === GM || o === WM)
      if (u = e.get("EXT_texture_compression_bptc"), u !== null) {
        if (o === Vy) return d === Yn ? u.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : u.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (o === GM) return u.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (o === WM) return u.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (o === TP || o === XM || o === jM || o === YM)
      if (u = e.get("EXT_texture_compression_rgtc"), u !== null) {
        if (o === Vy) return u.COMPRESSED_RED_RGTC1_EXT;
        if (o === XM) return u.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (o === jM) return u.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (o === YM) return u.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return o === cu ? n ? i.UNSIGNED_INT_24_8 : (u = e.get("WEBGL_depth_texture"), u !== null ? u.UNSIGNED_INT_24_8_WEBGL : null) : i[o] !== void 0 ? i[o] : null;
  }
  return { convert: r };
}
class eL extends Ii {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Wd extends Dn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const MH = { type: "move" };
class RS {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Wd(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Wd(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new j(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new j()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Wd(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new j(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new j()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let r = null, o = null, l = null;
    const u = this._targetRay, d = this._grip, h = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (h && e.hand) {
        l = !0;
        for (const w of e.hand.values()) {
          const T = t.getJointPose(w, n), M = this._getHandJoint(h, w);
          T !== null && (M.matrix.fromArray(T.transform.matrix), M.matrix.decompose(M.position, M.rotation, M.scale), M.matrixWorldNeedsUpdate = !0, M.jointRadius = T.radius), M.visible = T !== null;
        }
        const m = h.joints["index-finger-tip"], g = h.joints["thumb-tip"], y = m.position.distanceTo(g.position), _ = 0.02, E = 5e-3;
        h.inputState.pinching && y > _ + E ? (h.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !h.inputState.pinching && y <= _ - E && (h.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        d !== null && e.gripSpace && (o = t.getPose(e.gripSpace, n), o !== null && (d.matrix.fromArray(o.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), d.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (d.hasLinearVelocity = !0, d.linearVelocity.copy(o.linearVelocity)) : d.hasLinearVelocity = !1, o.angularVelocity ? (d.hasAngularVelocity = !0, d.angularVelocity.copy(o.angularVelocity)) : d.hasAngularVelocity = !1));
      u !== null && (r = t.getPose(e.targetRaySpace, n), r === null && o !== null && (r = o), r !== null && (u.matrix.fromArray(r.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(r.linearVelocity)) : u.hasLinearVelocity = !1, r.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(r.angularVelocity)) : u.hasAngularVelocity = !1, this.dispatchEvent(MH)));
    }
    return u !== null && (u.visible = r !== null), d !== null && (d.visible = o !== null), h !== null && (h.visible = l !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Wd();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class EH extends ul {
  constructor(e, t) {
    super();
    const n = this;
    let r = null, o = 1, l = null, u = "local-floor", d = 1, h = null, m = null, g = null, y = null, _ = null, E = null;
    const w = t.getContextAttributes();
    let T = null, M = null;
    const C = [], A = [], N = new Oe();
    let z = null;
    const I = new Ii();
    I.layers.enable(1), I.viewport = new Bn();
    const V = new Ii();
    V.layers.enable(2), V.viewport = new Bn();
    const W = [I, V], U = new eL();
    U.layers.enable(1), U.layers.enable(2);
    let O = null, q = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(pe) {
      let Ae = C[pe];
      return Ae === void 0 && (Ae = new RS(), C[pe] = Ae), Ae.getTargetRaySpace();
    }, this.getControllerGrip = function(pe) {
      let Ae = C[pe];
      return Ae === void 0 && (Ae = new RS(), C[pe] = Ae), Ae.getGripSpace();
    }, this.getHand = function(pe) {
      let Ae = C[pe];
      return Ae === void 0 && (Ae = new RS(), C[pe] = Ae), Ae.getHandSpace();
    };
    function le(pe) {
      const Ae = A.indexOf(pe.inputSource);
      if (Ae === -1)
        return;
      const qe = C[Ae];
      qe !== void 0 && (qe.update(pe.inputSource, pe.frame, h || l), qe.dispatchEvent({ type: pe.type, data: pe.inputSource }));
    }
    function ye() {
      r.removeEventListener("select", le), r.removeEventListener("selectstart", le), r.removeEventListener("selectend", le), r.removeEventListener("squeeze", le), r.removeEventListener("squeezestart", le), r.removeEventListener("squeezeend", le), r.removeEventListener("end", ye), r.removeEventListener("inputsourceschange", K);
      for (let pe = 0; pe < C.length; pe++) {
        const Ae = A[pe];
        Ae !== null && (A[pe] = null, C[pe].disconnect(Ae));
      }
      O = null, q = null, e.setRenderTarget(T), _ = null, y = null, g = null, r = null, M = null, Le.stop(), n.isPresenting = !1, e.setPixelRatio(z), e.setSize(N.width, N.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(pe) {
      o = pe, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(pe) {
      u = pe, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return h || l;
    }, this.setReferenceSpace = function(pe) {
      h = pe;
    }, this.getBaseLayer = function() {
      return y !== null ? y : _;
    }, this.getBinding = function() {
      return g;
    }, this.getFrame = function() {
      return E;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(pe) {
      if (r = pe, r !== null) {
        if (T = e.getRenderTarget(), r.addEventListener("select", le), r.addEventListener("selectstart", le), r.addEventListener("selectend", le), r.addEventListener("squeeze", le), r.addEventListener("squeezestart", le), r.addEventListener("squeezeend", le), r.addEventListener("end", ye), r.addEventListener("inputsourceschange", K), w.xrCompatible !== !0 && await t.makeXRCompatible(), z = e.getPixelRatio(), e.getSize(N), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const Ae = {
            antialias: r.renderState.layers === void 0 ? w.antialias : !0,
            alpha: !0,
            depth: w.depth,
            stencil: w.stencil,
            framebufferScaleFactor: o
          };
          _ = new XRWebGLLayer(r, t, Ae), r.updateRenderState({ baseLayer: _ }), e.setPixelRatio(1), e.setSize(_.framebufferWidth, _.framebufferHeight, !1), M = new ka(
            _.framebufferWidth,
            _.framebufferHeight,
            {
              format: is,
              type: vo,
              colorSpace: e.outputColorSpace,
              stencilBuffer: w.stencil
            }
          );
        } else {
          let Ae = null, qe = null, je = null;
          w.depth && (je = w.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, Ae = w.stencil ? Bc : fu, qe = w.stencil ? cu : $o);
          const $e = {
            colorFormat: t.RGBA8,
            depthFormat: je,
            scaleFactor: o
          };
          g = new XRWebGLBinding(r, t), y = g.createProjectionLayer($e), r.updateRenderState({ layers: [y] }), e.setPixelRatio(1), e.setSize(y.textureWidth, y.textureHeight, !1), M = new ka(
            y.textureWidth,
            y.textureHeight,
            {
              format: is,
              type: vo,
              depthTexture: new WE(y.textureWidth, y.textureHeight, qe, void 0, void 0, void 0, void 0, void 0, void 0, Ae),
              stencilBuffer: w.stencil,
              colorSpace: e.outputColorSpace,
              samples: w.antialias ? 4 : 0
            }
          );
          const Rt = e.properties.get(M);
          Rt.__ignoreDepthValues = y.ignoreDepthValues;
        }
        M.isXRRenderTarget = !0, this.setFoveation(d), h = null, l = await r.requestReferenceSpace(u), Le.setContext(r), Le.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    };
    function K(pe) {
      for (let Ae = 0; Ae < pe.removed.length; Ae++) {
        const qe = pe.removed[Ae], je = A.indexOf(qe);
        je >= 0 && (A[je] = null, C[je].disconnect(qe));
      }
      for (let Ae = 0; Ae < pe.added.length; Ae++) {
        const qe = pe.added[Ae];
        let je = A.indexOf(qe);
        if (je === -1) {
          for (let Rt = 0; Rt < C.length; Rt++)
            if (Rt >= A.length) {
              A.push(qe), je = Rt;
              break;
            } else if (A[Rt] === null) {
              A[Rt] = qe, je = Rt;
              break;
            }
          if (je === -1) break;
        }
        const $e = C[je];
        $e && $e.connect(qe);
      }
    }
    const oe = new j(), ie = new j();
    function Ee(pe, Ae, qe) {
      oe.setFromMatrixPosition(Ae.matrixWorld), ie.setFromMatrixPosition(qe.matrixWorld);
      const je = oe.distanceTo(ie), $e = Ae.projectionMatrix.elements, Rt = qe.projectionMatrix.elements, Ut = $e[14] / ($e[10] - 1), ot = $e[14] / ($e[10] + 1), pt = ($e[9] + 1) / $e[5], J = ($e[9] - 1) / $e[5], Be = ($e[8] - 1) / $e[0], Pe = (Rt[8] + 1) / Rt[0], He = Ut * Be, Re = Ut * Pe, _t = je / (-Be + Pe), rt = _t * -Be;
      Ae.matrixWorld.decompose(pe.position, pe.quaternion, pe.scale), pe.translateX(rt), pe.translateZ(_t), pe.matrixWorld.compose(pe.position, pe.quaternion, pe.scale), pe.matrixWorldInverse.copy(pe.matrixWorld).invert();
      const G = Ut + _t, B = ot + _t, ce = He - rt, Fe = Re + (je - rt), ze = pt * ot / B * G, Ie = J * ot / B * G;
      pe.projectionMatrix.makePerspective(ce, Fe, ze, Ie, G, B), pe.projectionMatrixInverse.copy(pe.projectionMatrix).invert();
    }
    function Q(pe, Ae) {
      Ae === null ? pe.matrixWorld.copy(pe.matrix) : pe.matrixWorld.multiplyMatrices(Ae.matrixWorld, pe.matrix), pe.matrixWorldInverse.copy(pe.matrixWorld).invert();
    }
    this.updateCamera = function(pe) {
      if (r === null) return;
      U.near = V.near = I.near = pe.near, U.far = V.far = I.far = pe.far, (O !== U.near || q !== U.far) && (r.updateRenderState({
        depthNear: U.near,
        depthFar: U.far
      }), O = U.near, q = U.far);
      const Ae = pe.parent, qe = U.cameras;
      Q(U, Ae);
      for (let je = 0; je < qe.length; je++)
        Q(qe[je], Ae);
      qe.length === 2 ? Ee(U, I, V) : U.projectionMatrix.copy(I.projectionMatrix), se(pe, U, Ae);
    };
    function se(pe, Ae, qe) {
      qe === null ? pe.matrix.copy(Ae.matrixWorld) : (pe.matrix.copy(qe.matrixWorld), pe.matrix.invert(), pe.matrix.multiply(Ae.matrixWorld)), pe.matrix.decompose(pe.position, pe.quaternion, pe.scale), pe.updateMatrixWorld(!0), pe.projectionMatrix.copy(Ae.projectionMatrix), pe.projectionMatrixInverse.copy(Ae.projectionMatrixInverse), pe.isPerspectiveCamera && (pe.fov = eh * 2 * Math.atan(1 / pe.projectionMatrix.elements[5]), pe.zoom = 1);
    }
    this.getCamera = function() {
      return U;
    }, this.getFoveation = function() {
      if (!(y === null && _ === null))
        return d;
    }, this.setFoveation = function(pe) {
      d = pe, y !== null && (y.fixedFoveation = pe), _ !== null && _.fixedFoveation !== void 0 && (_.fixedFoveation = pe);
    };
    let re = null;
    function ue(pe, Ae) {
      if (m = Ae.getViewerPose(h || l), E = Ae, m !== null) {
        const qe = m.views;
        _ !== null && (e.setRenderTargetFramebuffer(M, _.framebuffer), e.setRenderTarget(M));
        let je = !1;
        qe.length !== U.cameras.length && (U.cameras.length = 0, je = !0);
        for (let $e = 0; $e < qe.length; $e++) {
          const Rt = qe[$e];
          let Ut = null;
          if (_ !== null)
            Ut = _.getViewport(Rt);
          else {
            const pt = g.getViewSubImage(y, Rt);
            Ut = pt.viewport, $e === 0 && (e.setRenderTargetTextures(
              M,
              pt.colorTexture,
              y.ignoreDepthValues ? void 0 : pt.depthStencilTexture
            ), e.setRenderTarget(M));
          }
          let ot = W[$e];
          ot === void 0 && (ot = new Ii(), ot.layers.enable($e), ot.viewport = new Bn(), W[$e] = ot), ot.matrix.fromArray(Rt.transform.matrix), ot.matrix.decompose(ot.position, ot.quaternion, ot.scale), ot.projectionMatrix.fromArray(Rt.projectionMatrix), ot.projectionMatrixInverse.copy(ot.projectionMatrix).invert(), ot.viewport.set(Ut.x, Ut.y, Ut.width, Ut.height), $e === 0 && (U.matrix.copy(ot.matrix), U.matrix.decompose(U.position, U.quaternion, U.scale)), je === !0 && U.cameras.push(ot);
        }
      }
      for (let qe = 0; qe < C.length; qe++) {
        const je = A[qe], $e = C[qe];
        je !== null && $e !== void 0 && $e.update(je, Ae, h || l);
      }
      re && re(pe, Ae), Ae.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: Ae }), E = null;
    }
    const Le = new YP();
    Le.setAnimationLoop(ue), this.setAnimationLoop = function(pe) {
      re = pe;
    }, this.dispose = function() {
    };
  }
}
function bH(i, e) {
  function t(T, M) {
    T.matrixAutoUpdate === !0 && T.updateMatrix(), M.value.copy(T.matrix);
  }
  function n(T, M) {
    M.color.getRGB(T.fogColor.value, GP(i)), M.isFog ? (T.fogNear.value = M.near, T.fogFar.value = M.far) : M.isFogExp2 && (T.fogDensity.value = M.density);
  }
  function r(T, M, C, A, N) {
    M.isMeshBasicMaterial || M.isMeshLambertMaterial ? o(T, M) : M.isMeshToonMaterial ? (o(T, M), g(T, M)) : M.isMeshPhongMaterial ? (o(T, M), m(T, M)) : M.isMeshStandardMaterial ? (o(T, M), y(T, M), M.isMeshPhysicalMaterial && _(T, M, N)) : M.isMeshMatcapMaterial ? (o(T, M), E(T, M)) : M.isMeshDepthMaterial ? o(T, M) : M.isMeshDistanceMaterial ? (o(T, M), w(T, M)) : M.isMeshNormalMaterial ? o(T, M) : M.isLineBasicMaterial ? (l(T, M), M.isLineDashedMaterial && u(T, M)) : M.isPointsMaterial ? d(T, M, C, A) : M.isSpriteMaterial ? h(T, M) : M.isShadowMaterial ? (T.color.value.copy(M.color), T.opacity.value = M.opacity) : M.isShaderMaterial && (M.uniformsNeedUpdate = !1);
  }
  function o(T, M) {
    T.opacity.value = M.opacity, M.color && T.diffuse.value.copy(M.color), M.emissive && T.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity), M.map && (T.map.value = M.map, t(M.map, T.mapTransform)), M.alphaMap && (T.alphaMap.value = M.alphaMap, t(M.alphaMap, T.alphaMapTransform)), M.bumpMap && (T.bumpMap.value = M.bumpMap, t(M.bumpMap, T.bumpMapTransform), T.bumpScale.value = M.bumpScale, M.side === ss && (T.bumpScale.value *= -1)), M.normalMap && (T.normalMap.value = M.normalMap, t(M.normalMap, T.normalMapTransform), T.normalScale.value.copy(M.normalScale), M.side === ss && T.normalScale.value.negate()), M.displacementMap && (T.displacementMap.value = M.displacementMap, t(M.displacementMap, T.displacementMapTransform), T.displacementScale.value = M.displacementScale, T.displacementBias.value = M.displacementBias), M.emissiveMap && (T.emissiveMap.value = M.emissiveMap, t(M.emissiveMap, T.emissiveMapTransform)), M.specularMap && (T.specularMap.value = M.specularMap, t(M.specularMap, T.specularMapTransform)), M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
    const C = e.get(M).envMap;
    if (C && (T.envMap.value = C, T.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1, T.reflectivity.value = M.reflectivity, T.ior.value = M.ior, T.refractionRatio.value = M.refractionRatio), M.lightMap) {
      T.lightMap.value = M.lightMap;
      const A = i._useLegacyLights === !0 ? Math.PI : 1;
      T.lightMapIntensity.value = M.lightMapIntensity * A, t(M.lightMap, T.lightMapTransform);
    }
    M.aoMap && (T.aoMap.value = M.aoMap, T.aoMapIntensity.value = M.aoMapIntensity, t(M.aoMap, T.aoMapTransform));
  }
  function l(T, M) {
    T.diffuse.value.copy(M.color), T.opacity.value = M.opacity, M.map && (T.map.value = M.map, t(M.map, T.mapTransform));
  }
  function u(T, M) {
    T.dashSize.value = M.dashSize, T.totalSize.value = M.dashSize + M.gapSize, T.scale.value = M.scale;
  }
  function d(T, M, C, A) {
    T.diffuse.value.copy(M.color), T.opacity.value = M.opacity, T.size.value = M.size * C, T.scale.value = A * 0.5, M.map && (T.map.value = M.map, t(M.map, T.uvTransform)), M.alphaMap && (T.alphaMap.value = M.alphaMap, t(M.alphaMap, T.alphaMapTransform)), M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
  }
  function h(T, M) {
    T.diffuse.value.copy(M.color), T.opacity.value = M.opacity, T.rotation.value = M.rotation, M.map && (T.map.value = M.map, t(M.map, T.mapTransform)), M.alphaMap && (T.alphaMap.value = M.alphaMap, t(M.alphaMap, T.alphaMapTransform)), M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
  }
  function m(T, M) {
    T.specular.value.copy(M.specular), T.shininess.value = Math.max(M.shininess, 1e-4);
  }
  function g(T, M) {
    M.gradientMap && (T.gradientMap.value = M.gradientMap);
  }
  function y(T, M) {
    T.metalness.value = M.metalness, M.metalnessMap && (T.metalnessMap.value = M.metalnessMap, t(M.metalnessMap, T.metalnessMapTransform)), T.roughness.value = M.roughness, M.roughnessMap && (T.roughnessMap.value = M.roughnessMap, t(M.roughnessMap, T.roughnessMapTransform)), e.get(M).envMap && (T.envMapIntensity.value = M.envMapIntensity);
  }
  function _(T, M, C) {
    T.ior.value = M.ior, M.sheen > 0 && (T.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen), T.sheenRoughness.value = M.sheenRoughness, M.sheenColorMap && (T.sheenColorMap.value = M.sheenColorMap, t(M.sheenColorMap, T.sheenColorMapTransform)), M.sheenRoughnessMap && (T.sheenRoughnessMap.value = M.sheenRoughnessMap, t(M.sheenRoughnessMap, T.sheenRoughnessMapTransform))), M.clearcoat > 0 && (T.clearcoat.value = M.clearcoat, T.clearcoatRoughness.value = M.clearcoatRoughness, M.clearcoatMap && (T.clearcoatMap.value = M.clearcoatMap, t(M.clearcoatMap, T.clearcoatMapTransform)), M.clearcoatRoughnessMap && (T.clearcoatRoughnessMap.value = M.clearcoatRoughnessMap, t(M.clearcoatRoughnessMap, T.clearcoatRoughnessMapTransform)), M.clearcoatNormalMap && (T.clearcoatNormalMap.value = M.clearcoatNormalMap, t(M.clearcoatNormalMap, T.clearcoatNormalMapTransform), T.clearcoatNormalScale.value.copy(M.clearcoatNormalScale), M.side === ss && T.clearcoatNormalScale.value.negate())), M.iridescence > 0 && (T.iridescence.value = M.iridescence, T.iridescenceIOR.value = M.iridescenceIOR, T.iridescenceThicknessMinimum.value = M.iridescenceThicknessRange[0], T.iridescenceThicknessMaximum.value = M.iridescenceThicknessRange[1], M.iridescenceMap && (T.iridescenceMap.value = M.iridescenceMap, t(M.iridescenceMap, T.iridescenceMapTransform)), M.iridescenceThicknessMap && (T.iridescenceThicknessMap.value = M.iridescenceThicknessMap, t(M.iridescenceThicknessMap, T.iridescenceThicknessMapTransform))), M.transmission > 0 && (T.transmission.value = M.transmission, T.transmissionSamplerMap.value = C.texture, T.transmissionSamplerSize.value.set(C.width, C.height), M.transmissionMap && (T.transmissionMap.value = M.transmissionMap, t(M.transmissionMap, T.transmissionMapTransform)), T.thickness.value = M.thickness, M.thicknessMap && (T.thicknessMap.value = M.thicknessMap, t(M.thicknessMap, T.thicknessMapTransform)), T.attenuationDistance.value = M.attenuationDistance, T.attenuationColor.value.copy(M.attenuationColor)), M.anisotropy > 0 && (T.anisotropyVector.value.set(M.anisotropy * Math.cos(M.anisotropyRotation), M.anisotropy * Math.sin(M.anisotropyRotation)), M.anisotropyMap && (T.anisotropyMap.value = M.anisotropyMap, t(M.anisotropyMap, T.anisotropyMapTransform))), T.specularIntensity.value = M.specularIntensity, T.specularColor.value.copy(M.specularColor), M.specularColorMap && (T.specularColorMap.value = M.specularColorMap, t(M.specularColorMap, T.specularColorMapTransform)), M.specularIntensityMap && (T.specularIntensityMap.value = M.specularIntensityMap, t(M.specularIntensityMap, T.specularIntensityMapTransform));
  }
  function E(T, M) {
    M.matcap && (T.matcap.value = M.matcap);
  }
  function w(T, M) {
    const C = e.get(M).light;
    T.referencePosition.value.setFromMatrixPosition(C.matrixWorld), T.nearDistance.value = C.shadow.camera.near, T.farDistance.value = C.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: r
  };
}
function TH(i, e, t, n) {
  let r = {}, o = {}, l = [];
  const u = t.isWebGL2 ? i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function d(C, A) {
    const N = A.program;
    n.uniformBlockBinding(C, N);
  }
  function h(C, A) {
    let N = r[C.id];
    N === void 0 && (E(C), N = m(C), r[C.id] = N, C.addEventListener("dispose", T));
    const z = A.program;
    n.updateUBOMapping(C, z);
    const I = e.render.frame;
    o[C.id] !== I && (y(C), o[C.id] = I);
  }
  function m(C) {
    const A = g();
    C.__bindingPointIndex = A;
    const N = i.createBuffer(), z = C.__size, I = C.usage;
    return i.bindBuffer(i.UNIFORM_BUFFER, N), i.bufferData(i.UNIFORM_BUFFER, z, I), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, A, N), N;
  }
  function g() {
    for (let C = 0; C < u; C++)
      if (l.indexOf(C) === -1)
        return l.push(C), C;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function y(C) {
    const A = r[C.id], N = C.uniforms, z = C.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, A);
    for (let I = 0, V = N.length; I < V; I++) {
      const W = Array.isArray(N[I]) ? N[I] : [N[I]];
      for (let U = 0, O = W.length; U < O; U++) {
        const q = W[U];
        if (_(q, I, U, z) === !0) {
          const le = q.__offset, ye = Array.isArray(q.value) ? q.value : [q.value];
          let K = 0;
          for (let oe = 0; oe < ye.length; oe++) {
            const ie = ye[oe], Ee = w(ie);
            typeof ie == "number" || typeof ie == "boolean" ? (q.__data[0] = ie, i.bufferSubData(i.UNIFORM_BUFFER, le + K, q.__data)) : ie.isMatrix3 ? (q.__data[0] = ie.elements[0], q.__data[1] = ie.elements[1], q.__data[2] = ie.elements[2], q.__data[3] = 0, q.__data[4] = ie.elements[3], q.__data[5] = ie.elements[4], q.__data[6] = ie.elements[5], q.__data[7] = 0, q.__data[8] = ie.elements[6], q.__data[9] = ie.elements[7], q.__data[10] = ie.elements[8], q.__data[11] = 0) : (ie.toArray(q.__data, K), K += Ee.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          i.bufferSubData(i.UNIFORM_BUFFER, le, q.__data);
        }
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function _(C, A, N, z) {
    const I = C.value, V = A + "_" + N;
    if (z[V] === void 0)
      return typeof I == "number" || typeof I == "boolean" ? z[V] = I : z[V] = I.clone(), !0;
    {
      const W = z[V];
      if (typeof I == "number" || typeof I == "boolean") {
        if (W !== I)
          return z[V] = I, !0;
      } else if (W.equals(I) === !1)
        return W.copy(I), !0;
    }
    return !1;
  }
  function E(C) {
    const A = C.uniforms;
    let N = 0;
    const z = 16;
    for (let V = 0, W = A.length; V < W; V++) {
      const U = Array.isArray(A[V]) ? A[V] : [A[V]];
      for (let O = 0, q = U.length; O < q; O++) {
        const le = U[O], ye = Array.isArray(le.value) ? le.value : [le.value];
        for (let K = 0, oe = ye.length; K < oe; K++) {
          const ie = ye[K], Ee = w(ie), Q = N % z;
          Q !== 0 && z - Q < Ee.boundary && (N += z - Q), le.__data = new Float32Array(Ee.storage / Float32Array.BYTES_PER_ELEMENT), le.__offset = N, N += Ee.storage;
        }
      }
    }
    const I = N % z;
    return I > 0 && (N += z - I), C.__size = N, C.__cache = {}, this;
  }
  function w(C) {
    const A = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof C == "number" || typeof C == "boolean" ? (A.boundary = 4, A.storage = 4) : C.isVector2 ? (A.boundary = 8, A.storage = 8) : C.isVector3 || C.isColor ? (A.boundary = 16, A.storage = 12) : C.isVector4 ? (A.boundary = 16, A.storage = 16) : C.isMatrix3 ? (A.boundary = 48, A.storage = 48) : C.isMatrix4 ? (A.boundary = 64, A.storage = 64) : C.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", C), A;
  }
  function T(C) {
    const A = C.target;
    A.removeEventListener("dispose", T);
    const N = l.indexOf(A.__bindingPointIndex);
    l.splice(N, 1), i.deleteBuffer(r[A.id]), delete r[A.id], delete o[A.id];
  }
  function M() {
    for (const C in r)
      i.deleteBuffer(r[C]);
    l = [], r = {}, o = {};
  }
  return {
    bind: d,
    update: h,
    dispose: M
  };
}
class YE {
  constructor(e = {}) {
    const {
      canvas: t = VP(),
      context: n = null,
      depth: r = !0,
      stencil: o = !0,
      alpha: l = !1,
      antialias: u = !1,
      premultipliedAlpha: d = !0,
      preserveDrawingBuffer: h = !1,
      powerPreference: m = "default",
      failIfMajorPerformanceCaveat: g = !1
    } = e;
    this.isWebGLRenderer = !0;
    let y;
    n !== null ? y = n.getContextAttributes().alpha : y = l;
    const _ = new Uint32Array(4), E = new Int32Array(4);
    let w = null, T = null;
    const M = [], C = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = nr, this._useLegacyLights = !1, this.toneMapping = mo, this.toneMappingExposure = 1;
    const A = this;
    let N = !1, z = 0, I = 0, V = null, W = -1, U = null;
    const O = new Bn(), q = new Bn();
    let le = null;
    const ye = new Tt(0);
    let K = 0, oe = t.width, ie = t.height, Ee = 1, Q = null, se = null;
    const re = new Bn(0, 0, oe, ie), ue = new Bn(0, 0, oe, ie);
    let Le = !1;
    const pe = new Om();
    let Ae = !1, qe = !1, je = null;
    const $e = new $t(), Rt = new Oe(), Ut = new j(), ot = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function pt() {
      return V === null ? Ee : 1;
    }
    let J = n;
    function Be(k, ne) {
      for (let ge = 0; ge < k.length; ge++) {
        const ve = k[ge], me = t.getContext(ve, ne);
        if (me !== null) return me;
      }
      return null;
    }
    try {
      const k = {
        alpha: !0,
        depth: r,
        stencil: o,
        antialias: u,
        premultipliedAlpha: d,
        preserveDrawingBuffer: h,
        powerPreference: m,
        failIfMajorPerformanceCaveat: g
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${l0}`), t.addEventListener("webglcontextlost", Te, !1), t.addEventListener("webglcontextrestored", ee, !1), t.addEventListener("webglcontextcreationerror", Ke, !1), J === null) {
        const ne = ["webgl2", "webgl", "experimental-webgl"];
        if (A.isWebGL1Renderer === !0 && ne.shift(), J = Be(ne, k), J === null)
          throw Be(ne) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && J instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), J.getShaderPrecisionFormat === void 0 && (J.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (k) {
      throw console.error("THREE.WebGLRenderer: " + k.message), k;
    }
    let Pe, He, Re, _t, rt, G, B, ce, Fe, ze, Ie, Mt, it, mt, Dt, Ht, de, nt, lt, Xe, dt, at, Y, he;
    function Ze() {
      Pe = new BB(J), He = new NB(J, Pe, e), Pe.init(He), at = new $P(J, Pe, He), Re = new _H(J, Pe, He), _t = new kB(J), rt = new lH(), G = new SH(J, Pe, Re, rt, He, at, _t), B = new OB(A), ce = new zB(A), Fe = new KI(J, He), Y = new LB(J, Pe, Fe, He), ze = new VB(J, Fe, _t, Y), Ie = new jB(J, ze, Fe, _t), lt = new XB(J, He, G), Ht = new UB(rt), Mt = new oH(A, B, ce, Pe, He, Y, Ht), it = new bH(A, rt), mt = new cH(), Dt = new vH(Pe, He), nt = new PB(A, B, ce, Re, Ie, y, d), de = new xH(A, Ie, He), he = new TH(J, _t, He, Re), Xe = new DB(J, Pe, _t, He), dt = new HB(J, Pe, _t, He), _t.programs = Mt.programs, A.capabilities = He, A.extensions = Pe, A.properties = rt, A.renderLists = mt, A.shadowMap = de, A.state = Re, A.info = _t;
    }
    Ze();
    const Ve = new EH(A, J);
    this.xr = Ve, this.getContext = function() {
      return J;
    }, this.getContextAttributes = function() {
      return J.getContextAttributes();
    }, this.forceContextLoss = function() {
      const k = Pe.get("WEBGL_lose_context");
      k && k.loseContext();
    }, this.forceContextRestore = function() {
      const k = Pe.get("WEBGL_lose_context");
      k && k.restoreContext();
    }, this.getPixelRatio = function() {
      return Ee;
    }, this.setPixelRatio = function(k) {
      k !== void 0 && (Ee = k, this.setSize(oe, ie, !1));
    }, this.getSize = function(k) {
      return k.set(oe, ie);
    }, this.setSize = function(k, ne, ge = !0) {
      if (Ve.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      oe = k, ie = ne, t.width = Math.floor(k * Ee), t.height = Math.floor(ne * Ee), ge === !0 && (t.style.width = k + "px", t.style.height = ne + "px"), this.setViewport(0, 0, k, ne);
    }, this.getDrawingBufferSize = function(k) {
      return k.set(oe * Ee, ie * Ee).floor();
    }, this.setDrawingBufferSize = function(k, ne, ge) {
      oe = k, ie = ne, Ee = ge, t.width = Math.floor(k * ge), t.height = Math.floor(ne * ge), this.setViewport(0, 0, k, ne);
    }, this.getCurrentViewport = function(k) {
      return k.copy(O);
    }, this.getViewport = function(k) {
      return k.copy(re);
    }, this.setViewport = function(k, ne, ge, ve) {
      k.isVector4 ? re.set(k.x, k.y, k.z, k.w) : re.set(k, ne, ge, ve), Re.viewport(O.copy(re).multiplyScalar(Ee).floor());
    }, this.getScissor = function(k) {
      return k.copy(ue);
    }, this.setScissor = function(k, ne, ge, ve) {
      k.isVector4 ? ue.set(k.x, k.y, k.z, k.w) : ue.set(k, ne, ge, ve), Re.scissor(q.copy(ue).multiplyScalar(Ee).floor());
    }, this.getScissorTest = function() {
      return Le;
    }, this.setScissorTest = function(k) {
      Re.setScissorTest(Le = k);
    }, this.setOpaqueSort = function(k) {
      Q = k;
    }, this.setTransparentSort = function(k) {
      se = k;
    }, this.getClearColor = function(k) {
      return k.copy(nt.getClearColor());
    }, this.setClearColor = function() {
      nt.setClearColor.apply(nt, arguments);
    }, this.getClearAlpha = function() {
      return nt.getClearAlpha();
    }, this.setClearAlpha = function() {
      nt.setClearAlpha.apply(nt, arguments);
    }, this.clear = function(k = !0, ne = !0, ge = !0) {
      let ve = 0;
      if (k) {
        let me = !1;
        if (V !== null) {
          const Qe = V.texture.format;
          me = Qe === NE || Qe === DE || Qe === LE;
        }
        if (me) {
          const Qe = V.texture.type, wt = Qe === vo || Qe === $o || Qe === f0 || Qe === cu || Qe === CE || Qe === PE, Ct = nt.getClearColor(), At = nt.getClearAlpha(), Wt = Ct.r, Xt = Ct.g, Zt = Ct.b;
          wt ? (_[0] = Wt, _[1] = Xt, _[2] = Zt, _[3] = At, J.clearBufferuiv(J.COLOR, 0, _)) : (E[0] = Wt, E[1] = Xt, E[2] = Zt, E[3] = At, J.clearBufferiv(J.COLOR, 0, E));
        } else
          ve |= J.COLOR_BUFFER_BIT;
      }
      ne && (ve |= J.DEPTH_BUFFER_BIT), ge && (ve |= J.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), J.clear(ve);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Te, !1), t.removeEventListener("webglcontextrestored", ee, !1), t.removeEventListener("webglcontextcreationerror", Ke, !1), mt.dispose(), Dt.dispose(), rt.dispose(), B.dispose(), ce.dispose(), Ie.dispose(), Y.dispose(), he.dispose(), Mt.dispose(), Ve.dispose(), Ve.removeEventListener("sessionstart", bn), Ve.removeEventListener("sessionend", Jt), je && (je.dispose(), je = null), di.stop();
    };
    function Te(k) {
      k.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), N = !0;
    }
    function ee() {
      console.log("THREE.WebGLRenderer: Context Restored."), N = !1;
      const k = _t.autoReset, ne = de.enabled, ge = de.autoUpdate, ve = de.needsUpdate, me = de.type;
      Ze(), _t.autoReset = k, de.enabled = ne, de.autoUpdate = ge, de.needsUpdate = ve, de.type = me;
    }
    function Ke(k) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage);
    }
    function st(k) {
      const ne = k.target;
      ne.removeEventListener("dispose", st), zt(ne);
    }
    function zt(k) {
      Ye(k), rt.remove(k);
    }
    function Ye(k) {
      const ne = rt.get(k).programs;
      ne !== void 0 && (ne.forEach(function(ge) {
        Mt.releaseProgram(ge);
      }), k.isShaderMaterial && Mt.releaseShaderCache(k));
    }
    this.renderBufferDirect = function(k, ne, ge, ve, me, Qe) {
      ne === null && (ne = ot);
      const wt = me.isMesh && me.matrixWorld.determinant() < 0, Ct = Ft(k, ne, ge, ve, me);
      Re.setMaterial(ve, wt);
      let At = ge.index, Wt = 1;
      if (ve.wireframe === !0) {
        if (At = ze.getWireframeAttribute(ge), At === void 0) return;
        Wt = 2;
      }
      const Xt = ge.drawRange, Zt = ge.attributes.position;
      let kn = Xt.start * Wt, zi = (Xt.start + Xt.count) * Wt;
      Qe !== null && (kn = Math.max(kn, Qe.start * Wt), zi = Math.min(zi, (Qe.start + Qe.count) * Wt)), At !== null ? (kn = Math.max(kn, 0), zi = Math.min(zi, At.count)) : Zt != null && (kn = Math.max(kn, 0), zi = Math.min(zi, Zt.count));
      const Gn = zi - kn;
      if (Gn < 0 || Gn === 1 / 0) return;
      Y.setup(me, ve, Ct, ge, At);
      let bi, jt = Xe;
      if (At !== null && (bi = Fe.get(At), jt = dt, jt.setIndex(bi)), me.isMesh)
        ve.wireframe === !0 ? (Re.setLineWidth(ve.wireframeLinewidth * pt()), jt.setMode(J.LINES)) : jt.setMode(J.TRIANGLES);
      else if (me.isLine) {
        let ht = ve.linewidth;
        ht === void 0 && (ht = 1), Re.setLineWidth(ht * pt()), me.isLineSegments ? jt.setMode(J.LINES) : me.isLineLoop ? jt.setMode(J.LINE_LOOP) : jt.setMode(J.LINE_STRIP);
      } else me.isPoints ? jt.setMode(J.POINTS) : me.isSprite && jt.setMode(J.TRIANGLES);
      if (me.isBatchedMesh)
        jt.renderMultiDraw(me._multiDrawStarts, me._multiDrawCounts, me._multiDrawCount);
      else if (me.isInstancedMesh)
        jt.renderInstances(kn, Gn, me.count);
      else if (ge.isInstancedBufferGeometry) {
        const ht = ge._maxInstanceCount !== void 0 ? ge._maxInstanceCount : 1 / 0, Ar = Math.min(ge.instanceCount, ht);
        jt.renderInstances(kn, Gn, Ar);
      } else
        jt.render(kn, Gn);
    };
    function qt(k, ne, ge) {
      k.transparent === !0 && k.side === po && k.forceSinglePass === !1 ? (k.side = ss, k.needsUpdate = !0, $(k, ne, ge), k.side = sl, k.needsUpdate = !0, $(k, ne, ge), k.side = po) : $(k, ne, ge);
    }
    this.compile = function(k, ne, ge = null) {
      ge === null && (ge = k), T = Dt.get(ge), T.init(), C.push(T), ge.traverseVisible(function(me) {
        me.isLight && me.layers.test(ne.layers) && (T.pushLight(me), me.castShadow && T.pushShadow(me));
      }), k !== ge && k.traverseVisible(function(me) {
        me.isLight && me.layers.test(ne.layers) && (T.pushLight(me), me.castShadow && T.pushShadow(me));
      }), T.setupLights(A._useLegacyLights);
      const ve = /* @__PURE__ */ new Set();
      return k.traverse(function(me) {
        const Qe = me.material;
        if (Qe)
          if (Array.isArray(Qe))
            for (let wt = 0; wt < Qe.length; wt++) {
              const Ct = Qe[wt];
              qt(Ct, ge, me), ve.add(Ct);
            }
          else
            qt(Qe, ge, me), ve.add(Qe);
      }), C.pop(), T = null, ve;
    }, this.compileAsync = function(k, ne, ge = null) {
      const ve = this.compile(k, ne, ge);
      return new Promise((me) => {
        function Qe() {
          if (ve.forEach(function(wt) {
            rt.get(wt).currentProgram.isReady() && ve.delete(wt);
          }), ve.size === 0) {
            me(k);
            return;
          }
          setTimeout(Qe, 10);
        }
        Pe.get("KHR_parallel_shader_compile") !== null ? Qe() : setTimeout(Qe, 10);
      });
    };
    let tn = null;
    function Sn(k) {
      tn && tn(k);
    }
    function bn() {
      di.stop();
    }
    function Jt() {
      di.start();
    }
    const di = new YP();
    di.setAnimationLoop(Sn), typeof self < "u" && di.setContext(self), this.setAnimationLoop = function(k) {
      tn = k, Ve.setAnimationLoop(k), k === null ? di.stop() : di.start();
    }, Ve.addEventListener("sessionstart", bn), Ve.addEventListener("sessionend", Jt), this.render = function(k, ne) {
      if (ne !== void 0 && ne.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (N === !0) return;
      k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(), ne.parent === null && ne.matrixWorldAutoUpdate === !0 && ne.updateMatrixWorld(), Ve.enabled === !0 && Ve.isPresenting === !0 && (Ve.cameraAutoUpdate === !0 && Ve.updateCamera(ne), ne = Ve.getCamera()), k.isScene === !0 && k.onBeforeRender(A, k, ne, V), T = Dt.get(k, C.length), T.init(), C.push(T), $e.multiplyMatrices(ne.projectionMatrix, ne.matrixWorldInverse), pe.setFromProjectionMatrix($e), qe = this.localClippingEnabled, Ae = Ht.init(this.clippingPlanes, qe), w = mt.get(k, M.length), w.init(), M.push(w), hi(k, ne, 0, A.sortObjects), w.finish(), A.sortObjects === !0 && w.sort(Q, se), this.info.render.frame++, Ae === !0 && Ht.beginShadows();
      const ge = T.state.shadowsArray;
      if (de.render(ge, k, ne), Ae === !0 && Ht.endShadows(), this.info.autoReset === !0 && this.info.reset(), nt.render(w, k), T.setupLights(A._useLegacyLights), ne.isArrayCamera) {
        const ve = ne.cameras;
        for (let me = 0, Qe = ve.length; me < Qe; me++) {
          const wt = ve[me];
          va(w, k, wt, wt.viewport);
        }
      } else
        va(w, k, ne);
      V !== null && (G.updateMultisampleRenderTarget(V), G.updateRenderTargetMipmap(V)), k.isScene === !0 && k.onAfterRender(A, k, ne), Y.resetDefaultState(), W = -1, U = null, C.pop(), C.length > 0 ? T = C[C.length - 1] : T = null, M.pop(), M.length > 0 ? w = M[M.length - 1] : w = null;
    };
    function hi(k, ne, ge, ve) {
      if (k.visible === !1) return;
      if (k.layers.test(ne.layers)) {
        if (k.isGroup)
          ge = k.renderOrder;
        else if (k.isLOD)
          k.autoUpdate === !0 && k.update(ne);
        else if (k.isLight)
          T.pushLight(k), k.castShadow && T.pushShadow(k);
        else if (k.isSprite) {
          if (!k.frustumCulled || pe.intersectsSprite(k)) {
            ve && Ut.setFromMatrixPosition(k.matrixWorld).applyMatrix4($e);
            const wt = Ie.update(k), Ct = k.material;
            Ct.visible && w.push(k, wt, Ct, ge, Ut.z, null);
          }
        } else if ((k.isMesh || k.isLine || k.isPoints) && (!k.frustumCulled || pe.intersectsObject(k))) {
          const wt = Ie.update(k), Ct = k.material;
          if (ve && (k.boundingSphere !== void 0 ? (k.boundingSphere === null && k.computeBoundingSphere(), Ut.copy(k.boundingSphere.center)) : (wt.boundingSphere === null && wt.computeBoundingSphere(), Ut.copy(wt.boundingSphere.center)), Ut.applyMatrix4(k.matrixWorld).applyMatrix4($e)), Array.isArray(Ct)) {
            const At = wt.groups;
            for (let Wt = 0, Xt = At.length; Wt < Xt; Wt++) {
              const Zt = At[Wt], kn = Ct[Zt.materialIndex];
              kn && kn.visible && w.push(k, wt, kn, ge, Ut.z, Zt);
            }
          } else Ct.visible && w.push(k, wt, Ct, ge, Ut.z, null);
        }
      }
      const Qe = k.children;
      for (let wt = 0, Ct = Qe.length; wt < Ct; wt++)
        hi(Qe[wt], ne, ge, ve);
    }
    function va(k, ne, ge, ve) {
      const me = k.opaque, Qe = k.transmissive, wt = k.transparent;
      T.setupLightsView(ge), Ae === !0 && Ht.setGlobalState(A.clippingPlanes, ge), Qe.length > 0 && Mo(me, Qe, ne, ge), ve && Re.viewport(O.copy(ve)), me.length > 0 && ws(me, ne, ge), Qe.length > 0 && ws(Qe, ne, ge), wt.length > 0 && ws(wt, ne, ge), Re.buffers.depth.setTest(!0), Re.buffers.depth.setMask(!0), Re.buffers.color.setMask(!0), Re.setPolygonOffset(!1);
    }
    function Mo(k, ne, ge, ve) {
      if ((ge.isScene === !0 ? ge.overrideMaterial : null) !== null)
        return;
      const Qe = He.isWebGL2;
      je === null && (je = new ka(1, 1, {
        generateMipmaps: !0,
        type: Pe.has("EXT_color_buffer_half_float") ? Qd : vo,
        minFilter: gu,
        samples: Qe ? 4 : 0
      })), A.getDrawingBufferSize(Rt), Qe ? je.setSize(Rt.x, Rt.y) : je.setSize(Ky(Rt.x), Ky(Rt.y));
      const wt = A.getRenderTarget();
      A.setRenderTarget(je), A.getClearColor(ye), K = A.getClearAlpha(), K < 1 && A.setClearColor(16777215, 0.5), A.clear();
      const Ct = A.toneMapping;
      A.toneMapping = mo, ws(k, ge, ve), G.updateMultisampleRenderTarget(je), G.updateRenderTargetMipmap(je);
      let At = !1;
      for (let Wt = 0, Xt = ne.length; Wt < Xt; Wt++) {
        const Zt = ne[Wt], kn = Zt.object, zi = Zt.geometry, Gn = Zt.material, bi = Zt.group;
        if (Gn.side === po && kn.layers.test(ve.layers)) {
          const jt = Gn.side;
          Gn.side = ss, Gn.needsUpdate = !0, Zn(kn, ge, ve, zi, Gn, bi), Gn.side = jt, Gn.needsUpdate = !0, At = !0;
        }
      }
      At === !0 && (G.updateMultisampleRenderTarget(je), G.updateRenderTargetMipmap(je)), A.setRenderTarget(wt), A.setClearColor(ye, K), A.toneMapping = Ct;
    }
    function ws(k, ne, ge) {
      const ve = ne.isScene === !0 ? ne.overrideMaterial : null;
      for (let me = 0, Qe = k.length; me < Qe; me++) {
        const wt = k[me], Ct = wt.object, At = wt.geometry, Wt = ve === null ? wt.material : ve, Xt = wt.group;
        Ct.layers.test(ge.layers) && Zn(Ct, ne, ge, At, Wt, Xt);
      }
    }
    function Zn(k, ne, ge, ve, me, Qe) {
      k.onBeforeRender(A, ne, ge, ve, me, Qe), k.modelViewMatrix.multiplyMatrices(ge.matrixWorldInverse, k.matrixWorld), k.normalMatrix.getNormalMatrix(k.modelViewMatrix), me.onBeforeRender(A, ne, ge, ve, k, Qe), me.transparent === !0 && me.side === po && me.forceSinglePass === !1 ? (me.side = ss, me.needsUpdate = !0, A.renderBufferDirect(ge, ne, ve, me, k, Qe), me.side = sl, me.needsUpdate = !0, A.renderBufferDirect(ge, ne, ve, me, k, Qe), me.side = po) : A.renderBufferDirect(ge, ne, ve, me, k, Qe), k.onAfterRender(A, ne, ge, ve, me, Qe);
    }
    function $(k, ne, ge) {
      ne.isScene !== !0 && (ne = ot);
      const ve = rt.get(k), me = T.state.lights, Qe = T.state.shadowsArray, wt = me.state.version, Ct = Mt.getParameters(k, me.state, Qe, ne, ge), At = Mt.getProgramCacheKey(Ct);
      let Wt = ve.programs;
      ve.environment = k.isMeshStandardMaterial ? ne.environment : null, ve.fog = ne.fog, ve.envMap = (k.isMeshStandardMaterial ? ce : B).get(k.envMap || ve.environment), Wt === void 0 && (k.addEventListener("dispose", st), Wt = /* @__PURE__ */ new Map(), ve.programs = Wt);
      let Xt = Wt.get(At);
      if (Xt !== void 0) {
        if (ve.currentProgram === Xt && ve.lightsStateVersion === wt)
          return vt(k, Ct), Xt;
      } else
        Ct.uniforms = Mt.getUniforms(k), k.onBuild(ge, Ct, A), k.onBeforeCompile(Ct, A), Xt = Mt.acquireProgram(Ct, At), Wt.set(At, Xt), ve.uniforms = Ct.uniforms;
      const Zt = ve.uniforms;
      return (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (Zt.clippingPlanes = Ht.uniform), vt(k, Ct), ve.needsLights = hn(k), ve.lightsStateVersion = wt, ve.needsLights && (Zt.ambientLightColor.value = me.state.ambient, Zt.lightProbe.value = me.state.probe, Zt.directionalLights.value = me.state.directional, Zt.directionalLightShadows.value = me.state.directionalShadow, Zt.spotLights.value = me.state.spot, Zt.spotLightShadows.value = me.state.spotShadow, Zt.rectAreaLights.value = me.state.rectArea, Zt.ltc_1.value = me.state.rectAreaLTC1, Zt.ltc_2.value = me.state.rectAreaLTC2, Zt.pointLights.value = me.state.point, Zt.pointLightShadows.value = me.state.pointShadow, Zt.hemisphereLights.value = me.state.hemi, Zt.directionalShadowMap.value = me.state.directionalShadowMap, Zt.directionalShadowMatrix.value = me.state.directionalShadowMatrix, Zt.spotShadowMap.value = me.state.spotShadowMap, Zt.spotLightMatrix.value = me.state.spotLightMatrix, Zt.spotLightMap.value = me.state.spotLightMap, Zt.pointShadowMap.value = me.state.pointShadowMap, Zt.pointShadowMatrix.value = me.state.pointShadowMatrix), ve.currentProgram = Xt, ve.uniformsList = null, Xt;
    }
    function ke(k) {
      if (k.uniformsList === null) {
        const ne = k.currentProgram.getUniforms();
        k.uniformsList = ky.seqWithValue(ne.seq, k.uniforms);
      }
      return k.uniformsList;
    }
    function vt(k, ne) {
      const ge = rt.get(k);
      ge.outputColorSpace = ne.outputColorSpace, ge.batching = ne.batching, ge.instancing = ne.instancing, ge.instancingColor = ne.instancingColor, ge.skinning = ne.skinning, ge.morphTargets = ne.morphTargets, ge.morphNormals = ne.morphNormals, ge.morphColors = ne.morphColors, ge.morphTargetsCount = ne.morphTargetsCount, ge.numClippingPlanes = ne.numClippingPlanes, ge.numIntersection = ne.numClipIntersection, ge.vertexAlphas = ne.vertexAlphas, ge.vertexTangents = ne.vertexTangents, ge.toneMapping = ne.toneMapping;
    }
    function Ft(k, ne, ge, ve, me) {
      ne.isScene !== !0 && (ne = ot), G.resetTextureUnits();
      const Qe = ne.fog, wt = ve.isMeshStandardMaterial ? ne.environment : null, Ct = V === null ? A.outputColorSpace : V.isXRRenderTarget === !0 ? V.texture.colorSpace : xo, At = (ve.isMeshStandardMaterial ? ce : B).get(ve.envMap || wt), Wt = ve.vertexColors === !0 && !!ge.attributes.color && ge.attributes.color.itemSize === 4, Xt = !!ge.attributes.tangent && (!!ve.normalMap || ve.anisotropy > 0), Zt = !!ge.morphAttributes.position, kn = !!ge.morphAttributes.normal, zi = !!ge.morphAttributes.color;
      let Gn = mo;
      ve.toneMapped && (V === null || V.isXRRenderTarget === !0) && (Gn = A.toneMapping);
      const bi = ge.morphAttributes.position || ge.morphAttributes.normal || ge.morphAttributes.color, jt = bi !== void 0 ? bi.length : 0, ht = rt.get(ve), Ar = T.state.lights;
      if (Ae === !0 && (qe === !0 || k !== U)) {
        const Ti = k === U && ve.id === W;
        Ht.setState(ve, k, Ti);
      }
      let on = !1;
      ve.version === ht.__version ? (ht.needsLights && ht.lightsStateVersion !== Ar.state.version || ht.outputColorSpace !== Ct || me.isBatchedMesh && ht.batching === !1 || !me.isBatchedMesh && ht.batching === !0 || me.isInstancedMesh && ht.instancing === !1 || !me.isInstancedMesh && ht.instancing === !0 || me.isSkinnedMesh && ht.skinning === !1 || !me.isSkinnedMesh && ht.skinning === !0 || me.isInstancedMesh && ht.instancingColor === !0 && me.instanceColor === null || me.isInstancedMesh && ht.instancingColor === !1 && me.instanceColor !== null || ht.envMap !== At || ve.fog === !0 && ht.fog !== Qe || ht.numClippingPlanes !== void 0 && (ht.numClippingPlanes !== Ht.numPlanes || ht.numIntersection !== Ht.numIntersection) || ht.vertexAlphas !== Wt || ht.vertexTangents !== Xt || ht.morphTargets !== Zt || ht.morphNormals !== kn || ht.morphColors !== zi || ht.toneMapping !== Gn || He.isWebGL2 === !0 && ht.morphTargetsCount !== jt) && (on = !0) : (on = !0, ht.__version = ve.version);
      let ti = ht.currentProgram;
      on === !0 && (ti = $(ve, ne, me));
      let Ws = !1, ls = !1, Bi = !1;
      const Kn = ti.getUniforms(), As = ht.uniforms;
      if (Re.useProgram(ti.program) && (Ws = !0, ls = !0, Bi = !0), ve.id !== W && (W = ve.id, ls = !0), Ws || U !== k) {
        Kn.setValue(J, "projectionMatrix", k.projectionMatrix), Kn.setValue(J, "viewMatrix", k.matrixWorldInverse);
        const Ti = Kn.map.cameraPosition;
        Ti !== void 0 && Ti.setValue(J, Ut.setFromMatrixPosition(k.matrixWorld)), He.logarithmicDepthBuffer && Kn.setValue(
          J,
          "logDepthBufFC",
          2 / (Math.log(k.far + 1) / Math.LN2)
        ), (ve.isMeshPhongMaterial || ve.isMeshToonMaterial || ve.isMeshLambertMaterial || ve.isMeshBasicMaterial || ve.isMeshStandardMaterial || ve.isShaderMaterial) && Kn.setValue(J, "isOrthographic", k.isOrthographicCamera === !0), U !== k && (U = k, ls = !0, Bi = !0);
      }
      if (me.isSkinnedMesh) {
        Kn.setOptional(J, me, "bindMatrix"), Kn.setOptional(J, me, "bindMatrixInverse");
        const Ti = me.skeleton;
        Ti && (He.floatVertexTextures ? (Ti.boneTexture === null && Ti.computeBoneTexture(), Kn.setValue(J, "boneTexture", Ti.boneTexture, G)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      me.isBatchedMesh && (Kn.setOptional(J, me, "batchingTexture"), Kn.setValue(J, "batchingTexture", me._matricesTexture, G));
      const Eo = ge.morphAttributes;
      if ((Eo.position !== void 0 || Eo.normal !== void 0 || Eo.color !== void 0 && He.isWebGL2 === !0) && lt.update(me, ge, ti), (ls || ht.receiveShadow !== me.receiveShadow) && (ht.receiveShadow = me.receiveShadow, Kn.setValue(J, "receiveShadow", me.receiveShadow)), ve.isMeshGouraudMaterial && ve.envMap !== null && (As.envMap.value = At, As.flipEnvMap.value = At.isCubeTexture && At.isRenderTargetTexture === !1 ? -1 : 1), ls && (Kn.setValue(J, "toneMappingExposure", A.toneMappingExposure), ht.needsLights && xn(As, Bi), Qe && ve.fog === !0 && it.refreshFogUniforms(As, Qe), it.refreshMaterialUniforms(As, ve, Ee, ie, je), ky.upload(J, ke(ht), As, G)), ve.isShaderMaterial && ve.uniformsNeedUpdate === !0 && (ky.upload(J, ke(ht), As, G), ve.uniformsNeedUpdate = !1), ve.isSpriteMaterial && Kn.setValue(J, "center", me.center), Kn.setValue(J, "modelViewMatrix", me.modelViewMatrix), Kn.setValue(J, "normalMatrix", me.normalMatrix), Kn.setValue(J, "modelMatrix", me.matrixWorld), ve.isShaderMaterial || ve.isRawShaderMaterial) {
        const Ti = ve.uniformsGroups;
        for (let bo = 0, Rr = Ti.length; bo < Rr; bo++)
          if (He.isWebGL2) {
            const Zc = Ti[bo];
            he.update(Zc, ti), he.bind(Zc, ti);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return ti;
    }
    function xn(k, ne) {
      k.ambientLightColor.needsUpdate = ne, k.lightProbe.needsUpdate = ne, k.directionalLights.needsUpdate = ne, k.directionalLightShadows.needsUpdate = ne, k.pointLights.needsUpdate = ne, k.pointLightShadows.needsUpdate = ne, k.spotLights.needsUpdate = ne, k.spotLightShadows.needsUpdate = ne, k.rectAreaLights.needsUpdate = ne, k.hemisphereLights.needsUpdate = ne;
    }
    function hn(k) {
      return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return z;
    }, this.getActiveMipmapLevel = function() {
      return I;
    }, this.getRenderTarget = function() {
      return V;
    }, this.setRenderTargetTextures = function(k, ne, ge) {
      rt.get(k.texture).__webglTexture = ne, rt.get(k.depthTexture).__webglTexture = ge;
      const ve = rt.get(k);
      ve.__hasExternalTextures = !0, ve.__hasExternalTextures && (ve.__autoAllocateDepthBuffer = ge === void 0, ve.__autoAllocateDepthBuffer || Pe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ve.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(k, ne) {
      const ge = rt.get(k);
      ge.__webglFramebuffer = ne, ge.__useDefaultFramebuffer = ne === void 0;
    }, this.setRenderTarget = function(k, ne = 0, ge = 0) {
      V = k, z = ne, I = ge;
      let ve = !0, me = null, Qe = !1, wt = !1;
      if (k) {
        const At = rt.get(k);
        At.__useDefaultFramebuffer !== void 0 ? (Re.bindFramebuffer(J.FRAMEBUFFER, null), ve = !1) : At.__webglFramebuffer === void 0 ? G.setupRenderTarget(k) : At.__hasExternalTextures && G.rebindTextures(k, rt.get(k.texture).__webglTexture, rt.get(k.depthTexture).__webglTexture);
        const Wt = k.texture;
        (Wt.isData3DTexture || Wt.isDataArrayTexture || Wt.isCompressedArrayTexture) && (wt = !0);
        const Xt = rt.get(k).__webglFramebuffer;
        k.isWebGLCubeRenderTarget ? (Array.isArray(Xt[ne]) ? me = Xt[ne][ge] : me = Xt[ne], Qe = !0) : He.isWebGL2 && k.samples > 0 && G.useMultisampledRTT(k) === !1 ? me = rt.get(k).__webglMultisampledFramebuffer : Array.isArray(Xt) ? me = Xt[ge] : me = Xt, O.copy(k.viewport), q.copy(k.scissor), le = k.scissorTest;
      } else
        O.copy(re).multiplyScalar(Ee).floor(), q.copy(ue).multiplyScalar(Ee).floor(), le = Le;
      if (Re.bindFramebuffer(J.FRAMEBUFFER, me) && He.drawBuffers && ve && Re.drawBuffers(k, me), Re.viewport(O), Re.scissor(q), Re.setScissorTest(le), Qe) {
        const At = rt.get(k.texture);
        J.framebufferTexture2D(J.FRAMEBUFFER, J.COLOR_ATTACHMENT0, J.TEXTURE_CUBE_MAP_POSITIVE_X + ne, At.__webglTexture, ge);
      } else if (wt) {
        const At = rt.get(k.texture), Wt = ne || 0;
        J.framebufferTextureLayer(J.FRAMEBUFFER, J.COLOR_ATTACHMENT0, At.__webglTexture, ge || 0, Wt);
      }
      W = -1;
    }, this.readRenderTargetPixels = function(k, ne, ge, ve, me, Qe, wt) {
      if (!(k && k.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ct = rt.get(k).__webglFramebuffer;
      if (k.isWebGLCubeRenderTarget && wt !== void 0 && (Ct = Ct[wt]), Ct) {
        Re.bindFramebuffer(J.FRAMEBUFFER, Ct);
        try {
          const At = k.texture, Wt = At.format, Xt = At.type;
          if (Wt !== is && at.convert(Wt) !== J.getParameter(J.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const Zt = Xt === Qd && (Pe.has("EXT_color_buffer_half_float") || He.isWebGL2 && Pe.has("EXT_color_buffer_float"));
          if (Xt !== vo && at.convert(Xt) !== J.getParameter(J.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(Xt === Va && (He.isWebGL2 || Pe.has("OES_texture_float") || Pe.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !Zt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ne >= 0 && ne <= k.width - ve && ge >= 0 && ge <= k.height - me && J.readPixels(ne, ge, ve, me, at.convert(Wt), at.convert(Xt), Qe);
        } finally {
          const At = V !== null ? rt.get(V).__webglFramebuffer : null;
          Re.bindFramebuffer(J.FRAMEBUFFER, At);
        }
      }
    }, this.copyFramebufferToTexture = function(k, ne, ge = 0) {
      const ve = Math.pow(2, -ge), me = Math.floor(ne.image.width * ve), Qe = Math.floor(ne.image.height * ve);
      G.setTexture2D(ne, 0), J.copyTexSubImage2D(J.TEXTURE_2D, ge, 0, 0, k.x, k.y, me, Qe), Re.unbindTexture();
    }, this.copyTextureToTexture = function(k, ne, ge, ve = 0) {
      const me = ne.image.width, Qe = ne.image.height, wt = at.convert(ge.format), Ct = at.convert(ge.type);
      G.setTexture2D(ge, 0), J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL, ge.flipY), J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ge.premultiplyAlpha), J.pixelStorei(J.UNPACK_ALIGNMENT, ge.unpackAlignment), ne.isDataTexture ? J.texSubImage2D(J.TEXTURE_2D, ve, k.x, k.y, me, Qe, wt, Ct, ne.image.data) : ne.isCompressedTexture ? J.compressedTexSubImage2D(J.TEXTURE_2D, ve, k.x, k.y, ne.mipmaps[0].width, ne.mipmaps[0].height, wt, ne.mipmaps[0].data) : J.texSubImage2D(J.TEXTURE_2D, ve, k.x, k.y, wt, Ct, ne.image), ve === 0 && ge.generateMipmaps && J.generateMipmap(J.TEXTURE_2D), Re.unbindTexture();
    }, this.copyTextureToTexture3D = function(k, ne, ge, ve, me = 0) {
      if (A.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const Qe = k.max.x - k.min.x + 1, wt = k.max.y - k.min.y + 1, Ct = k.max.z - k.min.z + 1, At = at.convert(ve.format), Wt = at.convert(ve.type);
      let Xt;
      if (ve.isData3DTexture)
        G.setTexture3D(ve, 0), Xt = J.TEXTURE_3D;
      else if (ve.isDataArrayTexture || ve.isCompressedArrayTexture)
        G.setTexture2DArray(ve, 0), Xt = J.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL, ve.flipY), J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), J.pixelStorei(J.UNPACK_ALIGNMENT, ve.unpackAlignment);
      const Zt = J.getParameter(J.UNPACK_ROW_LENGTH), kn = J.getParameter(J.UNPACK_IMAGE_HEIGHT), zi = J.getParameter(J.UNPACK_SKIP_PIXELS), Gn = J.getParameter(J.UNPACK_SKIP_ROWS), bi = J.getParameter(J.UNPACK_SKIP_IMAGES), jt = ge.isCompressedTexture ? ge.mipmaps[me] : ge.image;
      J.pixelStorei(J.UNPACK_ROW_LENGTH, jt.width), J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, jt.height), J.pixelStorei(J.UNPACK_SKIP_PIXELS, k.min.x), J.pixelStorei(J.UNPACK_SKIP_ROWS, k.min.y), J.pixelStorei(J.UNPACK_SKIP_IMAGES, k.min.z), ge.isDataTexture || ge.isData3DTexture ? J.texSubImage3D(Xt, me, ne.x, ne.y, ne.z, Qe, wt, Ct, At, Wt, jt.data) : ge.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), J.compressedTexSubImage3D(Xt, me, ne.x, ne.y, ne.z, Qe, wt, Ct, At, jt.data)) : J.texSubImage3D(Xt, me, ne.x, ne.y, ne.z, Qe, wt, Ct, At, Wt, jt), J.pixelStorei(J.UNPACK_ROW_LENGTH, Zt), J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, kn), J.pixelStorei(J.UNPACK_SKIP_PIXELS, zi), J.pixelStorei(J.UNPACK_SKIP_ROWS, Gn), J.pixelStorei(J.UNPACK_SKIP_IMAGES, bi), me === 0 && ve.generateMipmaps && J.generateMipmap(Xt), Re.unbindTexture();
    }, this.initTexture = function(k) {
      k.isCubeTexture ? G.setTextureCube(k, 0) : k.isData3DTexture ? G.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? G.setTexture2DArray(k, 0) : G.setTexture2D(k, 0), Re.unbindTexture();
    }, this.resetState = function() {
      z = 0, I = 0, V = null, Re.reset(), Y.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Ha;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === h0 ? "display-p3" : "srgb", t.unpackColorSpace = zn.workingColorSpace === Lm ? "display-p3" : "srgb";
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === nr ? du : IE;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === du ? nr : xo;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class tL extends YE {
}
tL.prototype.isWebGL1Renderer = !0;
class v0 {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Tt(e), this.density = t;
  }
  clone() {
    return new v0(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class g0 {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Tt(e), this.near = t, this.far = n;
  }
  clone() {
    return new g0(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class qE extends Dn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class y0 {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = vm, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = ks();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let r = 0, o = this.stride; r < o; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ks()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ks()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const es = /* @__PURE__ */ new j();
class Vc {
  constructor(e, t, n, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      es.fromBufferAttribute(this, t), es.applyMatrix4(e), this.setXYZ(t, es.x, es.y, es.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      es.fromBufferAttribute(this, t), es.applyNormalMatrix(e), this.setXYZ(t, es.x, es.y, es.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      es.fromBufferAttribute(this, t), es.transformDirection(e), this.setXYZ(t, es.x, es.y, es.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = dn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Es(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = dn(t, this.array), n = dn(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = dn(t, this.array), n = dn(n, this.array), r = dn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, n, r, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = dn(t, this.array), n = dn(n, this.array), r = dn(r, this.array), o = dn(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = o, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[r + o]);
      }
      return new Vn(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Vc(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[r + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class ZE extends Yr {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Tt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Ld;
const Up = /* @__PURE__ */ new j(), Dd = /* @__PURE__ */ new j(), Nd = /* @__PURE__ */ new j(), Ud = /* @__PURE__ */ new Oe(), Op = /* @__PURE__ */ new Oe(), nL = /* @__PURE__ */ new $t(), ry = /* @__PURE__ */ new j(), Ip = /* @__PURE__ */ new j(), sy = /* @__PURE__ */ new j(), gA = /* @__PURE__ */ new Oe(), CS = /* @__PURE__ */ new Oe(), yA = /* @__PURE__ */ new Oe();
class iL extends Dn {
  constructor(e = new ZE()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Ld === void 0) {
      Ld = new gn();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new y0(t, 5);
      Ld.setIndex([0, 1, 2, 0, 2, 3]), Ld.setAttribute("position", new Vc(n, 3, 0, !1)), Ld.setAttribute("uv", new Vc(n, 2, 3, !1));
    }
    this.geometry = Ld, this.material = e, this.center = new Oe(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Dd.setFromMatrixScale(this.matrixWorld), nL.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Nd.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Dd.multiplyScalar(-Nd.z);
    const n = this.material.rotation;
    let r, o;
    n !== 0 && (o = Math.cos(n), r = Math.sin(n));
    const l = this.center;
    ay(ry.set(-0.5, -0.5, 0), Nd, l, Dd, r, o), ay(Ip.set(0.5, -0.5, 0), Nd, l, Dd, r, o), ay(sy.set(0.5, 0.5, 0), Nd, l, Dd, r, o), gA.set(0, 0), CS.set(1, 0), yA.set(1, 1);
    let u = e.ray.intersectTriangle(ry, Ip, sy, !1, Up);
    if (u === null && (ay(Ip.set(-0.5, 0.5, 0), Nd, l, Dd, r, o), CS.set(0, 1), u = e.ray.intersectTriangle(ry, sy, Ip, !1, Up), u === null))
      return;
    const d = e.ray.origin.distanceTo(Up);
    d < e.near || d > e.far || t.push({
      distance: d,
      point: Up.clone(),
      uv: Ms.getInterpolation(Up, ry, Ip, sy, gA, CS, yA, new Oe()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function ay(i, e, t, n, r, o) {
  Ud.subVectors(i, t).addScalar(0.5).multiply(n), r !== void 0 ? (Op.x = o * Ud.x - r * Ud.y, Op.y = r * Ud.x + o * Ud.y) : Op.copy(Ud), i.copy(e), i.x += Op.x, i.y += Op.y, i.applyMatrix4(nL);
}
const oy = /* @__PURE__ */ new j(), xA = /* @__PURE__ */ new j();
class rL extends Dn {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let o;
    for (o = 0; o < r.length && !(t < r[o].distance); o++)
      ;
    return r.splice(o, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, r;
      for (n = 1, r = t.length; n < r; n++) {
        let o = t[n].distance;
        if (t[n].object.visible && (o -= o * t[n].hysteresis), e < o)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      oy.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(oy);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      oy.setFromMatrixPosition(e.matrixWorld), xA.setFromMatrixPosition(this.matrixWorld);
      const n = oy.distanceTo(xA) / e.zoom;
      t[0].object.visible = !0;
      let r, o;
      for (r = 1, o = t.length; r < o; r++) {
        let l = t[r].distance;
        if (t[r].object.visible && (l -= l * t[r].hysteresis), n >= l)
          t[r - 1].object.visible = !1, t[r].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = r - 1; r < o; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let r = 0, o = n.length; r < o; r++) {
      const l = n[r];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance,
        hysteresis: l.hysteresis
      });
    }
    return t;
  }
}
const _A = /* @__PURE__ */ new j(), SA = /* @__PURE__ */ new Bn(), MA = /* @__PURE__ */ new Bn(), wH = /* @__PURE__ */ new j(), EA = /* @__PURE__ */ new $t(), ly = /* @__PURE__ */ new j(), PS = /* @__PURE__ */ new jr(), bA = /* @__PURE__ */ new $t(), LS = /* @__PURE__ */ new Gc();
class sL extends ir {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = MM, this.bindMatrix = new $t(), this.bindMatrixInverse = new $t(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new as()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, ly), this.boundingBox.expandByPoint(ly);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new jr()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, ly), this.boundingSphere.expandByPoint(ly);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, r = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), PS.copy(this.boundingSphere), PS.applyMatrix4(r), e.ray.intersectsSphere(PS) !== !1 && (bA.copy(r).invert(), LS.copy(e.ray).applyMatrix4(bA), !(this.boundingBox !== null && LS.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, LS)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Bn(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, r = t.count; n < r; n++) {
      e.fromBufferAttribute(t, n);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === MM ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === gP ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, r = this.geometry;
    SA.fromBufferAttribute(r.attributes.skinIndex, e), MA.fromBufferAttribute(r.attributes.skinWeight, e), _A.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const l = MA.getComponent(o);
      if (l !== 0) {
        const u = SA.getComponent(o);
        EA.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]), t.addScaledVector(wH.copy(_A).applyMatrix4(EA), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class KE extends Dn {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Ic extends Fi {
  constructor(e = null, t = 1, n = 1, r, o, l, u, d, h = Ui, m = Ui, g, y) {
    super(null, l, u, d, h, m, r, o, g, y), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const TA = /* @__PURE__ */ new $t(), AH = /* @__PURE__ */ new $t();
class x0 {
  constructor(e = [], t = []) {
    this.uuid = ks(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new $t());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new $t();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o] ? e[o].matrixWorld : AH;
      TA.multiplyMatrices(u, t[o]), TA.toArray(n, o * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new x0(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Ic(t, e, e, is, Va);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, r = e.bones.length; n < r; n++) {
      const o = e.bones[n];
      let l = t[o];
      l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), l = new KE()), this.bones.push(l), this.boneInverses.push(new $t().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let r = 0, o = t.length; r < o; r++) {
      const l = t[r];
      e.bones.push(l.uuid);
      const u = n[r];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class nh extends Vn {
  constructor(e, t, n, r = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Od = /* @__PURE__ */ new $t(), wA = /* @__PURE__ */ new $t(), uy = [], AA = /* @__PURE__ */ new as(), RH = /* @__PURE__ */ new $t(), Fp = /* @__PURE__ */ new ir(), zp = /* @__PURE__ */ new jr();
class aL extends ir {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new nh(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < n; r++)
      this.setMatrixAt(r, RH);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new as()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Od), AA.copy(e.boundingBox).applyMatrix4(Od), this.boundingBox.union(AA);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new jr()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Od), zp.copy(e.boundingSphere).applyMatrix4(Od), this.boundingSphere.union(zp);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld, r = this.count;
    if (Fp.geometry = this.geometry, Fp.material = this.material, Fp.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), zp.copy(this.boundingSphere), zp.applyMatrix4(n), e.ray.intersectsSphere(zp) !== !1))
      for (let o = 0; o < r; o++) {
        this.getMatrixAt(o, Od), wA.multiplyMatrices(n, Od), Fp.matrixWorld = wA, Fp.raycast(e, uy);
        for (let l = 0, u = uy.length; l < u; l++) {
          const d = uy[l];
          d.instanceId = o, d.object = this, t.push(d);
        }
        uy.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new nh(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function CH(i, e) {
  return i.z - e.z;
}
function PH(i, e) {
  return e.z - i.z;
}
class LH {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const n = this.pool, r = this.list;
    this.index >= n.length && n.push({
      start: -1,
      count: -1,
      z: -1
    });
    const o = n[this.index];
    r.push(o), this.index++, o.start = e.start, o.count = e.count, o.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const Id = "batchId", nu = /* @__PURE__ */ new $t(), RA = /* @__PURE__ */ new $t(), DH = /* @__PURE__ */ new $t(), CA = /* @__PURE__ */ new $t(), DS = /* @__PURE__ */ new Om(), cy = /* @__PURE__ */ new as(), hc = /* @__PURE__ */ new jr(), Bp = /* @__PURE__ */ new j(), NS = /* @__PURE__ */ new LH(), kr = /* @__PURE__ */ new ir(), fy = [];
function NH(i, e, t = 0) {
  const n = e.itemSize;
  if (i.isInterleavedBufferAttribute || i.array.constructor !== e.array.constructor) {
    const r = i.count;
    for (let o = 0; o < r; o++)
      for (let l = 0; l < n; l++)
        e.setComponent(o + t, l, i.getComponent(o, l));
  } else
    e.array.set(i.array, t * n);
  e.needsUpdate = !0;
}
class oL extends ir {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, n = t * 2, r) {
    super(new gn(), r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new Ic(t, e, e, is, Va);
    this._matricesTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, r = this._maxGeometryCount, o = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const u in e.attributes) {
        const d = e.getAttribute(u), { array: h, itemSize: m, normalized: g } = d, y = new h.constructor(n * m), _ = new d.constructor(y, m, g);
        _.setUsage(d.usage), t.setAttribute(u, _);
      }
      if (e.getIndex() !== null) {
        const u = n > 65536 ? new Uint32Array(o) : new Uint16Array(o);
        t.setIndex(new Vn(u, 1));
      }
      const l = r > 65536 ? new Uint32Array(n) : new Uint16Array(n);
      t.setAttribute(Id, new Vn(l, 1)), this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry atributes
  _validateGeometry(e) {
    if (e.getAttribute(Id))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${Id}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (n === Id)
        continue;
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(n), o = t.getAttribute(n);
      if (r.itemSize !== o.itemSize || r.normalized !== o.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new as());
    const e = this._geometryCount, t = this.boundingBox, n = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      n[r] !== !1 && (this.getMatrixAt(r, nu), this.getBoundingBoxAt(r, cy).applyMatrix4(nu), t.union(cy));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new jr());
    const e = this._geometryCount, t = this.boundingSphere, n = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      n[r] !== !1 && (this.getMatrixAt(r, nu), this.getBoundingSphereAt(r, hc).applyMatrix4(nu), t.union(hc));
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let o = null;
    const l = this._reservedRanges, u = this._drawRanges, d = this._bounds;
    this._geometryCount !== 0 && (o = l[l.length - 1]), t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t, o === null ? r.vertexStart = 0 : r.vertexStart = o.vertexStart + o.vertexCount;
    const h = e.getIndex(), m = h !== null;
    if (m && (n === -1 ? r.indexCount = h.count : r.indexCount = n, o === null ? r.indexStart = 0 : r.indexStart = o.indexStart + o.indexCount), r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const g = this._visibility, y = this._active, _ = this._matricesTexture, E = this._matricesTexture.image.data;
    g.push(!0), y.push(!0);
    const w = this._geometryCount;
    this._geometryCount++, DH.toArray(E, w * 16), _.needsUpdate = !0, l.push(r), u.push({
      start: m ? r.indexStart : r.vertexStart,
      count: -1
    }), d.push({
      boxInitialized: !1,
      box: new as(),
      sphereInitialized: !1,
      sphere: new jr()
    });
    const T = this.geometry.getAttribute(Id);
    for (let M = 0; M < r.vertexCount; M++)
      T.setX(r.vertexStart + M, w);
    return T.needsUpdate = !0, this.setGeometryAt(w, e), w;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, r = n.getIndex() !== null, o = n.getIndex(), l = t.getIndex(), u = this._reservedRanges[e];
    if (r && l.count > u.indexCount || t.attributes.position.count > u.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const d = u.vertexStart, h = u.vertexCount;
    for (const _ in n.attributes) {
      if (_ === Id)
        continue;
      const E = t.getAttribute(_), w = n.getAttribute(_);
      NH(E, w, d);
      const T = E.itemSize;
      for (let M = E.count, C = h; M < C; M++) {
        const A = d + M;
        for (let N = 0; N < T; N++)
          w.setComponent(A, N, 0);
      }
      w.needsUpdate = !0;
    }
    if (r) {
      const _ = u.indexStart;
      for (let E = 0; E < l.count; E++)
        o.setX(_ + E, d + l.getX(E));
      for (let E = l.count, w = u.indexCount; E < w; E++)
        o.setX(_ + E, d);
      o.needsUpdate = !0;
    }
    const m = this._bounds[e];
    t.boundingBox !== null ? (m.box.copy(t.boundingBox), m.boxInitialized = !0) : m.boxInitialized = !1, t.boundingSphere !== null ? (m.sphere.copy(t.boundingSphere), m.sphereInitialized = !0) : m.sphereInitialized = !1;
    const g = this._drawRanges[e], y = t.getAttribute("position");
    return g.count = r ? l.count : y.count, this._visibilityChanged = !0, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this);
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const r = this._bounds[e], o = r.box, l = this.geometry;
    if (r.boxInitialized === !1) {
      o.makeEmpty();
      const u = l.index, d = l.attributes.position, h = this._drawRanges[e];
      for (let m = h.start, g = h.start + h.count; m < g; m++) {
        let y = m;
        u && (y = u.getX(y)), o.expandByPoint(Bp.fromBufferAttribute(d, y));
      }
      r.boxInitialized = !0;
    }
    return t.copy(o), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const r = this._bounds[e], o = r.sphere, l = this.geometry;
    if (r.sphereInitialized === !1) {
      o.makeEmpty(), this.getBoundingBoxAt(e, cy), cy.getCenter(o.center);
      const u = l.index, d = l.attributes.position, h = this._drawRanges[e];
      let m = 0;
      for (let g = h.start, y = h.start + h.count; g < y; g++) {
        let _ = g;
        u && (_ = u.getX(_)), Bp.fromBufferAttribute(d, _), m = Math.max(m, o.center.distanceToSquared(Bp));
      }
      o.radius = Math.sqrt(m), r.sphereInitialized = !0;
    }
    return t.copy(o), t;
  }
  setMatrixAt(e, t) {
    const n = this._active, r = this._matricesTexture, o = this._matricesTexture.image.data, l = this._geometryCount;
    return e >= l || n[e] === !1 ? this : (t.toArray(o, e * 16), r.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._active, r = this._matricesTexture.image.data, o = this._geometryCount;
    return e >= o || n[e] === !1 ? null : t.fromArray(r, e * 16);
  }
  setVisibleAt(e, t) {
    const n = this._visibility, r = this._active, o = this._geometryCount;
    return e >= o || r[e] === !1 || n[e] === t ? this : (n[e] = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, n = this._active, r = this._geometryCount;
    return e >= r || n[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const n = this._visibility, r = this._active, o = this._drawRanges, l = this._geometryCount, u = this.matrixWorld, d = this.geometry;
    kr.material = this.material, kr.geometry.index = d.index, kr.geometry.attributes = d.attributes, kr.geometry.boundingBox === null && (kr.geometry.boundingBox = new as()), kr.geometry.boundingSphere === null && (kr.geometry.boundingSphere = new jr());
    for (let h = 0; h < l; h++) {
      if (!n[h] || !r[h])
        continue;
      const m = o[h];
      kr.geometry.setDrawRange(m.start, m.count), this.getMatrixAt(h, kr.matrixWorld).premultiply(u), this.getBoundingBoxAt(h, kr.geometry.boundingBox), this.getBoundingSphereAt(h, kr.geometry.boundingSphere), kr.raycast(e, fy);
      for (let g = 0, y = fy.length; g < y; g++) {
        const _ = fy[g];
        _.object = this, _.batchId = h, t.push(_);
      }
      fy.length = 0;
    }
    kr.material = null, kr.geometry.index = null, kr.geometry.attributes = {}, kr.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, n, r, o) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const l = r.getIndex(), u = l === null ? 1 : l.array.BYTES_PER_ELEMENT, d = this._visibility, h = this._multiDrawStarts, m = this._multiDrawCounts, g = this._drawRanges, y = this.perObjectFrustumCulled;
    y && (CA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), DS.setFromProjectionMatrix(
      CA,
      e.isWebGPURenderer ? $d : Ha
    ));
    let _ = 0;
    if (this.sortObjects) {
      RA.copy(this.matrixWorld).invert(), Bp.setFromMatrixPosition(n.matrixWorld).applyMatrix4(RA);
      for (let T = 0, M = d.length; T < M; T++)
        if (d[T]) {
          this.getMatrixAt(T, nu), this.getBoundingSphereAt(T, hc).applyMatrix4(nu);
          let C = !1;
          if (y && (C = !DS.intersectsSphere(hc)), !C) {
            const A = Bp.distanceTo(hc.center);
            NS.push(g[T], A);
          }
        }
      const E = NS.list, w = this.customSort;
      w === null ? E.sort(o.transparent ? PH : CH) : w.call(this, E, n);
      for (let T = 0, M = E.length; T < M; T++) {
        const C = E[T];
        h[_] = C.start * u, m[_] = C.count, _++;
      }
      NS.reset();
    } else
      for (let E = 0, w = d.length; E < w; E++)
        if (d[E]) {
          let T = !1;
          if (y && (this.getMatrixAt(E, nu), this.getBoundingSphereAt(E, hc).applyMatrix4(nu), T = !DS.intersectsSphere(hc)), !T) {
            const M = g[E];
            h[_] = M.start * u, m[_] = M.count, _++;
          }
        }
    this._multiDrawCount = _, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, r, o, l) {
    this.onBeforeRender(e, null, r, o, l);
  }
}
class os extends Yr {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Tt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const PA = /* @__PURE__ */ new j(), LA = /* @__PURE__ */ new j(), DA = /* @__PURE__ */ new $t(), US = /* @__PURE__ */ new Gc(), dy = /* @__PURE__ */ new jr();
class yu extends Dn {
  constructor(e = new gn(), t = new os()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let r = 1, o = t.count; r < o; r++)
        PA.fromBufferAttribute(t, r - 1), LA.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += PA.distanceTo(LA);
      e.setAttribute("lineDistance", new Ot(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, o = e.params.Line.threshold, l = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), dy.copy(n.boundingSphere), dy.applyMatrix4(r), dy.radius += o, e.ray.intersectsSphere(dy) === !1) return;
    DA.copy(r).invert(), US.copy(e.ray).applyMatrix4(DA);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), d = u * u, h = new j(), m = new j(), g = new j(), y = new j(), _ = this.isLineSegments ? 2 : 1, E = n.index, T = n.attributes.position;
    if (E !== null) {
      const M = Math.max(0, l.start), C = Math.min(E.count, l.start + l.count);
      for (let A = M, N = C - 1; A < N; A += _) {
        const z = E.getX(A), I = E.getX(A + 1);
        if (h.fromBufferAttribute(T, z), m.fromBufferAttribute(T, I), US.distanceSqToSegment(h, m, y, g) > d) continue;
        y.applyMatrix4(this.matrixWorld);
        const W = e.ray.origin.distanceTo(y);
        W < e.near || W > e.far || t.push({
          distance: W,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: g.clone().applyMatrix4(this.matrixWorld),
          index: A,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const M = Math.max(0, l.start), C = Math.min(T.count, l.start + l.count);
      for (let A = M, N = C - 1; A < N; A += _) {
        if (h.fromBufferAttribute(T, A), m.fromBufferAttribute(T, A + 1), US.distanceSqToSegment(h, m, y, g) > d) continue;
        y.applyMatrix4(this.matrixWorld);
        const I = e.ray.origin.distanceTo(y);
        I < e.near || I > e.far || t.push({
          distance: I,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: g.clone().applyMatrix4(this.matrixWorld),
          index: A,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = r.length; o < l; o++) {
          const u = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
}
const NA = /* @__PURE__ */ new j(), UA = /* @__PURE__ */ new j();
class So extends yu {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let r = 0, o = t.count; r < o; r += 2)
        NA.fromBufferAttribute(t, r), UA.fromBufferAttribute(t, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + NA.distanceTo(UA);
      e.setAttribute("lineDistance", new Ot(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class lL extends yu {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class JE extends Yr {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Tt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const OA = /* @__PURE__ */ new $t(), $M = /* @__PURE__ */ new Gc(), hy = /* @__PURE__ */ new jr(), py = /* @__PURE__ */ new j();
class uL extends Dn {
  constructor(e = new gn(), t = new JE()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, o = e.params.Points.threshold, l = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), hy.copy(n.boundingSphere), hy.applyMatrix4(r), hy.radius += o, e.ray.intersectsSphere(hy) === !1) return;
    OA.copy(r).invert(), $M.copy(e.ray).applyMatrix4(OA);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), d = u * u, h = n.index, g = n.attributes.position;
    if (h !== null) {
      const y = Math.max(0, l.start), _ = Math.min(h.count, l.start + l.count);
      for (let E = y, w = _; E < w; E++) {
        const T = h.getX(E);
        py.fromBufferAttribute(g, T), IA(py, T, d, r, e, t, this);
      }
    } else {
      const y = Math.max(0, l.start), _ = Math.min(g.count, l.start + l.count);
      for (let E = y, w = _; E < w; E++)
        py.fromBufferAttribute(g, E), IA(py, E, d, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = r.length; o < l; o++) {
          const u = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = o;
        }
      }
    }
  }
}
function IA(i, e, t, n, r, o, l) {
  const u = $M.distanceSqToPoint(i);
  if (u < t) {
    const d = new j();
    $M.closestPointToPoint(i, d), d.applyMatrix4(n);
    const h = r.ray.origin.distanceTo(d);
    if (h < r.near || h > r.far) return;
    o.push({
      distance: h,
      distanceToRay: Math.sqrt(u),
      point: d,
      index: e,
      face: null,
      object: l
    });
  }
}
class UH extends Fi {
  constructor(e, t, n, r, o, l, u, d, h) {
    super(e, t, n, r, o, l, u, d, h), this.isVideoTexture = !0, this.minFilter = l !== void 0 ? l : Oi, this.magFilter = o !== void 0 ? o : Oi, this.generateMipmaps = !1;
    const m = this;
    function g() {
      m.needsUpdate = !0, e.requestVideoFrameCallback(g);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(g);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class OH extends Fi {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Ui, this.minFilter = Ui, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class _0 extends Fi {
  constructor(e, t, n, r, o, l, u, d, h, m, g, y) {
    super(null, l, u, d, h, m, r, o, g, y), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class IH extends _0 {
  constructor(e, t, n, r, o, l) {
    super(e, t, n, o, l), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = Wr;
  }
}
class FH extends _0 {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, al), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class zH extends Fi {
  constructor(e, t, n, r, o, l, u, d, h) {
    super(e, t, n, r, o, l, u, d, h), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Ga {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, r = this.getPoint(0), o = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      n = this.getPoint(l / e), o += n.distanceTo(r), t.push(o), r = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let r = 0;
    const o = n.length;
    let l;
    t ? l = t : l = e * n[o - 1];
    let u = 0, d = o - 1, h;
    for (; u <= d; )
      if (r = Math.floor(u + (d - u) / 2), h = n[r] - l, h < 0)
        u = r + 1;
      else if (h > 0)
        d = r - 1;
      else {
        d = r;
        break;
      }
    if (r = d, n[r] === l)
      return r / (o - 1);
    const m = n[r], y = n[r + 1] - m, _ = (l - m) / y;
    return (r + _) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let r = e - 1e-4, o = e + 1e-4;
    r < 0 && (r = 0), o > 1 && (o = 1);
    const l = this.getPoint(r), u = this.getPoint(o), d = t || (l.isVector2 ? new Oe() : new j());
    return d.copy(u).sub(l).normalize(), d;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new j(), r = [], o = [], l = [], u = new j(), d = new $t();
    for (let _ = 0; _ <= e; _++) {
      const E = _ / e;
      r[_] = this.getTangentAt(E, new j());
    }
    o[0] = new j(), l[0] = new j();
    let h = Number.MAX_VALUE;
    const m = Math.abs(r[0].x), g = Math.abs(r[0].y), y = Math.abs(r[0].z);
    m <= h && (h = m, n.set(1, 0, 0)), g <= h && (h = g, n.set(0, 1, 0)), y <= h && n.set(0, 0, 1), u.crossVectors(r[0], n).normalize(), o[0].crossVectors(r[0], u), l[0].crossVectors(r[0], o[0]);
    for (let _ = 1; _ <= e; _++) {
      if (o[_] = o[_ - 1].clone(), l[_] = l[_ - 1].clone(), u.crossVectors(r[_ - 1], r[_]), u.length() > Number.EPSILON) {
        u.normalize();
        const E = Math.acos(Mi(r[_ - 1].dot(r[_]), -1, 1));
        o[_].applyMatrix4(d.makeRotationAxis(u, E));
      }
      l[_].crossVectors(r[_], o[_]);
    }
    if (t === !0) {
      let _ = Math.acos(Mi(o[0].dot(o[e]), -1, 1));
      _ /= e, r[0].dot(u.crossVectors(o[0], o[e])) > 0 && (_ = -_);
      for (let E = 1; E <= e; E++)
        o[E].applyMatrix4(d.makeRotationAxis(r[E], _ * E)), l[E].crossVectors(r[E], o[E]);
    }
    return {
      tangents: r,
      normals: o,
      binormals: l
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class S0 extends Ga {
  constructor(e = 0, t = 0, n = 1, r = 1, o = 0, l = Math.PI * 2, u = !1, d = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = u, this.aRotation = d;
  }
  getPoint(e, t) {
    const n = t || new Oe(), r = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += r;
    for (; o > r; ) o -= r;
    o < Number.EPSILON && (l ? o = 0 : o = r), this.aClockwise === !0 && !l && (o === r ? o = -r : o = o - r);
    const u = this.aStartAngle + e * o;
    let d = this.aX + this.xRadius * Math.cos(u), h = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const m = Math.cos(this.aRotation), g = Math.sin(this.aRotation), y = d - this.aX, _ = h - this.aY;
      d = y * m - _ * g + this.aX, h = y * g + _ * m + this.aY;
    }
    return n.set(d, h);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class cL extends S0 {
  constructor(e, t, n, r, o, l) {
    super(e, t, n, n, r, o, l), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function QE() {
  let i = 0, e = 0, t = 0, n = 0;
  function r(o, l, u, d) {
    i = o, e = u, t = -3 * o + 3 * l - 2 * u - d, n = 2 * o - 2 * l + u + d;
  }
  return {
    initCatmullRom: function(o, l, u, d, h) {
      r(l, u, h * (u - o), h * (d - l));
    },
    initNonuniformCatmullRom: function(o, l, u, d, h, m, g) {
      let y = (l - o) / h - (u - o) / (h + m) + (u - l) / m, _ = (u - l) / m - (d - l) / (m + g) + (d - u) / g;
      y *= m, _ *= m, r(l, u, y, _);
    },
    calc: function(o) {
      const l = o * o, u = l * o;
      return i + e * o + t * l + n * u;
    }
  };
}
const my = /* @__PURE__ */ new j(), OS = /* @__PURE__ */ new QE(), IS = /* @__PURE__ */ new QE(), FS = /* @__PURE__ */ new QE();
class fL extends Ga {
  constructor(e = [], t = !1, n = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r;
  }
  getPoint(e, t = new j()) {
    const n = t, r = this.points, o = r.length, l = (o - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(l), d = l - u;
    this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / o) + 1) * o : d === 0 && u === o - 1 && (u = o - 2, d = 1);
    let h, m;
    this.closed || u > 0 ? h = r[(u - 1) % o] : (my.subVectors(r[0], r[1]).add(r[0]), h = my);
    const g = r[u % o], y = r[(u + 1) % o];
    if (this.closed || u + 2 < o ? m = r[(u + 2) % o] : (my.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), m = my), this.curveType === "centripetal" || this.curveType === "chordal") {
      const _ = this.curveType === "chordal" ? 0.5 : 0.25;
      let E = Math.pow(h.distanceToSquared(g), _), w = Math.pow(g.distanceToSquared(y), _), T = Math.pow(y.distanceToSquared(m), _);
      w < 1e-4 && (w = 1), E < 1e-4 && (E = w), T < 1e-4 && (T = w), OS.initNonuniformCatmullRom(h.x, g.x, y.x, m.x, E, w, T), IS.initNonuniformCatmullRom(h.y, g.y, y.y, m.y, E, w, T), FS.initNonuniformCatmullRom(h.z, g.z, y.z, m.z, E, w, T);
    } else this.curveType === "catmullrom" && (OS.initCatmullRom(h.x, g.x, y.x, m.x, this.tension), IS.initCatmullRom(h.y, g.y, y.y, m.y, this.tension), FS.initCatmullRom(h.z, g.z, y.z, m.z, this.tension));
    return n.set(
      OS.calc(d),
      IS.calc(d),
      FS.calc(d)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new j().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function FA(i, e, t, n, r) {
  const o = (n - e) * 0.5, l = (r - t) * 0.5, u = i * i, d = i * u;
  return (2 * t - 2 * n + o + l) * d + (-3 * t + 3 * n - 2 * o - l) * u + o * i + t;
}
function BH(i, e) {
  const t = 1 - i;
  return t * t * e;
}
function VH(i, e) {
  return 2 * (1 - i) * i * e;
}
function HH(i, e) {
  return i * i * e;
}
function $p(i, e, t, n) {
  return BH(i, e) + VH(i, t) + HH(i, n);
}
function kH(i, e) {
  const t = 1 - i;
  return t * t * t * e;
}
function GH(i, e) {
  const t = 1 - i;
  return 3 * t * t * i * e;
}
function WH(i, e) {
  return 3 * (1 - i) * i * i * e;
}
function XH(i, e) {
  return i * i * i * e;
}
function em(i, e, t, n, r) {
  return kH(i, e) + GH(i, t) + WH(i, n) + XH(i, r);
}
class $E extends Ga {
  constructor(e = new Oe(), t = new Oe(), n = new Oe(), r = new Oe()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  getPoint(e, t = new Oe()) {
    const n = t, r = this.v0, o = this.v1, l = this.v2, u = this.v3;
    return n.set(
      em(e, r.x, o.x, l.x, u.x),
      em(e, r.y, o.y, l.y, u.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class dL extends Ga {
  constructor(e = new j(), t = new j(), n = new j(), r = new j()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  getPoint(e, t = new j()) {
    const n = t, r = this.v0, o = this.v1, l = this.v2, u = this.v3;
    return n.set(
      em(e, r.x, o.x, l.x, u.x),
      em(e, r.y, o.y, l.y, u.y),
      em(e, r.z, o.z, l.z, u.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class eb extends Ga {
  constructor(e = new Oe(), t = new Oe()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Oe()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Oe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class hL extends Ga {
  constructor(e = new j(), t = new j()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new j()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new j()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class tb extends Ga {
  constructor(e = new Oe(), t = new Oe(), n = new Oe()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Oe()) {
    const n = t, r = this.v0, o = this.v1, l = this.v2;
    return n.set(
      $p(e, r.x, o.x, l.x),
      $p(e, r.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class nb extends Ga {
  constructor(e = new j(), t = new j(), n = new j()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new j()) {
    const n = t, r = this.v0, o = this.v1, l = this.v2;
    return n.set(
      $p(e, r.x, o.x, l.x),
      $p(e, r.y, o.y, l.y),
      $p(e, r.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class ib extends Ga {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Oe()) {
    const n = t, r = this.points, o = (r.length - 1) * e, l = Math.floor(o), u = o - l, d = r[l === 0 ? l : l - 1], h = r[l], m = r[l > r.length - 2 ? r.length - 1 : l + 1], g = r[l > r.length - 3 ? r.length - 1 : l + 2];
    return n.set(
      FA(u, d.x, h.x, m.x, g.x),
      FA(u, d.y, h.y, m.y, g.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new Oe().fromArray(r));
    }
    return this;
  }
}
var Jy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: cL,
  CatmullRomCurve3: fL,
  CubicBezierCurve: $E,
  CubicBezierCurve3: dL,
  EllipseCurve: S0,
  LineCurve: eb,
  LineCurve3: hL,
  QuadraticBezierCurve: tb,
  QuadraticBezierCurve3: nb,
  SplineCurve: ib
});
class pL extends Ga {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Jy[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), r = this.getCurveLengths();
    let o = 0;
    for (; o < r.length; ) {
      if (r[o] >= n) {
        const l = r[o] - n, u = this.curves[o], d = u.getLength(), h = d === 0 ? 0 : 1 - l / d;
        return u.getPointAt(h, t);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let r = 0, o = this.curves; r < o.length; r++) {
      const l = o[r], u = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, d = l.getPoints(u);
      for (let h = 0; h < d.length; h++) {
        const m = d[h];
        n && n.equals(m) || (t.push(m), n = m);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(new Jy[r.type]().fromJSON(r));
    }
    return this;
  }
}
class ym extends pL {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Oe(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new eb(this.currentPoint.clone(), new Oe(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, r) {
    const o = new tb(
      this.currentPoint.clone(),
      new Oe(e, t),
      new Oe(n, r)
    );
    return this.curves.push(o), this.currentPoint.set(n, r), this;
  }
  bezierCurveTo(e, t, n, r, o, l) {
    const u = new $E(
      this.currentPoint.clone(),
      new Oe(e, t),
      new Oe(n, r),
      new Oe(o, l)
    );
    return this.curves.push(u), this.currentPoint.set(o, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new ib(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, r, o, l) {
    const u = this.currentPoint.x, d = this.currentPoint.y;
    return this.absarc(
      e + u,
      t + d,
      n,
      r,
      o,
      l
    ), this;
  }
  absarc(e, t, n, r, o, l) {
    return this.absellipse(e, t, n, n, r, o, l), this;
  }
  ellipse(e, t, n, r, o, l, u, d) {
    const h = this.currentPoint.x, m = this.currentPoint.y;
    return this.absellipse(e + h, t + m, n, r, o, l, u, d), this;
  }
  absellipse(e, t, n, r, o, l, u, d) {
    const h = new S0(e, t, n, r, o, l, u, d);
    if (this.curves.length > 0) {
      const g = h.getPoint(0);
      g.equals(this.currentPoint) || this.lineTo(g.x, g.y);
    }
    this.curves.push(h);
    const m = h.getPoint(1);
    return this.currentPoint.copy(m), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Fm extends gn {
  constructor(e = [new Oe(0, -0.5), new Oe(0.5, 0), new Oe(0, 0.5)], t = 12, n = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: r
    }, t = Math.floor(t), r = Mi(r, 0, Math.PI * 2);
    const o = [], l = [], u = [], d = [], h = [], m = 1 / t, g = new j(), y = new Oe(), _ = new j(), E = new j(), w = new j();
    let T = 0, M = 0;
    for (let C = 0; C <= e.length - 1; C++)
      switch (C) {
        case 0:
          T = e[C + 1].x - e[C].x, M = e[C + 1].y - e[C].y, _.x = M * 1, _.y = -T, _.z = M * 0, w.copy(_), _.normalize(), d.push(_.x, _.y, _.z);
          break;
        case e.length - 1:
          d.push(w.x, w.y, w.z);
          break;
        default:
          T = e[C + 1].x - e[C].x, M = e[C + 1].y - e[C].y, _.x = M * 1, _.y = -T, _.z = M * 0, E.copy(_), _.x += w.x, _.y += w.y, _.z += w.z, _.normalize(), d.push(_.x, _.y, _.z), w.copy(E);
      }
    for (let C = 0; C <= t; C++) {
      const A = n + C * m * r, N = Math.sin(A), z = Math.cos(A);
      for (let I = 0; I <= e.length - 1; I++) {
        g.x = e[I].x * N, g.y = e[I].y, g.z = e[I].x * z, l.push(g.x, g.y, g.z), y.x = C / t, y.y = I / (e.length - 1), u.push(y.x, y.y);
        const V = d[3 * I + 0] * N, W = d[3 * I + 1], U = d[3 * I + 0] * z;
        h.push(V, W, U);
      }
    }
    for (let C = 0; C < t; C++)
      for (let A = 0; A < e.length - 1; A++) {
        const N = A + C * e.length, z = N, I = N + e.length, V = N + e.length + 1, W = N + 1;
        o.push(z, I, W), o.push(V, W, I);
      }
    this.setIndex(o), this.setAttribute("position", new Ot(l, 3)), this.setAttribute("uv", new Ot(u, 2)), this.setAttribute("normal", new Ot(h, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fm(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class M0 extends Fm {
  constructor(e = 1, t = 1, n = 4, r = 8) {
    const o = new ym();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0), o.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(o.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: r
    };
  }
  static fromJSON(e) {
    return new M0(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class E0 extends gn {
  constructor(e = 1, t = 32, n = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: r
    }, t = Math.max(3, t);
    const o = [], l = [], u = [], d = [], h = new j(), m = new Oe();
    l.push(0, 0, 0), u.push(0, 0, 1), d.push(0.5, 0.5);
    for (let g = 0, y = 3; g <= t; g++, y += 3) {
      const _ = n + g / t * r;
      h.x = e * Math.cos(_), h.y = e * Math.sin(_), l.push(h.x, h.y, h.z), u.push(0, 0, 1), m.x = (l[y] / e + 1) / 2, m.y = (l[y + 1] / e + 1) / 2, d.push(m.x, m.y);
    }
    for (let g = 1; g <= t; g++)
      o.push(g, g + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Ot(l, 3)), this.setAttribute("normal", new Ot(u, 3)), this.setAttribute("uv", new Ot(d, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new E0(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class uh extends gn {
  constructor(e = 1, t = 1, n = 1, r = 32, o = 1, l = !1, u = 0, d = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: r,
      heightSegments: o,
      openEnded: l,
      thetaStart: u,
      thetaLength: d
    };
    const h = this;
    r = Math.floor(r), o = Math.floor(o);
    const m = [], g = [], y = [], _ = [];
    let E = 0;
    const w = [], T = n / 2;
    let M = 0;
    C(), l === !1 && (e > 0 && A(!0), t > 0 && A(!1)), this.setIndex(m), this.setAttribute("position", new Ot(g, 3)), this.setAttribute("normal", new Ot(y, 3)), this.setAttribute("uv", new Ot(_, 2));
    function C() {
      const N = new j(), z = new j();
      let I = 0;
      const V = (t - e) / n;
      for (let W = 0; W <= o; W++) {
        const U = [], O = W / o, q = O * (t - e) + e;
        for (let le = 0; le <= r; le++) {
          const ye = le / r, K = ye * d + u, oe = Math.sin(K), ie = Math.cos(K);
          z.x = q * oe, z.y = -O * n + T, z.z = q * ie, g.push(z.x, z.y, z.z), N.set(oe, V, ie).normalize(), y.push(N.x, N.y, N.z), _.push(ye, 1 - O), U.push(E++);
        }
        w.push(U);
      }
      for (let W = 0; W < r; W++)
        for (let U = 0; U < o; U++) {
          const O = w[U][W], q = w[U + 1][W], le = w[U + 1][W + 1], ye = w[U][W + 1];
          m.push(O, q, ye), m.push(q, le, ye), I += 6;
        }
      h.addGroup(M, I, 0), M += I;
    }
    function A(N) {
      const z = E, I = new Oe(), V = new j();
      let W = 0;
      const U = N === !0 ? e : t, O = N === !0 ? 1 : -1;
      for (let le = 1; le <= r; le++)
        g.push(0, T * O, 0), y.push(0, O, 0), _.push(0.5, 0.5), E++;
      const q = E;
      for (let le = 0; le <= r; le++) {
        const K = le / r * d + u, oe = Math.cos(K), ie = Math.sin(K);
        V.x = U * ie, V.y = T * O, V.z = U * oe, g.push(V.x, V.y, V.z), y.push(0, O, 0), I.x = oe * 0.5 + 0.5, I.y = ie * 0.5 * O + 0.5, _.push(I.x, I.y), E++;
      }
      for (let le = 0; le < r; le++) {
        const ye = z + le, K = q + le;
        N === !0 ? m.push(K, K + 1, ye) : m.push(K + 1, K, ye), W += 3;
      }
      h.addGroup(M, W, N === !0 ? 1 : 2), M += W;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uh(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class b0 extends uh {
  constructor(e = 1, t = 1, n = 32, r = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(0, e, t, n, r, o, l, u), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: r,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
  }
  static fromJSON(e) {
    return new b0(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Eu extends gn {
  constructor(e = [], t = [], n = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: r
    };
    const o = [], l = [];
    u(r), h(n), m(), this.setAttribute("position", new Ot(o, 3)), this.setAttribute("normal", new Ot(o.slice(), 3)), this.setAttribute("uv", new Ot(l, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(C) {
      const A = new j(), N = new j(), z = new j();
      for (let I = 0; I < t.length; I += 3)
        _(t[I + 0], A), _(t[I + 1], N), _(t[I + 2], z), d(A, N, z, C);
    }
    function d(C, A, N, z) {
      const I = z + 1, V = [];
      for (let W = 0; W <= I; W++) {
        V[W] = [];
        const U = C.clone().lerp(N, W / I), O = A.clone().lerp(N, W / I), q = I - W;
        for (let le = 0; le <= q; le++)
          le === 0 && W === I ? V[W][le] = U : V[W][le] = U.clone().lerp(O, le / q);
      }
      for (let W = 0; W < I; W++)
        for (let U = 0; U < 2 * (I - W) - 1; U++) {
          const O = Math.floor(U / 2);
          U % 2 === 0 ? (y(V[W][O + 1]), y(V[W + 1][O]), y(V[W][O])) : (y(V[W][O + 1]), y(V[W + 1][O + 1]), y(V[W + 1][O]));
        }
    }
    function h(C) {
      const A = new j();
      for (let N = 0; N < o.length; N += 3)
        A.x = o[N + 0], A.y = o[N + 1], A.z = o[N + 2], A.normalize().multiplyScalar(C), o[N + 0] = A.x, o[N + 1] = A.y, o[N + 2] = A.z;
    }
    function m() {
      const C = new j();
      for (let A = 0; A < o.length; A += 3) {
        C.x = o[A + 0], C.y = o[A + 1], C.z = o[A + 2];
        const N = T(C) / 2 / Math.PI + 0.5, z = M(C) / Math.PI + 0.5;
        l.push(N, 1 - z);
      }
      E(), g();
    }
    function g() {
      for (let C = 0; C < l.length; C += 6) {
        const A = l[C + 0], N = l[C + 2], z = l[C + 4], I = Math.max(A, N, z), V = Math.min(A, N, z);
        I > 0.9 && V < 0.1 && (A < 0.2 && (l[C + 0] += 1), N < 0.2 && (l[C + 2] += 1), z < 0.2 && (l[C + 4] += 1));
      }
    }
    function y(C) {
      o.push(C.x, C.y, C.z);
    }
    function _(C, A) {
      const N = C * 3;
      A.x = e[N + 0], A.y = e[N + 1], A.z = e[N + 2];
    }
    function E() {
      const C = new j(), A = new j(), N = new j(), z = new j(), I = new Oe(), V = new Oe(), W = new Oe();
      for (let U = 0, O = 0; U < o.length; U += 9, O += 6) {
        C.set(o[U + 0], o[U + 1], o[U + 2]), A.set(o[U + 3], o[U + 4], o[U + 5]), N.set(o[U + 6], o[U + 7], o[U + 8]), I.set(l[O + 0], l[O + 1]), V.set(l[O + 2], l[O + 3]), W.set(l[O + 4], l[O + 5]), z.copy(C).add(A).add(N).divideScalar(3);
        const q = T(z);
        w(I, O + 0, C, q), w(V, O + 2, A, q), w(W, O + 4, N, q);
      }
    }
    function w(C, A, N, z) {
      z < 0 && C.x === 1 && (l[A] = C.x - 1), N.x === 0 && N.z === 0 && (l[A] = z / 2 / Math.PI + 0.5);
    }
    function T(C) {
      return Math.atan2(C.z, -C.x);
    }
    function M(C) {
      return Math.atan2(-C.y, Math.sqrt(C.x * C.x + C.z * C.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Eu(e.vertices, e.indices, e.radius, e.details);
  }
}
class T0 extends Eu {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = 1 / n, o = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -n,
      0,
      -r,
      n,
      0,
      r,
      -n,
      0,
      r,
      n,
      // (1/, , 0)
      -r,
      -n,
      0,
      -r,
      n,
      0,
      r,
      -n,
      0,
      r,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -r,
      n,
      0,
      -r,
      -n,
      0,
      r,
      n,
      0,
      r
    ], l = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(o, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new T0(e.radius, e.detail);
  }
}
const vy = /* @__PURE__ */ new j(), gy = /* @__PURE__ */ new j(), zS = /* @__PURE__ */ new j(), yy = /* @__PURE__ */ new Ms();
class mL extends gn {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const r = Math.pow(10, 4), o = Math.cos(Uc * t), l = e.getIndex(), u = e.getAttribute("position"), d = l ? l.count : u.count, h = [0, 0, 0], m = ["a", "b", "c"], g = new Array(3), y = {}, _ = [];
      for (let E = 0; E < d; E += 3) {
        l ? (h[0] = l.getX(E), h[1] = l.getX(E + 1), h[2] = l.getX(E + 2)) : (h[0] = E, h[1] = E + 1, h[2] = E + 2);
        const { a: w, b: T, c: M } = yy;
        if (w.fromBufferAttribute(u, h[0]), T.fromBufferAttribute(u, h[1]), M.fromBufferAttribute(u, h[2]), yy.getNormal(zS), g[0] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`, g[1] = `${Math.round(T.x * r)},${Math.round(T.y * r)},${Math.round(T.z * r)}`, g[2] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(M.z * r)}`, !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
          for (let C = 0; C < 3; C++) {
            const A = (C + 1) % 3, N = g[C], z = g[A], I = yy[m[C]], V = yy[m[A]], W = `${N}_${z}`, U = `${z}_${N}`;
            U in y && y[U] ? (zS.dot(y[U].normal) <= o && (_.push(I.x, I.y, I.z), _.push(V.x, V.y, V.z)), y[U] = null) : W in y || (y[W] = {
              index0: h[C],
              index1: h[A],
              normal: zS.clone()
            });
          }
      }
      for (const E in y)
        if (y[E]) {
          const { index0: w, index1: T } = y[E];
          vy.fromBufferAttribute(u, w), gy.fromBufferAttribute(u, T), _.push(vy.x, vy.y, vy.z), _.push(gy.x, gy.y, gy.z);
        }
      this.setAttribute("position", new Ot(_, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Fc extends ym {
  constructor(e) {
    super(e), this.uuid = ks(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(new ym().fromJSON(r));
    }
    return this;
  }
}
const jH = {
  triangulate: function(i, e, t = 2) {
    const n = e && e.length, r = n ? e[0] * t : i.length;
    let o = vL(i, 0, r, t, !0);
    const l = [];
    if (!o || o.next === o.prev) return l;
    let u, d, h, m, g, y, _;
    if (n && (o = JH(i, e, o, t)), i.length > 80 * t) {
      u = h = i[0], d = m = i[1];
      for (let E = t; E < r; E += t)
        g = i[E], y = i[E + 1], g < u && (u = g), y < d && (d = y), g > h && (h = g), y > m && (m = y);
      _ = Math.max(h - u, m - d), _ = _ !== 0 ? 32767 / _ : 0;
    }
    return xm(o, l, t, u, d, _, 0), l;
  }
};
function vL(i, e, t, n, r) {
  let o, l;
  if (r === lk(i, e, t, n) > 0)
    for (o = e; o < t; o += n) l = zA(o, i[o], i[o + 1], l);
  else
    for (o = t - n; o >= e; o -= n) l = zA(o, i[o], i[o + 1], l);
  return l && w0(l, l.next) && (Sm(l), l = l.next), l;
}
function Hc(i, e) {
  if (!i) return i;
  e || (e = i);
  let t = i, n;
  do
    if (n = !1, !t.steiner && (w0(t, t.next) || ci(t.prev, t, t.next) === 0)) {
      if (Sm(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function xm(i, e, t, n, r, o, l) {
  if (!i) return;
  !l && o && nk(i, n, r, o);
  let u = i, d, h;
  for (; i.prev !== i.next; ) {
    if (d = i.prev, h = i.next, o ? qH(i, n, r, o) : YH(i)) {
      e.push(d.i / t | 0), e.push(i.i / t | 0), e.push(h.i / t | 0), Sm(i), i = h.next, u = h.next;
      continue;
    }
    if (i = h, i === u) {
      l ? l === 1 ? (i = ZH(Hc(i), e, t), xm(i, e, t, n, r, o, 2)) : l === 2 && KH(i, e, t, n, r, o) : xm(Hc(i), e, t, n, r, o, 1);
      break;
    }
  }
}
function YH(i) {
  const e = i.prev, t = i, n = i.next;
  if (ci(e, t, n) >= 0) return !1;
  const r = e.x, o = t.x, l = n.x, u = e.y, d = t.y, h = n.y, m = r < o ? r < l ? r : l : o < l ? o : l, g = u < d ? u < h ? u : h : d < h ? d : h, y = r > o ? r > l ? r : l : o > l ? o : l, _ = u > d ? u > h ? u : h : d > h ? d : h;
  let E = n.next;
  for (; E !== e; ) {
    if (E.x >= m && E.x <= y && E.y >= g && E.y <= _ && Xd(r, u, o, d, l, h, E.x, E.y) && ci(E.prev, E, E.next) >= 0) return !1;
    E = E.next;
  }
  return !0;
}
function qH(i, e, t, n) {
  const r = i.prev, o = i, l = i.next;
  if (ci(r, o, l) >= 0) return !1;
  const u = r.x, d = o.x, h = l.x, m = r.y, g = o.y, y = l.y, _ = u < d ? u < h ? u : h : d < h ? d : h, E = m < g ? m < y ? m : y : g < y ? g : y, w = u > d ? u > h ? u : h : d > h ? d : h, T = m > g ? m > y ? m : y : g > y ? g : y, M = eE(_, E, e, t, n), C = eE(w, T, e, t, n);
  let A = i.prevZ, N = i.nextZ;
  for (; A && A.z >= M && N && N.z <= C; ) {
    if (A.x >= _ && A.x <= w && A.y >= E && A.y <= T && A !== r && A !== l && Xd(u, m, d, g, h, y, A.x, A.y) && ci(A.prev, A, A.next) >= 0 || (A = A.prevZ, N.x >= _ && N.x <= w && N.y >= E && N.y <= T && N !== r && N !== l && Xd(u, m, d, g, h, y, N.x, N.y) && ci(N.prev, N, N.next) >= 0)) return !1;
    N = N.nextZ;
  }
  for (; A && A.z >= M; ) {
    if (A.x >= _ && A.x <= w && A.y >= E && A.y <= T && A !== r && A !== l && Xd(u, m, d, g, h, y, A.x, A.y) && ci(A.prev, A, A.next) >= 0) return !1;
    A = A.prevZ;
  }
  for (; N && N.z <= C; ) {
    if (N.x >= _ && N.x <= w && N.y >= E && N.y <= T && N !== r && N !== l && Xd(u, m, d, g, h, y, N.x, N.y) && ci(N.prev, N, N.next) >= 0) return !1;
    N = N.nextZ;
  }
  return !0;
}
function ZH(i, e, t) {
  let n = i;
  do {
    const r = n.prev, o = n.next.next;
    !w0(r, o) && gL(r, n, n.next, o) && _m(r, o) && _m(o, r) && (e.push(r.i / t | 0), e.push(n.i / t | 0), e.push(o.i / t | 0), Sm(n), Sm(n.next), n = i = o), n = n.next;
  } while (n !== i);
  return Hc(n);
}
function KH(i, e, t, n, r, o) {
  let l = i;
  do {
    let u = l.next.next;
    for (; u !== l.prev; ) {
      if (l.i !== u.i && sk(l, u)) {
        let d = yL(l, u);
        l = Hc(l, l.next), d = Hc(d, d.next), xm(l, e, t, n, r, o, 0), xm(d, e, t, n, r, o, 0);
        return;
      }
      u = u.next;
    }
    l = l.next;
  } while (l !== i);
}
function JH(i, e, t, n) {
  const r = [];
  let o, l, u, d, h;
  for (o = 0, l = e.length; o < l; o++)
    u = e[o] * n, d = o < l - 1 ? e[o + 1] * n : i.length, h = vL(i, u, d, n, !1), h === h.next && (h.steiner = !0), r.push(rk(h));
  for (r.sort(QH), o = 0; o < r.length; o++)
    t = $H(r[o], t);
  return t;
}
function QH(i, e) {
  return i.x - e.x;
}
function $H(i, e) {
  const t = ek(i, e);
  if (!t)
    return e;
  const n = yL(t, i);
  return Hc(n, n.next), Hc(t, t.next);
}
function ek(i, e) {
  let t = e, n = -1 / 0, r;
  const o = i.x, l = i.y;
  do {
    if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
      const y = t.x + (l - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (y <= o && y > n && (n = y, r = t.x < t.next.x ? t : t.next, y === o))
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const u = r, d = r.x, h = r.y;
  let m = 1 / 0, g;
  t = r;
  do
    o >= t.x && t.x >= d && o !== t.x && Xd(l < h ? o : n, l, d, h, l < h ? n : o, l, t.x, t.y) && (g = Math.abs(l - t.y) / (o - t.x), _m(t, i) && (g < m || g === m && (t.x > r.x || t.x === r.x && tk(r, t))) && (r = t, m = g)), t = t.next;
  while (t !== u);
  return r;
}
function tk(i, e) {
  return ci(i.prev, i, e.prev) < 0 && ci(e.next, i, i.next) < 0;
}
function nk(i, e, t, n) {
  let r = i;
  do
    r.z === 0 && (r.z = eE(r.x, r.y, e, t, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, ik(r);
}
function ik(i) {
  let e, t, n, r, o, l, u, d, h = 1;
  do {
    for (t = i, i = null, o = null, l = 0; t; ) {
      for (l++, n = t, u = 0, e = 0; e < h && (u++, n = n.nextZ, !!n); e++)
        ;
      for (d = h; u > 0 || d > 0 && n; )
        u !== 0 && (d === 0 || !n || t.z <= n.z) ? (r = t, t = t.nextZ, u--) : (r = n, n = n.nextZ, d--), o ? o.nextZ = r : i = r, r.prevZ = o, o = r;
      t = n;
    }
    o.nextZ = null, h *= 2;
  } while (l > 1);
  return i;
}
function eE(i, e, t, n, r) {
  return i = (i - t) * r | 0, e = (e - n) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function rk(i) {
  let e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function Xd(i, e, t, n, r, o, l, u) {
  return (r - l) * (e - u) >= (i - l) * (o - u) && (i - l) * (n - u) >= (t - l) * (e - u) && (t - l) * (o - u) >= (r - l) * (n - u);
}
function sk(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !ak(i, e) && // dones't intersect other edges
  (_m(i, e) && _m(e, i) && ok(i, e) && // locally visible
  (ci(i.prev, i, e.prev) || ci(i, e.prev, e)) || // does not create opposite-facing sectors
  w0(i, e) && ci(i.prev, i, i.next) > 0 && ci(e.prev, e, e.next) > 0);
}
function ci(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function w0(i, e) {
  return i.x === e.x && i.y === e.y;
}
function gL(i, e, t, n) {
  const r = _y(ci(i, e, t)), o = _y(ci(i, e, n)), l = _y(ci(t, n, i)), u = _y(ci(t, n, e));
  return !!(r !== o && l !== u || r === 0 && xy(i, t, e) || o === 0 && xy(i, n, e) || l === 0 && xy(t, i, n) || u === 0 && xy(t, e, n));
}
function xy(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function _y(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function ak(i, e) {
  let t = i;
  do {
    if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && gL(t, t.next, i, e)) return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function _m(i, e) {
  return ci(i.prev, i, i.next) < 0 ? ci(i, e, i.next) >= 0 && ci(i, i.prev, e) >= 0 : ci(i, e, i.prev) < 0 || ci(i, i.next, e) < 0;
}
function ok(i, e) {
  let t = i, n = !1;
  const r = (i.x + e.x) / 2, o = (i.y + e.y) / 2;
  do
    t.y > o != t.next.y > o && t.next.y !== t.y && r < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== i);
  return n;
}
function yL(i, e) {
  const t = new tE(i.i, i.x, i.y), n = new tE(e.i, e.x, e.y), r = i.next, o = e.prev;
  return i.next = e, e.prev = i, t.next = r, r.prev = t, n.next = t, t.prev = n, o.next = n, n.prev = o, n;
}
function zA(i, e, t, n) {
  const r = new tE(i, e, t);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function Sm(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function tE(i, e, t) {
  this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function lk(i, e, t, n) {
  let r = 0;
  for (let o = e, l = t - n; o < t; o += n)
    r += (i[l] - i[o]) * (i[o + 1] + i[l + 1]), l = o;
  return r;
}
class go {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let r = t - 1, o = 0; o < t; r = o++)
      n += e[r].x * e[o].y - e[o].x * e[r].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return go.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], r = [], o = [];
    BA(e), VA(n, e);
    let l = e.length;
    t.forEach(BA);
    for (let d = 0; d < t.length; d++)
      r.push(l), l += t[d].length, VA(n, t[d]);
    const u = jH.triangulate(n, r);
    for (let d = 0; d < u.length; d += 3)
      o.push(u.slice(d, d + 3));
    return o;
  }
}
function BA(i) {
  const e = i.length;
  e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function VA(i, e) {
  for (let t = 0; t < e.length; t++)
    i.push(e[t].x), i.push(e[t].y);
}
class A0 extends gn {
  constructor(e = new Fc([new Oe(0.5, 0.5), new Oe(-0.5, 0.5), new Oe(-0.5, -0.5), new Oe(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, r = [], o = [];
    for (let u = 0, d = e.length; u < d; u++) {
      const h = e[u];
      l(h);
    }
    this.setAttribute("position", new Ot(r, 3)), this.setAttribute("uv", new Ot(o, 2)), this.computeVertexNormals();
    function l(u) {
      const d = [], h = t.curveSegments !== void 0 ? t.curveSegments : 12, m = t.steps !== void 0 ? t.steps : 1, g = t.depth !== void 0 ? t.depth : 1;
      let y = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, _ = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, E = t.bevelSize !== void 0 ? t.bevelSize : _ - 0.1, w = t.bevelOffset !== void 0 ? t.bevelOffset : 0, T = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const M = t.extrudePath, C = t.UVGenerator !== void 0 ? t.UVGenerator : uk;
      let A, N = !1, z, I, V, W;
      M && (A = M.getSpacedPoints(m), N = !0, y = !1, z = M.computeFrenetFrames(m, !1), I = new j(), V = new j(), W = new j()), y || (T = 0, _ = 0, E = 0, w = 0);
      const U = u.extractPoints(h);
      let O = U.shape;
      const q = U.holes;
      if (!go.isClockWise(O)) {
        O = O.reverse();
        for (let J = 0, Be = q.length; J < Be; J++) {
          const Pe = q[J];
          go.isClockWise(Pe) && (q[J] = Pe.reverse());
        }
      }
      const ye = go.triangulateShape(O, q), K = O;
      for (let J = 0, Be = q.length; J < Be; J++) {
        const Pe = q[J];
        O = O.concat(Pe);
      }
      function oe(J, Be, Pe) {
        return Be || console.error("THREE.ExtrudeGeometry: vec does not exist"), J.clone().addScaledVector(Be, Pe);
      }
      const ie = O.length, Ee = ye.length;
      function Q(J, Be, Pe) {
        let He, Re, _t;
        const rt = J.x - Be.x, G = J.y - Be.y, B = Pe.x - J.x, ce = Pe.y - J.y, Fe = rt * rt + G * G, ze = rt * ce - G * B;
        if (Math.abs(ze) > Number.EPSILON) {
          const Ie = Math.sqrt(Fe), Mt = Math.sqrt(B * B + ce * ce), it = Be.x - G / Ie, mt = Be.y + rt / Ie, Dt = Pe.x - ce / Mt, Ht = Pe.y + B / Mt, de = ((Dt - it) * ce - (Ht - mt) * B) / (rt * ce - G * B);
          He = it + rt * de - J.x, Re = mt + G * de - J.y;
          const nt = He * He + Re * Re;
          if (nt <= 2)
            return new Oe(He, Re);
          _t = Math.sqrt(nt / 2);
        } else {
          let Ie = !1;
          rt > Number.EPSILON ? B > Number.EPSILON && (Ie = !0) : rt < -Number.EPSILON ? B < -Number.EPSILON && (Ie = !0) : Math.sign(G) === Math.sign(ce) && (Ie = !0), Ie ? (He = -G, Re = rt, _t = Math.sqrt(Fe)) : (He = rt, Re = G, _t = Math.sqrt(Fe / 2));
        }
        return new Oe(He / _t, Re / _t);
      }
      const se = [];
      for (let J = 0, Be = K.length, Pe = Be - 1, He = J + 1; J < Be; J++, Pe++, He++)
        Pe === Be && (Pe = 0), He === Be && (He = 0), se[J] = Q(K[J], K[Pe], K[He]);
      const re = [];
      let ue, Le = se.concat();
      for (let J = 0, Be = q.length; J < Be; J++) {
        const Pe = q[J];
        ue = [];
        for (let He = 0, Re = Pe.length, _t = Re - 1, rt = He + 1; He < Re; He++, _t++, rt++)
          _t === Re && (_t = 0), rt === Re && (rt = 0), ue[He] = Q(Pe[He], Pe[_t], Pe[rt]);
        re.push(ue), Le = Le.concat(ue);
      }
      for (let J = 0; J < T; J++) {
        const Be = J / T, Pe = _ * Math.cos(Be * Math.PI / 2), He = E * Math.sin(Be * Math.PI / 2) + w;
        for (let Re = 0, _t = K.length; Re < _t; Re++) {
          const rt = oe(K[Re], se[Re], He);
          $e(rt.x, rt.y, -Pe);
        }
        for (let Re = 0, _t = q.length; Re < _t; Re++) {
          const rt = q[Re];
          ue = re[Re];
          for (let G = 0, B = rt.length; G < B; G++) {
            const ce = oe(rt[G], ue[G], He);
            $e(ce.x, ce.y, -Pe);
          }
        }
      }
      const pe = E + w;
      for (let J = 0; J < ie; J++) {
        const Be = y ? oe(O[J], Le[J], pe) : O[J];
        N ? (V.copy(z.normals[0]).multiplyScalar(Be.x), I.copy(z.binormals[0]).multiplyScalar(Be.y), W.copy(A[0]).add(V).add(I), $e(W.x, W.y, W.z)) : $e(Be.x, Be.y, 0);
      }
      for (let J = 1; J <= m; J++)
        for (let Be = 0; Be < ie; Be++) {
          const Pe = y ? oe(O[Be], Le[Be], pe) : O[Be];
          N ? (V.copy(z.normals[J]).multiplyScalar(Pe.x), I.copy(z.binormals[J]).multiplyScalar(Pe.y), W.copy(A[J]).add(V).add(I), $e(W.x, W.y, W.z)) : $e(Pe.x, Pe.y, g / m * J);
        }
      for (let J = T - 1; J >= 0; J--) {
        const Be = J / T, Pe = _ * Math.cos(Be * Math.PI / 2), He = E * Math.sin(Be * Math.PI / 2) + w;
        for (let Re = 0, _t = K.length; Re < _t; Re++) {
          const rt = oe(K[Re], se[Re], He);
          $e(rt.x, rt.y, g + Pe);
        }
        for (let Re = 0, _t = q.length; Re < _t; Re++) {
          const rt = q[Re];
          ue = re[Re];
          for (let G = 0, B = rt.length; G < B; G++) {
            const ce = oe(rt[G], ue[G], He);
            N ? $e(ce.x, ce.y + A[m - 1].y, A[m - 1].x + Pe) : $e(ce.x, ce.y, g + Pe);
          }
        }
      }
      Ae(), qe();
      function Ae() {
        const J = r.length / 3;
        if (y) {
          let Be = 0, Pe = ie * Be;
          for (let He = 0; He < Ee; He++) {
            const Re = ye[He];
            Rt(Re[2] + Pe, Re[1] + Pe, Re[0] + Pe);
          }
          Be = m + T * 2, Pe = ie * Be;
          for (let He = 0; He < Ee; He++) {
            const Re = ye[He];
            Rt(Re[0] + Pe, Re[1] + Pe, Re[2] + Pe);
          }
        } else {
          for (let Be = 0; Be < Ee; Be++) {
            const Pe = ye[Be];
            Rt(Pe[2], Pe[1], Pe[0]);
          }
          for (let Be = 0; Be < Ee; Be++) {
            const Pe = ye[Be];
            Rt(Pe[0] + ie * m, Pe[1] + ie * m, Pe[2] + ie * m);
          }
        }
        n.addGroup(J, r.length / 3 - J, 0);
      }
      function qe() {
        const J = r.length / 3;
        let Be = 0;
        je(K, Be), Be += K.length;
        for (let Pe = 0, He = q.length; Pe < He; Pe++) {
          const Re = q[Pe];
          je(Re, Be), Be += Re.length;
        }
        n.addGroup(J, r.length / 3 - J, 1);
      }
      function je(J, Be) {
        let Pe = J.length;
        for (; --Pe >= 0; ) {
          const He = Pe;
          let Re = Pe - 1;
          Re < 0 && (Re = J.length - 1);
          for (let _t = 0, rt = m + T * 2; _t < rt; _t++) {
            const G = ie * _t, B = ie * (_t + 1), ce = Be + He + G, Fe = Be + Re + G, ze = Be + Re + B, Ie = Be + He + B;
            Ut(ce, Fe, ze, Ie);
          }
        }
      }
      function $e(J, Be, Pe) {
        d.push(J), d.push(Be), d.push(Pe);
      }
      function Rt(J, Be, Pe) {
        ot(J), ot(Be), ot(Pe);
        const He = r.length / 3, Re = C.generateTopUV(n, r, He - 3, He - 2, He - 1);
        pt(Re[0]), pt(Re[1]), pt(Re[2]);
      }
      function Ut(J, Be, Pe, He) {
        ot(J), ot(Be), ot(He), ot(Be), ot(Pe), ot(He);
        const Re = r.length / 3, _t = C.generateSideWallUV(n, r, Re - 6, Re - 3, Re - 2, Re - 1);
        pt(_t[0]), pt(_t[1]), pt(_t[3]), pt(_t[1]), pt(_t[2]), pt(_t[3]);
      }
      function ot(J) {
        r.push(d[J * 3 + 0]), r.push(d[J * 3 + 1]), r.push(d[J * 3 + 2]);
      }
      function pt(J) {
        o.push(J.x), o.push(J.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return ck(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let o = 0, l = e.shapes.length; o < l; o++) {
      const u = t[e.shapes[o]];
      n.push(u);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new Jy[r.type]().fromJSON(r)), new A0(n, e.options);
  }
}
const uk = {
  generateTopUV: function(i, e, t, n, r) {
    const o = e[t * 3], l = e[t * 3 + 1], u = e[n * 3], d = e[n * 3 + 1], h = e[r * 3], m = e[r * 3 + 1];
    return [
      new Oe(o, l),
      new Oe(u, d),
      new Oe(h, m)
    ];
  },
  generateSideWallUV: function(i, e, t, n, r, o) {
    const l = e[t * 3], u = e[t * 3 + 1], d = e[t * 3 + 2], h = e[n * 3], m = e[n * 3 + 1], g = e[n * 3 + 2], y = e[r * 3], _ = e[r * 3 + 1], E = e[r * 3 + 2], w = e[o * 3], T = e[o * 3 + 1], M = e[o * 3 + 2];
    return Math.abs(u - m) < Math.abs(l - h) ? [
      new Oe(l, 1 - d),
      new Oe(h, 1 - g),
      new Oe(y, 1 - E),
      new Oe(w, 1 - M)
    ] : [
      new Oe(u, 1 - d),
      new Oe(m, 1 - g),
      new Oe(_, 1 - E),
      new Oe(T, 1 - M)
    ];
  }
};
function ck(i, e, t) {
  if (t.shapes = [], Array.isArray(i))
    for (let n = 0, r = i.length; n < r; n++) {
      const o = i[n];
      t.shapes.push(o.uuid);
    }
  else
    t.shapes.push(i.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class R0 extends Eu {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], o = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(r, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new R0(e.radius, e.detail);
  }
}
class zm extends Eu {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new zm(e.radius, e.detail);
  }
}
class C0 extends gn {
  constructor(e = 0.5, t = 1, n = 32, r = 1, o = 0, l = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: r,
      thetaStart: o,
      thetaLength: l
    }, n = Math.max(3, n), r = Math.max(1, r);
    const u = [], d = [], h = [], m = [];
    let g = e;
    const y = (t - e) / r, _ = new j(), E = new Oe();
    for (let w = 0; w <= r; w++) {
      for (let T = 0; T <= n; T++) {
        const M = o + T / n * l;
        _.x = g * Math.cos(M), _.y = g * Math.sin(M), d.push(_.x, _.y, _.z), h.push(0, 0, 1), E.x = (_.x / t + 1) / 2, E.y = (_.y / t + 1) / 2, m.push(E.x, E.y);
      }
      g += y;
    }
    for (let w = 0; w < r; w++) {
      const T = w * (n + 1);
      for (let M = 0; M < n; M++) {
        const C = M + T, A = C, N = C + n + 1, z = C + n + 2, I = C + 1;
        u.push(A, N, I), u.push(N, z, I);
      }
    }
    this.setIndex(u), this.setAttribute("position", new Ot(d, 3)), this.setAttribute("normal", new Ot(h, 3)), this.setAttribute("uv", new Ot(m, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new C0(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class P0 extends gn {
  constructor(e = new Fc([new Oe(0, 0.5), new Oe(-0.5, -0.5), new Oe(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], r = [], o = [], l = [];
    let u = 0, d = 0;
    if (Array.isArray(e) === !1)
      h(e);
    else
      for (let m = 0; m < e.length; m++)
        h(e[m]), this.addGroup(u, d, m), u += d, d = 0;
    this.setIndex(n), this.setAttribute("position", new Ot(r, 3)), this.setAttribute("normal", new Ot(o, 3)), this.setAttribute("uv", new Ot(l, 2));
    function h(m) {
      const g = r.length / 3, y = m.extractPoints(t);
      let _ = y.shape;
      const E = y.holes;
      go.isClockWise(_) === !1 && (_ = _.reverse());
      for (let T = 0, M = E.length; T < M; T++) {
        const C = E[T];
        go.isClockWise(C) === !0 && (E[T] = C.reverse());
      }
      const w = go.triangulateShape(_, E);
      for (let T = 0, M = E.length; T < M; T++) {
        const C = E[T];
        _ = _.concat(C);
      }
      for (let T = 0, M = _.length; T < M; T++) {
        const C = _[T];
        r.push(C.x, C.y, 0), o.push(0, 0, 1), l.push(C.x, C.y);
      }
      for (let T = 0, M = w.length; T < M; T++) {
        const C = w[T], A = C[0] + g, N = C[1] + g, z = C[2] + g;
        n.push(A, N, z), d += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return fk(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const l = t[e.shapes[r]];
      n.push(l);
    }
    return new P0(n, e.curveSegments);
  }
}
function fk(i, e) {
  if (e.shapes = [], Array.isArray(i))
    for (let t = 0, n = i.length; t < n; t++) {
      const r = i[t];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(i.uuid);
  return e;
}
class Bm extends gn {
  constructor(e = 1, t = 32, n = 16, r = 0, o = Math.PI * 2, l = 0, u = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: r,
      phiLength: o,
      thetaStart: l,
      thetaLength: u
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const d = Math.min(l + u, Math.PI);
    let h = 0;
    const m = [], g = new j(), y = new j(), _ = [], E = [], w = [], T = [];
    for (let M = 0; M <= n; M++) {
      const C = [], A = M / n;
      let N = 0;
      M === 0 && l === 0 ? N = 0.5 / t : M === n && d === Math.PI && (N = -0.5 / t);
      for (let z = 0; z <= t; z++) {
        const I = z / t;
        g.x = -e * Math.cos(r + I * o) * Math.sin(l + A * u), g.y = e * Math.cos(l + A * u), g.z = e * Math.sin(r + I * o) * Math.sin(l + A * u), E.push(g.x, g.y, g.z), y.copy(g).normalize(), w.push(y.x, y.y, y.z), T.push(I + N, 1 - A), C.push(h++);
      }
      m.push(C);
    }
    for (let M = 0; M < n; M++)
      for (let C = 0; C < t; C++) {
        const A = m[M][C + 1], N = m[M][C], z = m[M + 1][C], I = m[M + 1][C + 1];
        (M !== 0 || l > 0) && _.push(A, N, I), (M !== n - 1 || d < Math.PI) && _.push(N, z, I);
      }
    this.setIndex(_), this.setAttribute("position", new Ot(E, 3)), this.setAttribute("normal", new Ot(w, 3)), this.setAttribute("uv", new Ot(T, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Bm(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class L0 extends Eu {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new L0(e.radius, e.detail);
  }
}
class D0 extends gn {
  constructor(e = 1, t = 0.4, n = 12, r = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: r,
      arc: o
    }, n = Math.floor(n), r = Math.floor(r);
    const l = [], u = [], d = [], h = [], m = new j(), g = new j(), y = new j();
    for (let _ = 0; _ <= n; _++)
      for (let E = 0; E <= r; E++) {
        const w = E / r * o, T = _ / n * Math.PI * 2;
        g.x = (e + t * Math.cos(T)) * Math.cos(w), g.y = (e + t * Math.cos(T)) * Math.sin(w), g.z = t * Math.sin(T), u.push(g.x, g.y, g.z), m.x = e * Math.cos(w), m.y = e * Math.sin(w), y.subVectors(g, m).normalize(), d.push(y.x, y.y, y.z), h.push(E / r), h.push(_ / n);
      }
    for (let _ = 1; _ <= n; _++)
      for (let E = 1; E <= r; E++) {
        const w = (r + 1) * _ + E - 1, T = (r + 1) * (_ - 1) + E - 1, M = (r + 1) * (_ - 1) + E, C = (r + 1) * _ + E;
        l.push(w, T, C), l.push(T, M, C);
      }
    this.setIndex(l), this.setAttribute("position", new Ot(u, 3)), this.setAttribute("normal", new Ot(d, 3)), this.setAttribute("uv", new Ot(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new D0(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class N0 extends gn {
  constructor(e = 1, t = 0.4, n = 64, r = 8, o = 2, l = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: r,
      p: o,
      q: l
    }, n = Math.floor(n), r = Math.floor(r);
    const u = [], d = [], h = [], m = [], g = new j(), y = new j(), _ = new j(), E = new j(), w = new j(), T = new j(), M = new j();
    for (let A = 0; A <= n; ++A) {
      const N = A / n * o * Math.PI * 2;
      C(N, o, l, e, _), C(N + 0.01, o, l, e, E), T.subVectors(E, _), M.addVectors(E, _), w.crossVectors(T, M), M.crossVectors(w, T), w.normalize(), M.normalize();
      for (let z = 0; z <= r; ++z) {
        const I = z / r * Math.PI * 2, V = -t * Math.cos(I), W = t * Math.sin(I);
        g.x = _.x + (V * M.x + W * w.x), g.y = _.y + (V * M.y + W * w.y), g.z = _.z + (V * M.z + W * w.z), d.push(g.x, g.y, g.z), y.subVectors(g, _).normalize(), h.push(y.x, y.y, y.z), m.push(A / n), m.push(z / r);
      }
    }
    for (let A = 1; A <= n; A++)
      for (let N = 1; N <= r; N++) {
        const z = (r + 1) * (A - 1) + (N - 1), I = (r + 1) * A + (N - 1), V = (r + 1) * A + N, W = (r + 1) * (A - 1) + N;
        u.push(z, I, W), u.push(I, V, W);
      }
    this.setIndex(u), this.setAttribute("position", new Ot(d, 3)), this.setAttribute("normal", new Ot(h, 3)), this.setAttribute("uv", new Ot(m, 2));
    function C(A, N, z, I, V) {
      const W = Math.cos(A), U = Math.sin(A), O = z / N * A, q = Math.cos(O);
      V.x = I * (2 + q) * 0.5 * W, V.y = I * (2 + q) * U * 0.5, V.z = I * Math.sin(O) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new N0(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class U0 extends gn {
  constructor(e = new nb(new j(-1, -1, 0), new j(-1, 1, 0), new j(1, 1, 0)), t = 64, n = 1, r = 8, o = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: r,
      closed: o
    };
    const l = e.computeFrenetFrames(t, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    const u = new j(), d = new j(), h = new Oe();
    let m = new j();
    const g = [], y = [], _ = [], E = [];
    w(), this.setIndex(E), this.setAttribute("position", new Ot(g, 3)), this.setAttribute("normal", new Ot(y, 3)), this.setAttribute("uv", new Ot(_, 2));
    function w() {
      for (let A = 0; A < t; A++)
        T(A);
      T(o === !1 ? t : 0), C(), M();
    }
    function T(A) {
      m = e.getPointAt(A / t, m);
      const N = l.normals[A], z = l.binormals[A];
      for (let I = 0; I <= r; I++) {
        const V = I / r * Math.PI * 2, W = Math.sin(V), U = -Math.cos(V);
        d.x = U * N.x + W * z.x, d.y = U * N.y + W * z.y, d.z = U * N.z + W * z.z, d.normalize(), y.push(d.x, d.y, d.z), u.x = m.x + n * d.x, u.y = m.y + n * d.y, u.z = m.z + n * d.z, g.push(u.x, u.y, u.z);
      }
    }
    function M() {
      for (let A = 1; A <= t; A++)
        for (let N = 1; N <= r; N++) {
          const z = (r + 1) * (A - 1) + (N - 1), I = (r + 1) * A + (N - 1), V = (r + 1) * A + N, W = (r + 1) * (A - 1) + N;
          E.push(z, I, W), E.push(I, V, W);
        }
    }
    function C() {
      for (let A = 0; A <= t; A++)
        for (let N = 0; N <= r; N++)
          h.x = A / t, h.y = N / r, _.push(h.x, h.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new U0(
      new Jy[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class xL extends gn {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), r = new j(), o = new j();
      if (e.index !== null) {
        const l = e.attributes.position, u = e.index;
        let d = e.groups;
        d.length === 0 && (d = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let h = 0, m = d.length; h < m; ++h) {
          const g = d[h], y = g.start, _ = g.count;
          for (let E = y, w = y + _; E < w; E += 3)
            for (let T = 0; T < 3; T++) {
              const M = u.getX(E + T), C = u.getX(E + (T + 1) % 3);
              r.fromBufferAttribute(l, M), o.fromBufferAttribute(l, C), HA(r, o, n) === !0 && (t.push(r.x, r.y, r.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let u = 0, d = l.count / 3; u < d; u++)
          for (let h = 0; h < 3; h++) {
            const m = 3 * u + h, g = 3 * u + (h + 1) % 3;
            r.fromBufferAttribute(l, m), o.fromBufferAttribute(l, g), HA(r, o, n) === !0 && (t.push(r.x, r.y, r.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new Ot(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function HA(i, e, t) {
  const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
  return t.has(n) === !0 || t.has(r) === !0 ? !1 : (t.add(n), t.add(r), !0);
}
var kA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Wc,
  CapsuleGeometry: M0,
  CircleGeometry: E0,
  ConeGeometry: b0,
  CylinderGeometry: uh,
  DodecahedronGeometry: T0,
  EdgesGeometry: mL,
  ExtrudeGeometry: A0,
  IcosahedronGeometry: R0,
  LatheGeometry: Fm,
  OctahedronGeometry: zm,
  PlaneGeometry: Im,
  PolyhedronGeometry: Eu,
  RingGeometry: C0,
  ShapeGeometry: P0,
  SphereGeometry: Bm,
  TetrahedronGeometry: L0,
  TorusGeometry: D0,
  TorusKnotGeometry: N0,
  TubeGeometry: U0,
  WireframeGeometry: xL
});
class _L extends Yr {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Tt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class SL extends _o {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class rb extends Yr {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Tt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Su, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class sb extends rb {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Oe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Mi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Tt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Tt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Tt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class ML extends Yr {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Tt(16777215), this.specular = new Tt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Su, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Pm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class EL extends Yr {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Tt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Su, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class bL extends Yr {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Su, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class TL extends Yr {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Su, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Pm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class wL extends Yr {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Tt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Su, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class AL extends os {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Lc(i, e, t) {
  return !i || // let 'undefined' and 'null' pass
  !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
}
function RL(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function CL(i) {
  function e(r, o) {
    return i[r] - i[o];
  }
  const t = i.length, n = new Array(t);
  for (let r = 0; r !== t; ++r) n[r] = r;
  return n.sort(e), n;
}
function nE(i, e, t) {
  const n = i.length, r = new i.constructor(n);
  for (let o = 0, l = 0; l !== n; ++o) {
    const u = t[o] * e;
    for (let d = 0; d !== e; ++d)
      r[l++] = i[u + d];
  }
  return r;
}
function ab(i, e, t, n) {
  let r = 1, o = i[0];
  for (; o !== void 0 && o[n] === void 0; )
    o = i[r++];
  if (o === void 0) return;
  let l = o[n];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        l = o[n], l !== void 0 && (e.push(o.time), t.push.apply(t, l)), o = i[r++];
      while (o !== void 0);
    else if (l.toArray !== void 0)
      do
        l = o[n], l !== void 0 && (e.push(o.time), l.toArray(t, t.length)), o = i[r++];
      while (o !== void 0);
    else
      do
        l = o[n], l !== void 0 && (e.push(o.time), t.push(l)), o = i[r++];
      while (o !== void 0);
}
function dk(i, e, t, n, r = 30) {
  const o = i.clone();
  o.name = e;
  const l = [];
  for (let d = 0; d < o.tracks.length; ++d) {
    const h = o.tracks[d], m = h.getValueSize(), g = [], y = [];
    for (let _ = 0; _ < h.times.length; ++_) {
      const E = h.times[_] * r;
      if (!(E < t || E >= n)) {
        g.push(h.times[_]);
        for (let w = 0; w < m; ++w)
          y.push(h.values[_ * m + w]);
      }
    }
    g.length !== 0 && (h.times = Lc(g, h.times.constructor), h.values = Lc(y, h.values.constructor), l.push(h));
  }
  o.tracks = l;
  let u = 1 / 0;
  for (let d = 0; d < o.tracks.length; ++d)
    u > o.tracks[d].times[0] && (u = o.tracks[d].times[0]);
  for (let d = 0; d < o.tracks.length; ++d)
    o.tracks[d].shift(-1 * u);
  return o.resetDuration(), o;
}
function hk(i, e = 0, t = i, n = 30) {
  n <= 0 && (n = 30);
  const r = t.tracks.length, o = e / n;
  for (let l = 0; l < r; ++l) {
    const u = t.tracks[l], d = u.ValueTypeName;
    if (d === "bool" || d === "string") continue;
    const h = i.tracks.find(function(M) {
      return M.name === u.name && M.ValueTypeName === d;
    });
    if (h === void 0) continue;
    let m = 0;
    const g = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = g / 3);
    let y = 0;
    const _ = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (y = _ / 3);
    const E = u.times.length - 1;
    let w;
    if (o <= u.times[0]) {
      const M = m, C = g - m;
      w = u.values.slice(M, C);
    } else if (o >= u.times[E]) {
      const M = E * g + m, C = M + g - m;
      w = u.values.slice(M, C);
    } else {
      const M = u.createInterpolant(), C = m, A = g - m;
      M.evaluate(o), w = M.resultBuffer.slice(C, A);
    }
    d === "quaternion" && new Xr().fromArray(w).normalize().conjugate().toArray(w);
    const T = h.times.length;
    for (let M = 0; M < T; ++M) {
      const C = M * _ + y;
      if (d === "quaternion")
        Xr.multiplyQuaternionsFlat(
          h.values,
          C,
          w,
          0,
          h.values,
          C
        );
      else {
        const A = _ - y * 2;
        for (let N = 0; N < A; ++N)
          h.values[C + N] -= w[N];
      }
    }
  }
  return i.blendMode = OE, i;
}
const pk = {
  convertArray: Lc,
  isTypedArray: RL,
  getKeyframeOrder: CL,
  sortedArray: nE,
  flattenJSON: ab,
  subclip: dk,
  makeClipAdditive: hk
};
class Vm {
  constructor(e, t, n, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, r = t[n], o = t[n - 1];
    e: {
      t: {
        let l;
        n: {
          i: if (!(e < r)) {
            for (let u = n + 2; ; ) {
              if (r === void 0) {
                if (e < o) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === u) break;
              if (o = r, r = t[++n], e < r)
                break t;
            }
            l = t.length;
            break n;
          }
          if (!(e >= o)) {
            const u = t[1];
            e < u && (n = 2, o = u);
            for (let d = n - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === d) break;
              if (r = o, o = t[--n - 1], e >= o)
                break t;
            }
            l = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < l; ) {
          const u = n + l >>> 1;
          e < t[u] ? l = u : n = u + 1;
        }
        if (r = t[n], o = t[n - 1], o === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, o, r);
    }
    return this.interpolate_(n, o, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, o = e * r;
    for (let l = 0; l !== r; ++l)
      t[l] = n[o + l];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class PL extends Vm {
  constructor(e, t, n, r) {
    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: Rc,
      endingEnd: Rc
    };
  }
  intervalChanged_(e, t, n) {
    const r = this.parameterPositions;
    let o = e - 2, l = e + 1, u = r[o], d = r[l];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case Cc:
          o = e, u = 2 * t - n;
          break;
        case dm:
          o = r.length - 2, u = t + r[o] - r[o + 1];
          break;
        default:
          o = e, u = n;
      }
    if (d === void 0)
      switch (this.getSettings_().endingEnd) {
        case Cc:
          l = e, d = 2 * n - t;
          break;
        case dm:
          l = 1, d = n + r[1] - r[0];
          break;
        default:
          l = e - 1, d = t;
      }
    const h = (n - t) * 0.5, m = this.valueSize;
    this._weightPrev = h / (t - u), this._weightNext = h / (d - n), this._offsetPrev = o * m, this._offsetNext = l * m;
  }
  interpolate_(e, t, n, r) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, d = e * u, h = d - u, m = this._offsetPrev, g = this._offsetNext, y = this._weightPrev, _ = this._weightNext, E = (n - t) / (r - t), w = E * E, T = w * E, M = -y * T + 2 * y * w - y * E, C = (1 + y) * T + (-1.5 - 2 * y) * w + (-0.5 + y) * E + 1, A = (-1 - _) * T + (1.5 + _) * w + 0.5 * E, N = _ * T - _ * w;
    for (let z = 0; z !== u; ++z)
      o[z] = M * l[m + z] + C * l[h + z] + A * l[d + z] + N * l[g + z];
    return o;
  }
}
class ob extends Vm {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, d = e * u, h = d - u, m = (n - t) / (r - t), g = 1 - m;
    for (let y = 0; y !== u; ++y)
      o[y] = l[h + y] * g + l[d + y] * m;
    return o;
  }
}
class LL extends Vm {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Wa {
  constructor(e, t, n, r) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Lc(t, this.TimeBufferType), this.values = Lc(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Lc(e.times, Array),
        values: Lc(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new LL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new ob(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new PL(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case cm:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case fm:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Hy:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return cm;
      case this.InterpolantFactoryMethodLinear:
        return fm;
      case this.InterpolantFactoryMethodSmooth:
        return Hy;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, r = n.length;
    let o = 0, l = r - 1;
    for (; o !== r && n[o] < e; )
      ++o;
    for (; l !== -1 && n[l] > t; )
      --l;
    if (++l, o !== 0 || l !== r) {
      o >= l && (l = Math.max(l, 1), o = l - 1);
      const u = this.getValueSize();
      this.times = n.slice(o, l), this.values = this.values.slice(o * u, l * u);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, r = this.values, o = n.length;
    o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let l = null;
    for (let u = 0; u !== o; u++) {
      const d = n[u];
      if (typeof d == "number" && isNaN(d)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, u, d), e = !1;
        break;
      }
      if (l !== null && l > d) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, u, d, l), e = !1;
        break;
      }
      l = d;
    }
    if (r !== void 0 && RL(r))
      for (let u = 0, d = r.length; u !== d; ++u) {
        const h = r[u];
        if (isNaN(h)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, u, h), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), r = this.getInterpolation() === Hy, o = e.length - 1;
    let l = 1;
    for (let u = 1; u < o; ++u) {
      let d = !1;
      const h = e[u], m = e[u + 1];
      if (h !== m && (u !== 1 || h !== e[0]))
        if (r)
          d = !0;
        else {
          const g = u * n, y = g - n, _ = g + n;
          for (let E = 0; E !== n; ++E) {
            const w = t[g + E];
            if (w !== t[y + E] || w !== t[_ + E]) {
              d = !0;
              break;
            }
          }
        }
      if (d) {
        if (u !== l) {
          e[l] = e[u];
          const g = u * n, y = l * n;
          for (let _ = 0; _ !== n; ++_)
            t[y + _] = t[g + _];
        }
        ++l;
      }
    }
    if (o > 0) {
      e[l] = e[o];
      for (let u = o * n, d = l * n, h = 0; h !== n; ++h)
        t[d + h] = t[u + h];
      ++l;
    }
    return l !== e.length ? (this.times = e.slice(0, l), this.values = t.slice(0, l * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, r = new n(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
Wa.prototype.TimeBufferType = Float32Array;
Wa.prototype.ValueBufferType = Float32Array;
Wa.prototype.DefaultInterpolation = fm;
class Xc extends Wa {
}
Xc.prototype.ValueTypeName = "bool";
Xc.prototype.ValueBufferType = Array;
Xc.prototype.DefaultInterpolation = cm;
Xc.prototype.InterpolantFactoryMethodLinear = void 0;
Xc.prototype.InterpolantFactoryMethodSmooth = void 0;
class lb extends Wa {
}
lb.prototype.ValueTypeName = "color";
class Mm extends Wa {
}
Mm.prototype.ValueTypeName = "number";
class DL extends Vm {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const o = this.resultBuffer, l = this.sampleValues, u = this.valueSize, d = (n - t) / (r - t);
    let h = e * u;
    for (let m = h + u; h !== m; h += 4)
      Xr.slerpFlat(o, 0, l, h - u, l, h, d);
    return o;
  }
}
class ch extends Wa {
  InterpolantFactoryMethodLinear(e) {
    return new DL(this.times, this.values, this.getValueSize(), e);
  }
}
ch.prototype.ValueTypeName = "quaternion";
ch.prototype.DefaultInterpolation = fm;
ch.prototype.InterpolantFactoryMethodSmooth = void 0;
class jc extends Wa {
}
jc.prototype.ValueTypeName = "string";
jc.prototype.ValueBufferType = Array;
jc.prototype.DefaultInterpolation = cm;
jc.prototype.InterpolantFactoryMethodLinear = void 0;
jc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Em extends Wa {
}
Em.prototype.ValueTypeName = "vector";
class bm {
  constructor(e, t = -1, n, r = d0) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = ks(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, r = 1 / (e.fps || 1);
    for (let l = 0, u = n.length; l !== u; ++l)
      t.push(vk(n[l]).scale(r));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return o.uuid = e.uuid, o;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let o = 0, l = n.length; o !== l; ++o)
      t.push(Wa.toJSON(n[o]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, n, r) {
    const o = t.length, l = [];
    for (let u = 0; u < o; u++) {
      let d = [], h = [];
      d.push(
        (u + o - 1) % o,
        u,
        (u + 1) % o
      ), h.push(0, 1, 0);
      const m = CL(d);
      d = nE(d, 1, m), h = nE(h, 1, m), !r && d[0] === 0 && (d.push(o), h.push(h[0])), l.push(
        new Mm(
          ".morphTargetInfluences[" + t[u].name + "]",
          d,
          h
        ).scale(1 / n)
      );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const r = e;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === t)
        return n[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const r = {}, o = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, d = e.length; u < d; u++) {
      const h = e[u], m = h.name.match(o);
      if (m && m.length > 1) {
        const g = m[1];
        let y = r[g];
        y || (r[g] = y = []), y.push(h);
      }
    }
    const l = [];
    for (const u in r)
      l.push(this.CreateFromMorphTargetSequence(u, r[u], t, n));
    return l;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(g, y, _, E, w) {
      if (_.length !== 0) {
        const T = [], M = [];
        ab(_, T, M, E), T.length !== 0 && w.push(new g(y, T, M));
      }
    }, r = [], o = e.name || "default", l = e.fps || 30, u = e.blendMode;
    let d = e.length || -1;
    const h = e.hierarchy || [];
    for (let g = 0; g < h.length; g++) {
      const y = h[g].keys;
      if (!(!y || y.length === 0))
        if (y[0].morphTargets) {
          const _ = {};
          let E;
          for (E = 0; E < y.length; E++)
            if (y[E].morphTargets)
              for (let w = 0; w < y[E].morphTargets.length; w++)
                _[y[E].morphTargets[w]] = -1;
          for (const w in _) {
            const T = [], M = [];
            for (let C = 0; C !== y[E].morphTargets.length; ++C) {
              const A = y[E];
              T.push(A.time), M.push(A.morphTarget === w ? 1 : 0);
            }
            r.push(new Mm(".morphTargetInfluence[" + w + "]", T, M));
          }
          d = _.length * l;
        } else {
          const _ = ".bones[" + t[g].name + "]";
          n(
            Em,
            _ + ".position",
            y,
            "pos",
            r
          ), n(
            ch,
            _ + ".quaternion",
            y,
            "rot",
            r
          ), n(
            Em,
            _ + ".scale",
            y,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(o, d, r, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const o = this.tracks[n];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function mk(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Mm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Em;
    case "color":
      return lb;
    case "quaternion":
      return ch;
    case "bool":
    case "boolean":
      return Xc;
    case "string":
      return jc;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function vk(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = mk(i.type);
  if (i.times === void 0) {
    const t = [], n = [];
    ab(i.keys, t, n, "value"), i.times = t, i.values = n;
  }
  return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
const el = {
  enabled: !1,
  files: {},
  add: function(i, e) {
    this.enabled !== !1 && (this.files[i] = e);
  },
  get: function(i) {
    if (this.enabled !== !1)
      return this.files[i];
  },
  remove: function(i) {
    delete this.files[i];
  },
  clear: function() {
    this.files = {};
  }
};
class ub {
  constructor(e, t, n) {
    const r = this;
    let o = !1, l = 0, u = 0, d;
    const h = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(m) {
      u++, o === !1 && r.onStart !== void 0 && r.onStart(m, l, u), o = !0;
    }, this.itemEnd = function(m) {
      l++, r.onProgress !== void 0 && r.onProgress(m, l, u), l === u && (o = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(m) {
      r.onError !== void 0 && r.onError(m);
    }, this.resolveURL = function(m) {
      return d ? d(m) : m;
    }, this.setURLModifier = function(m) {
      return d = m, this;
    }, this.addHandler = function(m, g) {
      return h.push(m, g), this;
    }, this.removeHandler = function(m) {
      const g = h.indexOf(m);
      return g !== -1 && h.splice(g, 2), this;
    }, this.getHandler = function(m) {
      for (let g = 0, y = h.length; g < y; g += 2) {
        const _ = h[g], E = h[g + 1];
        if (_.global && (_.lastIndex = 0), _.test(m))
          return E;
      }
      return null;
    };
  }
}
const NL = /* @__PURE__ */ new ub();
class Ts {
  constructor(e) {
    this.manager = e !== void 0 ? e : NL, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(r, o) {
      n.load(e, r, t, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Ts.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ko = {};
class gk extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class ol extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = el.get(e);
    if (o !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(o), this.manager.itemEnd(e);
      }, 0), o;
    if (Ko[e] !== void 0) {
      Ko[e].push({
        onLoad: t,
        onProgress: n,
        onError: r
      });
      return;
    }
    Ko[e] = [], Ko[e].push({
      onLoad: t,
      onProgress: n,
      onError: r
    });
    const l = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), u = this.mimeType, d = this.responseType;
    fetch(l).then((h) => {
      if (h.status === 200 || h.status === 0) {
        if (h.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || h.body === void 0 || h.body.getReader === void 0)
          return h;
        const m = Ko[e], g = h.body.getReader(), y = h.headers.get("Content-Length") || h.headers.get("X-File-Size"), _ = y ? parseInt(y) : 0, E = _ !== 0;
        let w = 0;
        const T = new ReadableStream({
          start(M) {
            C();
            function C() {
              g.read().then(({ done: A, value: N }) => {
                if (A)
                  M.close();
                else {
                  w += N.byteLength;
                  const z = new ProgressEvent("progress", { lengthComputable: E, loaded: w, total: _ });
                  for (let I = 0, V = m.length; I < V; I++) {
                    const W = m[I];
                    W.onProgress && W.onProgress(z);
                  }
                  M.enqueue(N), C();
                }
              });
            }
          }
        });
        return new Response(T);
      } else
        throw new gk(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h);
    }).then((h) => {
      switch (d) {
        case "arraybuffer":
          return h.arrayBuffer();
        case "blob":
          return h.blob();
        case "document":
          return h.text().then((m) => new DOMParser().parseFromString(m, u));
        case "json":
          return h.json();
        default:
          if (u === void 0)
            return h.text();
          {
            const g = /charset="?([^;"\s]*)"?/i.exec(u), y = g && g[1] ? g[1].toLowerCase() : void 0, _ = new TextDecoder(y);
            return h.arrayBuffer().then((E) => _.decode(E));
          }
      }
    }).then((h) => {
      el.add(e, h);
      const m = Ko[e];
      delete Ko[e];
      for (let g = 0, y = m.length; g < y; g++) {
        const _ = m[g];
        _.onLoad && _.onLoad(h);
      }
    }).catch((h) => {
      const m = Ko[e];
      if (m === void 0)
        throw this.manager.itemError(e), h;
      delete Ko[e];
      for (let g = 0, y = m.length; g < y; g++) {
        const _ = m[g];
        _.onError && _.onError(h);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class yk extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = this, l = new ol(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (d) {
        r ? r(d) : console.error(d), o.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const r = bm.parse(e[n]);
      t.push(r);
    }
    return t;
  }
}
class xk extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = this, l = [], u = new _0(), d = new ol(this.manager);
    d.setPath(this.path), d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setWithCredentials(o.withCredentials);
    let h = 0;
    function m(g) {
      d.load(e[g], function(y) {
        const _ = o.parse(y, !0);
        l[g] = {
          width: _.width,
          height: _.height,
          format: _.format,
          mipmaps: _.mipmaps
        }, h += 1, h === 6 && (_.mipmapCount === 1 && (u.minFilter = Oi), u.image = l, u.format = _.format, u.needsUpdate = !0, t && t(u));
      }, n, r);
    }
    if (Array.isArray(e))
      for (let g = 0, y = e.length; g < y; ++g)
        m(g);
    else
      d.load(e, function(g) {
        const y = o.parse(g, !0);
        if (y.isCubemap) {
          const _ = y.mipmaps.length / y.mipmapCount;
          for (let E = 0; E < _; E++) {
            l[E] = { mipmaps: [] };
            for (let w = 0; w < y.mipmapCount; w++)
              l[E].mipmaps.push(y.mipmaps[E * y.mipmapCount + w]), l[E].format = y.format, l[E].width = y.width, l[E].height = y.height;
          }
          u.image = l;
        } else
          u.image.width = y.width, u.image.height = y.height, u.mipmaps = y.mipmaps;
        y.mipmapCount === 1 && (u.minFilter = Oi), u.format = y.format, u.needsUpdate = !0, t && t(u);
      }, n, r);
    return u;
  }
}
class Tm extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = el.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const u = gm("img");
    function d() {
      m(), el.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function h(g) {
      m(), r && r(g), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function m() {
      u.removeEventListener("load", d, !1), u.removeEventListener("error", h, !1);
    }
    return u.addEventListener("load", d, !1), u.addEventListener("error", h, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (u.crossOrigin = this.crossOrigin), o.manager.itemStart(e), u.src = e, u;
  }
}
class _k extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = new Um();
    o.colorSpace = nr;
    const l = new Tm(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let u = 0;
    function d(h) {
      l.load(e[h], function(m) {
        o.images[h] = m, u++, u === 6 && (o.needsUpdate = !0, t && t(o));
      }, void 0, r);
    }
    for (let h = 0; h < e.length; ++h)
      d(h);
    return o;
  }
}
class Sk extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = this, l = new Ic(), u = new ol(this.manager);
    return u.setResponseType("arraybuffer"), u.setRequestHeader(this.requestHeader), u.setPath(this.path), u.setWithCredentials(o.withCredentials), u.load(e, function(d) {
      let h;
      try {
        h = o.parse(d);
      } catch (m) {
        if (r !== void 0)
          r(m);
        else {
          console.error(m);
          return;
        }
      }
      h.image !== void 0 ? l.image = h.image : h.data !== void 0 && (l.image.width = h.width, l.image.height = h.height, l.image.data = h.data), l.wrapS = h.wrapS !== void 0 ? h.wrapS : Wr, l.wrapT = h.wrapT !== void 0 ? h.wrapT : Wr, l.magFilter = h.magFilter !== void 0 ? h.magFilter : Oi, l.minFilter = h.minFilter !== void 0 ? h.minFilter : Oi, l.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1, h.colorSpace !== void 0 ? l.colorSpace = h.colorSpace : h.encoding !== void 0 && (l.encoding = h.encoding), h.flipY !== void 0 && (l.flipY = h.flipY), h.format !== void 0 && (l.format = h.format), h.type !== void 0 && (l.type = h.type), h.mipmaps !== void 0 && (l.mipmaps = h.mipmaps, l.minFilter = gu), h.mipmapCount === 1 && (l.minFilter = Oi), h.generateMipmaps !== void 0 && (l.generateMipmaps = h.generateMipmaps), l.needsUpdate = !0, t && t(l, h);
    }, n, r), l;
  }
}
class Mk extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = new Fi(), l = new Tm(this.manager);
    return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(u) {
      o.image = u, o.needsUpdate = !0, t !== void 0 && t(o);
    }, n, r), o;
  }
}
class bu extends Dn {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Tt(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class UL extends bu {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Dn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Tt(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const BS = /* @__PURE__ */ new $t(), GA = /* @__PURE__ */ new j(), WA = /* @__PURE__ */ new j();
class cb {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Oe(512, 512), this.map = null, this.mapPass = null, this.matrix = new $t(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Om(), this._frameExtents = new Oe(1, 1), this._viewportCount = 1, this._viewports = [
      new Bn(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    GA.setFromMatrixPosition(e.matrixWorld), t.position.copy(GA), WA.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(WA), t.updateMatrixWorld(), BS.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(BS), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(BS);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class Ek extends cb {
  constructor() {
    super(new Ii(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = eh * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, o = e.distance || t.far;
    (n !== t.fov || r !== t.aspect || o !== t.far) && (t.fov = n, t.aspect = r, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class OL extends bu {
  constructor(e, t, n = 0, r = Math.PI / 3, o = 0, l = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Dn.DEFAULT_UP), this.updateMatrix(), this.target = new Dn(), this.distance = n, this.angle = r, this.penumbra = o, this.decay = l, this.map = null, this.shadow = new Ek();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const XA = /* @__PURE__ */ new $t(), Vp = /* @__PURE__ */ new j(), VS = /* @__PURE__ */ new j();
class bk extends cb {
  constructor() {
    super(new Ii(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Oe(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Bn(2, 1, 1, 1),
      // negative X
      new Bn(0, 1, 1, 1),
      // positive Z
      new Bn(3, 1, 1, 1),
      // negative Z
      new Bn(1, 1, 1, 1),
      // positive Y
      new Bn(3, 0, 1, 1),
      // negative Y
      new Bn(1, 0, 1, 1)
    ], this._cubeDirections = [
      new j(1, 0, 0),
      new j(-1, 0, 0),
      new j(0, 0, 1),
      new j(0, 0, -1),
      new j(0, 1, 0),
      new j(0, -1, 0)
    ], this._cubeUps = [
      new j(0, 1, 0),
      new j(0, 1, 0),
      new j(0, 1, 0),
      new j(0, 1, 0),
      new j(0, 0, 1),
      new j(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, r = this.matrix, o = e.distance || n.far;
    o !== n.far && (n.far = o, n.updateProjectionMatrix()), Vp.setFromMatrixPosition(e.matrixWorld), n.position.copy(Vp), VS.copy(n.position), VS.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(VS), n.updateMatrixWorld(), r.makeTranslation(-Vp.x, -Vp.y, -Vp.z), XA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(XA);
  }
}
class IL extends bu {
  constructor(e, t, n = 0, r = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new bk();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Tk extends cb {
  constructor() {
    super(new hu(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class FL extends bu {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Dn.DEFAULT_UP), this.updateMatrix(), this.target = new Dn(), this.shadow = new Tk();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class zL extends bu {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class BL extends bu {
  constructor(e, t, n = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class VL {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new j());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, r = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * r), t.addScaledVector(l[2], 0.488603 * o), t.addScaledVector(l[3], 0.488603 * n), t.addScaledVector(l[4], 1.092548 * (n * r)), t.addScaledVector(l[5], 1.092548 * (r * o)), t.addScaledVector(l[6], 0.315392 * (3 * o * o - 1)), t.addScaledVector(l[7], 1.092548 * (n * o)), t.addScaledVector(l[8], 0.546274 * (n * n - r * r)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, r = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * r), t.addScaledVector(l[2], 2 * 0.511664 * o), t.addScaledVector(l[3], 2 * 0.511664 * n), t.addScaledVector(l[4], 2 * 0.429043 * n * r), t.addScaledVector(l[5], 2 * 0.429043 * r * o), t.addScaledVector(l[6], 0.743125 * o * o - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * n * o), t.addScaledVector(l[8], 0.429043 * (n * n - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].toArray(e, t + r * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, r = e.y, o = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * o, t[3] = 0.488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * o, t[6] = 0.315392 * (3 * o * o - 1), t[7] = 1.092548 * n * o, t[8] = 0.546274 * (n * n - r * r);
  }
}
class HL extends bu {
  constructor(e = new VL(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class O0 extends Ts {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, r) {
    const o = this, l = new ol(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (d) {
        r ? r(d) : console.error(d), o.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = this.textures;
    function n(o) {
      return t[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), t[o];
    }
    const r = O0.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Tt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const o in e.uniforms) {
        const l = e.uniforms[o];
        switch (r.uniforms[o] = {}, l.type) {
          case "t":
            r.uniforms[o].value = n(l.value);
            break;
          case "c":
            r.uniforms[o].value = new Tt().setHex(l.value);
            break;
          case "v2":
            r.uniforms[o].value = new Oe().fromArray(l.value);
            break;
          case "v3":
            r.uniforms[o].value = new j().fromArray(l.value);
            break;
          case "v4":
            r.uniforms[o].value = new Bn().fromArray(l.value);
            break;
          case "m3":
            r.uniforms[o].value = new vn().fromArray(l.value);
            break;
          case "m4":
            r.uniforms[o].value = new $t().fromArray(l.value);
            break;
          default:
            r.uniforms[o].value = l.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const o in e.extensions)
        r.extensions[o] = e.extensions[o];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = n(e.map)), e.matcap !== void 0 && (r.matcap = n(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]), r.normalScale = new Oe().fromArray(o);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Oe().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: _L,
      SpriteMaterial: ZE,
      RawShaderMaterial: SL,
      ShaderMaterial: _o,
      PointsMaterial: JE,
      MeshPhysicalMaterial: sb,
      MeshStandardMaterial: rb,
      MeshPhongMaterial: ML,
      MeshToonMaterial: EL,
      MeshNormalMaterial: bL,
      MeshLambertMaterial: TL,
      MeshDepthMaterial: XE,
      MeshDistanceMaterial: jE,
      MeshBasicMaterial: Mu,
      MeshMatcapMaterial: wL,
      LineDashedMaterial: AL,
      LineBasicMaterial: os,
      Material: Yr
    };
    return new t[e]();
  }
}
class iE {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, r = e.length; n < r; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class kL extends gn {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class GL extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = this, l = new ol(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(u) {
      try {
        t(o.parse(JSON.parse(u)));
      } catch (d) {
        r ? r(d) : console.error(d), o.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = {}, n = {};
    function r(_, E) {
      if (t[E] !== void 0) return t[E];
      const T = _.interleavedBuffers[E], M = o(_, T.buffer), C = Hd(T.type, M), A = new y0(C, T.stride);
      return A.uuid = T.uuid, t[E] = A, A;
    }
    function o(_, E) {
      if (n[E] !== void 0) return n[E];
      const T = _.arrayBuffers[E], M = new Uint32Array(T).buffer;
      return n[E] = M, M;
    }
    const l = e.isInstancedBufferGeometry ? new kL() : new gn(), u = e.data.index;
    if (u !== void 0) {
      const _ = Hd(u.type, u.array);
      l.setIndex(new Vn(_, 1));
    }
    const d = e.data.attributes;
    for (const _ in d) {
      const E = d[_];
      let w;
      if (E.isInterleavedBufferAttribute) {
        const T = r(e.data, E.data);
        w = new Vc(T, E.itemSize, E.offset, E.normalized);
      } else {
        const T = Hd(E.type, E.array), M = E.isInstancedBufferAttribute ? nh : Vn;
        w = new M(T, E.itemSize, E.normalized);
      }
      E.name !== void 0 && (w.name = E.name), E.usage !== void 0 && w.setUsage(E.usage), l.setAttribute(_, w);
    }
    const h = e.data.morphAttributes;
    if (h)
      for (const _ in h) {
        const E = h[_], w = [];
        for (let T = 0, M = E.length; T < M; T++) {
          const C = E[T];
          let A;
          if (C.isInterleavedBufferAttribute) {
            const N = r(e.data, C.data);
            A = new Vc(N, C.itemSize, C.offset, C.normalized);
          } else {
            const N = Hd(C.type, C.array);
            A = new Vn(N, C.itemSize, C.normalized);
          }
          C.name !== void 0 && (A.name = C.name), w.push(A);
        }
        l.morphAttributes[_] = w;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const g = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (g !== void 0)
      for (let _ = 0, E = g.length; _ !== E; ++_) {
        const w = g[_];
        l.addGroup(w.start, w.count, w.materialIndex);
      }
    const y = e.data.boundingSphere;
    if (y !== void 0) {
      const _ = new j();
      y.center !== void 0 && _.fromArray(y.center), l.boundingSphere = new jr(_, y.radius);
    }
    return e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
  }
}
class wk extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = this, l = this.path === "" ? iE.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const u = new ol(this.manager);
    u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(e, function(d) {
      let h = null;
      try {
        h = JSON.parse(d);
      } catch (g) {
        r !== void 0 && r(g), console.error("THREE:ObjectLoader: Can't parse " + e + ".", g.message);
        return;
      }
      const m = h.metadata;
      if (m === void 0 || m.type === void 0 || m.type.toLowerCase() === "geometry") {
        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      o.parse(h, t);
    }, n, r);
  }
  async loadAsync(e, t) {
    const n = this, r = this.path === "" ? iE.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const o = new ol(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const l = await o.loadAsync(e, t), u = JSON.parse(l), d = u.metadata;
    if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), o = this.parseGeometries(e.geometries, r), l = this.parseImages(e.images, function() {
      t !== void 0 && t(h);
    }), u = this.parseTextures(e.textures, l), d = this.parseMaterials(e.materials, u), h = this.parseObject(e.object, o, d, u, n), m = this.parseSkeletons(e.skeletons, h);
    if (this.bindSkeletons(h, m), t !== void 0) {
      let g = !1;
      for (const y in l)
        if (l[y].data instanceof HTMLImageElement) {
          g = !0;
          break;
        }
      g === !1 && t(h);
    }
    return h;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), o = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, o), u = this.parseMaterials(e.materials, l), d = this.parseObject(e.object, r, u, l, t), h = this.parseSkeletons(e.skeletons, d);
    return this.bindSkeletons(d, h), d;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, r = e.length; n < r; n++) {
        const o = new Fc().fromJSON(e[n]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, r = {};
    if (t.traverse(function(o) {
      o.isBone && (r[o.uuid] = o);
    }), e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const u = new x0().fromJSON(e[o], r);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const r = new GL();
      for (let o = 0, l = e.length; o < l; o++) {
        let u;
        const d = e[o];
        switch (d.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = r.parse(d);
            break;
          default:
            d.type in kA ? u = kA[d.type].fromJSON(d, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${d.type}"`);
        }
        u.uuid = d.uuid, d.name !== void 0 && (u.name = d.name), d.userData !== void 0 && (u.userData = d.userData), n[d.uuid] = u;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, r = {};
    if (e !== void 0) {
      const o = new O0();
      o.setTextures(t);
      for (let l = 0, u = e.length; l < u; l++) {
        const d = e[l];
        n[d.uuid] === void 0 && (n[d.uuid] = o.parse(d)), r[d.uuid] = n[d.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const r = e[n], o = bm.parse(r);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, r = {};
    let o;
    function l(d) {
      return n.manager.itemStart(d), o.load(d, function() {
        n.manager.itemEnd(d);
      }, void 0, function() {
        n.manager.itemError(d), n.manager.itemEnd(d);
      });
    }
    function u(d) {
      if (typeof d == "string") {
        const h = d, m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : n.resourcePath + h;
        return l(m);
      } else
        return d.data ? {
          data: Hd(d.type, d.data),
          width: d.width,
          height: d.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const d = new ub(t);
      o = new Tm(d), o.setCrossOrigin(this.crossOrigin);
      for (let h = 0, m = e.length; h < m; h++) {
        const g = e[h], y = g.url;
        if (Array.isArray(y)) {
          const _ = [];
          for (let E = 0, w = y.length; E < w; E++) {
            const T = y[E], M = u(T);
            M !== null && (M instanceof HTMLImageElement ? _.push(M) : _.push(new Ic(M.data, M.width, M.height)));
          }
          r[g.uuid] = new Pc(_);
        } else {
          const _ = u(g.url);
          r[g.uuid] = new Pc(_);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let r;
    async function o(l) {
      if (typeof l == "string") {
        const u = l, d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await r.loadAsync(d);
      } else
        return l.data ? {
          data: Hd(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new Tm(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let l = 0, u = e.length; l < u; l++) {
        const d = e[l], h = d.url;
        if (Array.isArray(h)) {
          const m = [];
          for (let g = 0, y = h.length; g < y; g++) {
            const _ = h[g], E = await o(_);
            E !== null && (E instanceof HTMLImageElement ? m.push(E) : m.push(new Ic(E.data, E.width, E.height)));
          }
          n[d.uuid] = new Pc(m);
        } else {
          const m = await o(d.url);
          n[d.uuid] = new Pc(m);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(o, l) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), l[o]);
    }
    const r = {};
    if (e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const u = e[o];
        u.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid), t[u.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", u.image);
        const d = t[u.image], h = d.data;
        let m;
        Array.isArray(h) ? (m = new Um(), h.length === 6 && (m.needsUpdate = !0)) : (h && h.data ? m = new Ic() : m = new Fi(), h && (m.needsUpdate = !0)), m.source = d, m.uuid = u.uuid, u.name !== void 0 && (m.name = u.name), u.mapping !== void 0 && (m.mapping = n(u.mapping, Ak)), u.channel !== void 0 && (m.channel = u.channel), u.offset !== void 0 && m.offset.fromArray(u.offset), u.repeat !== void 0 && m.repeat.fromArray(u.repeat), u.center !== void 0 && m.center.fromArray(u.center), u.rotation !== void 0 && (m.rotation = u.rotation), u.wrap !== void 0 && (m.wrapS = n(u.wrap[0], jA), m.wrapT = n(u.wrap[1], jA)), u.format !== void 0 && (m.format = u.format), u.internalFormat !== void 0 && (m.internalFormat = u.internalFormat), u.type !== void 0 && (m.type = u.type), u.colorSpace !== void 0 && (m.colorSpace = u.colorSpace), u.encoding !== void 0 && (m.encoding = u.encoding), u.minFilter !== void 0 && (m.minFilter = n(u.minFilter, YA)), u.magFilter !== void 0 && (m.magFilter = n(u.magFilter, YA)), u.anisotropy !== void 0 && (m.anisotropy = u.anisotropy), u.flipY !== void 0 && (m.flipY = u.flipY), u.generateMipmaps !== void 0 && (m.generateMipmaps = u.generateMipmaps), u.premultiplyAlpha !== void 0 && (m.premultiplyAlpha = u.premultiplyAlpha), u.unpackAlignment !== void 0 && (m.unpackAlignment = u.unpackAlignment), u.compareFunction !== void 0 && (m.compareFunction = u.compareFunction), u.userData !== void 0 && (m.userData = u.userData), r[u.uuid] = m;
      }
    return r;
  }
  parseObject(e, t, n, r, o) {
    let l;
    function u(y) {
      return t[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", y), t[y];
    }
    function d(y) {
      if (y !== void 0) {
        if (Array.isArray(y)) {
          const _ = [];
          for (let E = 0, w = y.length; E < w; E++) {
            const T = y[E];
            n[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", T), _.push(n[T]);
          }
          return _;
        }
        return n[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", y), n[y];
      }
    }
    function h(y) {
      return r[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", y), r[y];
    }
    let m, g;
    switch (e.type) {
      case "Scene":
        l = new qE(), e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new Tt(e.background) : l.background = h(e.background)), e.environment !== void 0 && (l.environment = h(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new g0(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new v0(e.fog.color, e.fog.density)), e.fog.name !== "" && (l.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (l.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (l.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        l = new Ii(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        l = new hu(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new zL(e.color, e.intensity);
        break;
      case "DirectionalLight":
        l = new FL(e.color, e.intensity);
        break;
      case "PointLight":
        l = new IL(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new BL(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        l = new OL(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        l = new UL(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new HL().fromJSON(e);
        break;
      case "SkinnedMesh":
        m = u(e.geometry), g = d(e.material), l = new sL(m, g), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        m = u(e.geometry), g = d(e.material), l = new ir(m, g);
        break;
      case "InstancedMesh":
        m = u(e.geometry), g = d(e.material);
        const y = e.count, _ = e.instanceMatrix, E = e.instanceColor;
        l = new aL(m, g, y), l.instanceMatrix = new nh(new Float32Array(_.array), 16), E !== void 0 && (l.instanceColor = new nh(new Float32Array(E.array), E.itemSize));
        break;
      case "BatchedMesh":
        m = u(e.geometry), g = d(e.material), l = new oL(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, g), l.geometry = m, l.perObjectFrustumCulled = e.perObjectFrustumCulled, l.sortObjects = e.sortObjects, l._drawRanges = e.drawRanges, l._reservedRanges = e.reservedRanges, l._visibility = e.visibility, l._active = e.active, l._bounds = e.bounds.map((w) => {
          const T = new as();
          T.min.fromArray(w.boxMin), T.max.fromArray(w.boxMax);
          const M = new jr();
          return M.radius = w.sphereRadius, M.center.fromArray(w.sphereCenter), {
            boxInitialized: w.boxInitialized,
            box: T,
            sphereInitialized: w.sphereInitialized,
            sphere: M
          };
        }), l._maxGeometryCount = e.maxGeometryCount, l._maxVertexCount = e.maxVertexCount, l._maxIndexCount = e.maxIndexCount, l._geometryInitialized = e.geometryInitialized, l._geometryCount = e.geometryCount, l._matricesTexture = h(e.matricesTexture.uuid);
        break;
      case "LOD":
        l = new rL();
        break;
      case "Line":
        l = new yu(u(e.geometry), d(e.material));
        break;
      case "LineLoop":
        l = new lL(u(e.geometry), d(e.material));
        break;
      case "LineSegments":
        l = new So(u(e.geometry), d(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new uL(u(e.geometry), d(e.material));
        break;
      case "Sprite":
        l = new iL(d(e.material));
        break;
      case "Group":
        l = new Wd();
        break;
      case "Bone":
        l = new KE();
        break;
      default:
        l = new Dn();
    }
    if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.up !== void 0 && l.up.fromArray(e.up), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
      const y = e.children;
      for (let _ = 0; _ < y.length; _++)
        l.add(this.parseObject(y[_], t, n, r, o));
    }
    if (e.animations !== void 0) {
      const y = e.animations;
      for (let _ = 0; _ < y.length; _++) {
        const E = y[_];
        l.animations.push(o[E]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const y = e.levels;
      for (let _ = 0; _ < y.length; _++) {
        const E = y[_], w = l.getObjectByProperty("uuid", E.object);
        w !== void 0 && l.addLevel(w, E.distance, E.hysteresis);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const r = t[n.skeleton];
        r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(r, n.bindMatrix);
      }
    });
  }
}
const Ak = {
  UVMapping: c0,
  CubeReflectionMapping: al,
  CubeRefractionMapping: vu,
  EquirectangularReflectionMapping: am,
  EquirectangularRefractionMapping: om,
  CubeUVReflectionMapping: oh
}, jA = {
  RepeatWrapping: lm,
  ClampToEdgeWrapping: Wr,
  MirroredRepeatWrapping: um
}, YA = {
  NearestFilter: Ui,
  NearestMipmapNearestFilter: qy,
  NearestMipmapLinearFilter: Kp,
  LinearFilter: Oi,
  LinearMipmapNearestFilter: AE,
  LinearMipmapLinearFilter: gu
};
class Rk extends Ts {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = el.get(e);
    if (l !== void 0) {
      if (o.manager.itemStart(e), l.then) {
        l.then((h) => {
          t && t(h), o.manager.itemEnd(e);
        }).catch((h) => {
          r && r(h);
        });
        return;
      }
      return setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    }
    const u = {};
    u.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", u.headers = this.requestHeader;
    const d = fetch(e, u).then(function(h) {
      return h.blob();
    }).then(function(h) {
      return createImageBitmap(h, Object.assign(o.options, { colorSpaceConversion: "none" }));
    }).then(function(h) {
      return el.add(e, h), t && t(h), o.manager.itemEnd(e), h;
    }).catch(function(h) {
      r && r(h), el.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
    });
    el.add(e, d), o.manager.itemStart(e);
  }
}
let Sy;
class fb {
  static getContext() {
    return Sy === void 0 && (Sy = new (window.AudioContext || window.webkitAudioContext)()), Sy;
  }
  static setContext(e) {
    Sy = e;
  }
}
class Ck extends Ts {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const o = this, l = new ol(this.manager);
    l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(d) {
      try {
        const h = d.slice(0);
        fb.getContext().decodeAudioData(h, function(g) {
          t(g);
        }).catch(u);
      } catch (h) {
        u(h);
      }
    }, n, r);
    function u(d) {
      r ? r(d) : console.error(d), o.manager.itemError(e);
    }
  }
}
const qA = /* @__PURE__ */ new $t(), ZA = /* @__PURE__ */ new $t(), pc = /* @__PURE__ */ new $t();
class Pk {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ii(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ii(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, pc.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, o = r * t.near / t.focus, l = t.near * Math.tan(Uc * t.fov * 0.5) / t.zoom;
      let u, d;
      ZA.elements[12] = -r, qA.elements[12] = r, u = -l * t.aspect + o, d = l * t.aspect + o, pc.elements[0] = 2 * t.near / (d - u), pc.elements[8] = (d + u) / (d - u), this.cameraL.projectionMatrix.copy(pc), u = -l * t.aspect - o, d = l * t.aspect - o, pc.elements[0] = 2 * t.near / (d - u), pc.elements[8] = (d + u) / (d - u), this.cameraR.projectionMatrix.copy(pc);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ZA), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(qA);
  }
}
class db {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = KA(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = KA();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function KA() {
  return (typeof performance > "u" ? Date : performance).now();
}
const mc = /* @__PURE__ */ new j(), JA = /* @__PURE__ */ new Xr(), Lk = /* @__PURE__ */ new j(), vc = /* @__PURE__ */ new j();
class Dk extends Dn {
  constructor() {
    super(), this.type = "AudioListener", this.context = fb.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new db();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(mc, JA, Lk), vc.set(0, 0, -1).applyQuaternion(JA), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(mc.x, r), t.positionY.linearRampToValueAtTime(mc.y, r), t.positionZ.linearRampToValueAtTime(mc.z, r), t.forwardX.linearRampToValueAtTime(vc.x, r), t.forwardY.linearRampToValueAtTime(vc.y, r), t.forwardZ.linearRampToValueAtTime(vc.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r);
    } else
      t.setPosition(mc.x, mc.y, mc.z), t.setOrientation(vc.x, vc.y, vc.z, n.x, n.y, n.z);
  }
}
class WL extends Dn {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const gc = /* @__PURE__ */ new j(), QA = /* @__PURE__ */ new Xr(), Nk = /* @__PURE__ */ new j(), yc = /* @__PURE__ */ new j();
class Uk extends WL {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(gc, QA, Nk), yc.set(0, 0, 1).applyQuaternion(QA);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(gc.x, n), t.positionY.linearRampToValueAtTime(gc.y, n), t.positionZ.linearRampToValueAtTime(gc.z, n), t.orientationX.linearRampToValueAtTime(yc.x, n), t.orientationY.linearRampToValueAtTime(yc.y, n), t.orientationZ.linearRampToValueAtTime(yc.z, n);
    } else
      t.setPosition(gc.x, gc.y, gc.z), t.setOrientation(yc.x, yc.y, yc.z);
  }
}
class Ok {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class XL {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let r, o, l;
    switch (t) {
      case "quaternion":
        r = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        r = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, r = this.valueSize, o = e * r + r;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let u = 0; u !== r; ++u)
        n[o + u] = n[u];
      l = t;
    } else {
      l += t;
      const u = t / l;
      this._mixBufferRegion(n, o, 0, u, r);
    }
    this.cumulativeWeight = l;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, r = e * t + t, o = this.cumulativeWeight, l = this.cumulativeWeightAdditive, u = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
      const d = t * this._origIndex;
      this._mixBufferRegion(
        n,
        r,
        d,
        1 - o,
        t
      );
    }
    l > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
    for (let d = t, h = t + t; d !== h; ++d)
      if (n[d] !== n[d + t]) {
        u.setValue(n, r);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex;
    e.getValue(t, r);
    for (let o = n, l = r; o !== l; ++o)
      t[o] = t[r + o % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, r, o) {
    if (r >= 0.5)
      for (let l = 0; l !== o; ++l)
        e[t + l] = e[n + l];
  }
  _slerp(e, t, n, r) {
    Xr.slerpFlat(e, t, e, t, e, n, r);
  }
  _slerpAdditive(e, t, n, r, o) {
    const l = this._workIndex * o;
    Xr.multiplyQuaternionsFlat(e, l, e, t, e, n), Xr.slerpFlat(e, t, e, t, e, l, r);
  }
  _lerp(e, t, n, r, o) {
    const l = 1 - r;
    for (let u = 0; u !== o; ++u) {
      const d = t + u;
      e[d] = e[d] * l + e[n + u] * r;
    }
  }
  _lerpAdditive(e, t, n, r, o) {
    for (let l = 0; l !== o; ++l) {
      const u = t + l;
      e[u] = e[u] + e[n + l] * r;
    }
  }
}
const hb = "\\[\\]\\.:\\/", Ik = new RegExp("[" + hb + "]", "g"), pb = "[^" + hb + "]", Fk = "[^" + hb.replace("\\.", "") + "]", zk = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", pb), Bk = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", Fk), Vk = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pb), Hk = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pb), kk = new RegExp(
  "^" + zk + Bk + Vk + Hk + "$"
), Gk = ["material", "materials", "bones", "map"];
class Wk {
  constructor(e, t, n) {
    const r = n || Pn.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, o = n.length; r !== o; ++r)
      n[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Pn {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Pn.parseTrackName(t), this.node = Pn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Pn.Composite(e, t, n) : new Pn(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(Ik, "");
  }
  static parseTrackName(e) {
    const t = kk.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const o = n.nodeName.substring(r + 1);
      Gk.indexOf(o) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = o);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(o) {
        for (let l = 0; l < o.length; l++) {
          const u = o[l];
          if (u.name === t || u.uuid === t)
            return u;
          const d = n(u.children);
          if (d) return d;
        }
        return null;
      }, r = n(e.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, o = n.length; r !== o; ++r)
      e[t++] = n[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, o = n.length; r !== o; ++r)
      n[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, o = n.length; r !== o; ++r)
      n[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, o = n.length; r !== o; ++r)
      n[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, r = t.propertyName;
    let o = t.propertyIndex;
    if (e || (e = Pn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let h = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let m = 0; m < e.length; m++)
            if (e[m].name === h) {
              h = m;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (h !== void 0) {
        if (e[h] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[h];
      }
    }
    const l = e[r];
    if (l === void 0) {
      const h = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + r + " but it wasn't found.", e);
      return;
    }
    let u = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? u = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let d = this.BindingType.Direct;
    if (o !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      d = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o;
    } else l.fromArray !== void 0 && l.toArray !== void 0 ? (d = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (d = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[d], this.setValue = this.SetterByBindingTypeAndVersioning[d][u];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Pn.Composite = Wk;
Pn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Pn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Pn.prototype.GetterByBindingType = [
  Pn.prototype._getValue_direct,
  Pn.prototype._getValue_array,
  Pn.prototype._getValue_arrayElement,
  Pn.prototype._getValue_toArray
];
Pn.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Pn.prototype._setValue_direct,
    Pn.prototype._setValue_direct_setNeedsUpdate,
    Pn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Pn.prototype._setValue_array,
    Pn.prototype._setValue_array_setNeedsUpdate,
    Pn.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Pn.prototype._setValue_arrayElement,
    Pn.prototype._setValue_arrayElement_setNeedsUpdate,
    Pn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Pn.prototype._setValue_fromArray,
    Pn.prototype._setValue_fromArray_setNeedsUpdate,
    Pn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class Xk {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ks(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, r = arguments.length; n !== r; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, o = this._bindings, l = o.length;
    let u, d = e.length, h = this.nCachedObjects_;
    for (let m = 0, g = arguments.length; m !== g; ++m) {
      const y = arguments[m], _ = y.uuid;
      let E = t[_];
      if (E === void 0) {
        E = d++, t[_] = E, e.push(y);
        for (let w = 0, T = l; w !== T; ++w)
          o[w].push(new Pn(y, n[w], r[w]));
      } else if (E < h) {
        u = e[E];
        const w = --h, T = e[w];
        t[T.uuid] = E, e[E] = T, t[_] = w, e[w] = y;
        for (let M = 0, C = l; M !== C; ++M) {
          const A = o[M], N = A[w];
          let z = A[E];
          A[E] = N, z === void 0 && (z = new Pn(y, n[M], r[M])), A[w] = z;
        }
      } else e[E] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = h;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length;
    let o = this.nCachedObjects_;
    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const d = arguments[l], h = d.uuid, m = t[h];
      if (m !== void 0 && m >= o) {
        const g = o++, y = e[g];
        t[y.uuid] = m, e[m] = y, t[h] = g, e[g] = d;
        for (let _ = 0, E = r; _ !== E; ++_) {
          const w = n[_], T = w[g], M = w[m];
          w[m] = T, w[g] = M;
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length;
    let o = this.nCachedObjects_, l = e.length;
    for (let u = 0, d = arguments.length; u !== d; ++u) {
      const h = arguments[u], m = h.uuid, g = t[m];
      if (g !== void 0)
        if (delete t[m], g < o) {
          const y = --o, _ = e[y], E = --l, w = e[E];
          t[_.uuid] = g, e[g] = _, t[w.uuid] = y, e[y] = w, e.pop();
          for (let T = 0, M = r; T !== M; ++T) {
            const C = n[T], A = C[y], N = C[E];
            C[g] = A, C[y] = N, C.pop();
          }
        } else {
          const y = --l, _ = e[y];
          y > 0 && (t[_.uuid] = g), e[g] = _, e.pop();
          for (let E = 0, w = r; E !== w; ++E) {
            const T = n[E];
            T[g] = T[y], T.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let r = n[e];
    const o = this._bindings;
    if (r !== void 0) return o[r];
    const l = this._paths, u = this._parsedPaths, d = this._objects, h = d.length, m = this.nCachedObjects_, g = new Array(h);
    r = o.length, n[e] = r, l.push(e), u.push(t), o.push(g);
    for (let y = m, _ = d.length; y !== _; ++y) {
      const E = d[y];
      g[y] = new Pn(E, e, t);
    }
    return g;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const r = this._paths, o = this._parsedPaths, l = this._bindings, u = l.length - 1, d = l[u], h = e[u];
      t[h] = n, l[n] = d, l.pop(), o[n] = o[u], o.pop(), r[n] = r[u], r.pop();
    }
  }
}
class jL {
  constructor(e, t, n = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
    const o = t.tracks, l = o.length, u = new Array(l), d = {
      endingStart: Rc,
      endingEnd: Rc
    };
    for (let h = 0; h !== l; ++h) {
      const m = o[h].createInterpolant(null);
      u[h] = m, m.settings = d;
    }
    this._interpolantSettings = d, this._interpolants = u, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = AP, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const r = this._clip.duration, o = e._clip.duration, l = o / r, u = r / o;
      e.warp(1, l, t), this.warp(u, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const r = this._mixer, o = r.time, l = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null && (u = r._lendControlInterpolant(), this._timeScaleInterpolant = u);
    const d = u.parameterPositions, h = u.sampleValues;
    return d[0] = o, d[1] = o + n, h[0] = e / l, h[1] = t / l, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const d = (e - o) * n;
      d < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * d);
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t), u = this._updateWeight(e);
    if (u > 0) {
      const d = this._interpolants, h = this._propertyBindings;
      switch (this.blendMode) {
        case OE:
          for (let m = 0, g = d.length; m !== g; ++m)
            d[m].evaluate(l), h[m].accumulateAdditive(u);
          break;
        case d0:
        default:
          for (let m = 0, g = d.length; m !== g; ++m)
            d[m].evaluate(l), h[m].accumulate(r, u);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let r = this.time + e, o = this._loopCount;
    const l = n === RP;
    if (e === 0)
      return o === -1 ? r : l && (o & 1) === 1 ? t - r : r;
    if (n === wP) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), r >= t || r < 0) {
        const u = Math.floor(r / t);
        r -= t * u, o += Math.abs(u);
        const d = this.repetitions - o;
        if (d <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (d === 1) {
            const h = e < 0;
            this._setEndings(h, !h, l);
          } else
            this._setEndings(!1, !1, l);
          this._loopCount = o, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: u
          });
        }
      } else
        this.time = r;
      if (l && (o & 1) === 1)
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, n) {
    const r = this._interpolantSettings;
    n ? (r.endingStart = Cc, r.endingEnd = Cc) : (e ? r.endingStart = this.zeroSlopeAtStart ? Cc : Rc : r.endingStart = dm, t ? r.endingEnd = this.zeroSlopeAtEnd ? Cc : Rc : r.endingEnd = dm);
  }
  _scheduleFading(e, t, n) {
    const r = this._mixer, o = r.time;
    let l = this._weightInterpolant;
    l === null && (l = r._lendControlInterpolant(), this._weightInterpolant = l);
    const u = l.parameterPositions, d = l.sampleValues;
    return u[0] = o, d[0] = t, u[1] = o + e, d[1] = n, this;
  }
}
const jk = new Float32Array(1);
class Yk extends ul {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, r = e._clip.tracks, o = r.length, l = e._propertyBindings, u = e._interpolants, d = n.uuid, h = this._bindingsByRootAndName;
    let m = h[d];
    m === void 0 && (m = {}, h[d] = m);
    for (let g = 0; g !== o; ++g) {
      const y = r[g], _ = y.name;
      let E = m[_];
      if (E !== void 0)
        ++E.referenceCount, l[g] = E;
      else {
        if (E = l[g], E !== void 0) {
          E._cacheIndex === null && (++E.referenceCount, this._addInactiveBinding(E, d, _));
          continue;
        }
        const w = t && t._propertyBindings[g].binding.parsedPath;
        E = new XL(
          Pn.create(n, _, w),
          y.ValueTypeName,
          y.getValueSize()
        ), ++E.referenceCount, this._addInactiveBinding(E, d, _), l[g] = E;
      }
      u[g].resultBuffer = E.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, r = e._clip.uuid, o = this._actionsByClip[r];
        this._bindAction(
          e,
          o && o.knownActions[0]
        ), this._addInactiveAction(e, r, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const o = t[n];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const o = t[n];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const r = this._actions, o = this._actionsByClip;
    let l = o[t];
    if (l === void 0)
      l = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, o[t] = l;
    else {
      const u = l.knownActions;
      e._byClipCacheIndex = u.length, u.push(e);
    }
    e._cacheIndex = r.length, r.push(e), l.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], r = e._cacheIndex;
    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
    const o = e._clip.uuid, l = this._actionsByClip, u = l[o], d = u.knownActions, h = d[d.length - 1], m = e._byClipCacheIndex;
    h._byClipCacheIndex = m, d[m] = h, d.pop(), e._byClipCacheIndex = null;
    const g = u.actionByRoot, y = (e._localRoot || this._root).uuid;
    delete g[y], d.length === 0 && delete l[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, r = t.length; n !== r; ++n) {
      const o = t[n];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, o = t[r];
    e._cacheIndex = r, t[r] = e, o._cacheIndex = n, t[n] = o;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, o = t[r];
    e._cacheIndex = r, t[r] = e, o._cacheIndex = n, t[n] = o;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const r = this._bindingsByRootAndName, o = this._bindings;
    let l = r[t];
    l === void 0 && (l = {}, r[t] = l), l[n] = e, e._cacheIndex = o.length, o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, r = n.rootNode.uuid, o = n.path, l = this._bindingsByRootAndName, u = l[r], d = t[t.length - 1], h = e._cacheIndex;
    d._cacheIndex = h, t[h] = d, t.pop(), delete u[o], Object.keys(u).length === 0 && delete l[r];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, o = t[r];
    e._cacheIndex = r, t[r] = e, o._cacheIndex = n, t[n] = o;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, o = t[r];
    e._cacheIndex = r, t[r] = e, o._cacheIndex = n, t[n] = o;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new ob(
      new Float32Array(2),
      new Float32Array(2),
      1,
      jk
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, o = t[r];
    e.__cacheIndex = r, t[r] = e, o.__cacheIndex = n, t[n] = o;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const r = t || this._root, o = r.uuid;
    let l = typeof e == "string" ? bm.findByName(r, e) : e;
    const u = l !== null ? l.uuid : e, d = this._actionsByClip[u];
    let h = null;
    if (n === void 0 && (l !== null ? n = l.blendMode : n = d0), d !== void 0) {
      const g = d.actionByRoot[o];
      if (g !== void 0 && g.blendMode === n)
        return g;
      h = d.knownActions[0], l === null && (l = h._clip);
    }
    if (l === null) return null;
    const m = new jL(this, l, t, n);
    return this._bindAction(m, h), this._addInactiveAction(m, u, o), m;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, r = n.uuid, o = typeof e == "string" ? bm.findByName(n, e) : e, l = o ? o.uuid : e, u = this._actionsByClip[l];
    return u !== void 0 && u.actionByRoot[r] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, r = this.time += e, o = Math.sign(e), l = this._accuIndex ^= 1;
    for (let h = 0; h !== n; ++h)
      t[h]._update(r, e, o, l);
    const u = this._bindings, d = this._nActiveBindings;
    for (let h = 0; h !== d; ++h)
      u[h].apply(l);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, r = this._actionsByClip, o = r[n];
    if (o !== void 0) {
      const l = o.knownActions;
      for (let u = 0, d = l.length; u !== d; ++u) {
        const h = l[u];
        this._deactivateAction(h);
        const m = h._cacheIndex, g = t[t.length - 1];
        h._cacheIndex = null, h._byClipCacheIndex = null, g._cacheIndex = m, t[m] = g, t.pop(), this._removeInactiveBindingsForAction(h);
      }
      delete r[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const l in n) {
      const u = n[l].actionByRoot, d = u[t];
      d !== void 0 && (this._deactivateAction(d), this._removeInactiveAction(d));
    }
    const r = this._bindingsByRootAndName, o = r[t];
    if (o !== void 0)
      for (const l in o) {
        const u = o[l];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class mb {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new mb(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let qk = 0;
class Zk extends ul {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: qk++ }), this.name = "", this.usage = vm, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const o = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let l = 0; l < o.length; l++)
        this.uniforms.push(o[l].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Kk extends y0 {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class Jk {
  constructor(e, t, n, r, o) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = o, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class YL {
  constructor(e, t, n = 0, r = 1 / 0) {
    this.ray = new Gc(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Oc(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return rE(e, this, n, t), n.sort($A), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let r = 0, o = e.length; r < o; r++)
      rE(e[r], this, n, t);
    return n.sort($A), n;
  }
}
function $A(i, e) {
  return i.distance - e.distance;
}
function rE(i, e, t, n) {
  if (i.layers.test(e.layers) && i.raycast(e, t), n === !0) {
    const r = i.children;
    for (let o = 0, l = r.length; o < l; o++)
      rE(r[o], e, t, !0);
  }
}
class sE {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Mi(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qk {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const eR = /* @__PURE__ */ new Oe();
class $k {
  constructor(e = new Oe(1 / 0, 1 / 0), t = new Oe(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = eR.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, eR).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const tR = /* @__PURE__ */ new j(), My = /* @__PURE__ */ new j();
class e4 {
  constructor(e = new j(), t = new j()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    tR.subVectors(e, this.start), My.subVectors(this.end, this.start);
    const n = My.dot(My);
    let o = My.dot(tR) / n;
    return t && (o = Mi(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, n) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const nR = /* @__PURE__ */ new j();
class t4 extends Dn {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new gn(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let l = 0, u = 1, d = 32; l < d; l++, u++) {
      const h = l / d * Math.PI * 2, m = u / d * Math.PI * 2;
      r.push(
        Math.cos(h),
        Math.sin(h),
        1,
        Math.cos(m),
        Math.sin(m),
        1
      );
    }
    n.setAttribute("position", new Ot(r, 3));
    const o = new os({ fog: !1, toneMapped: !1 });
    this.cone = new So(n, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), nR.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(nR), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const iu = /* @__PURE__ */ new j(), Ey = /* @__PURE__ */ new $t(), HS = /* @__PURE__ */ new $t();
class n4 extends So {
  constructor(e) {
    const t = qL(e), n = new gn(), r = [], o = [], l = new Tt(0, 0, 1), u = new Tt(0, 1, 0);
    for (let h = 0; h < t.length; h++) {
      const m = t[h];
      m.parent && m.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), o.push(l.r, l.g, l.b), o.push(u.r, u.g, u.b));
    }
    n.setAttribute("position", new Ot(r, 3)), n.setAttribute("color", new Ot(o, 3));
    const d = new os({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, d), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, r = n.getAttribute("position");
    HS.copy(this.root.matrixWorld).invert();
    for (let o = 0, l = 0; o < t.length; o++) {
      const u = t[o];
      u.parent && u.parent.isBone && (Ey.multiplyMatrices(HS, u.matrixWorld), iu.setFromMatrixPosition(Ey), r.setXYZ(l, iu.x, iu.y, iu.z), Ey.multiplyMatrices(HS, u.parent.matrixWorld), iu.setFromMatrixPosition(Ey), r.setXYZ(l + 1, iu.x, iu.y, iu.z), l += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function qL(i) {
  const e = [];
  i.isBone === !0 && e.push(i);
  for (let t = 0; t < i.children.length; t++)
    e.push.apply(e, qL(i.children[t]));
  return e;
}
class i4 extends ir {
  constructor(e, t, n) {
    const r = new Bm(t, 4, 2), o = new Mu({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, o), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const r4 = /* @__PURE__ */ new j(), iR = /* @__PURE__ */ new Tt(), rR = /* @__PURE__ */ new Tt();
class s4 extends Dn {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const r = new zm(t);
    r.rotateY(Math.PI * 0.5), this.material = new Mu({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const o = r.getAttribute("position"), l = new Float32Array(o.count * 3);
    r.setAttribute("color", new Vn(l, 3)), this.add(new ir(r, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      iR.copy(this.light.color), rR.copy(this.light.groundColor);
      for (let n = 0, r = t.count; n < r; n++) {
        const o = n < r / 2 ? iR : rR;
        t.setXYZ(n, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(r4.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class a4 extends So {
  constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
    n = new Tt(n), r = new Tt(r);
    const o = t / 2, l = e / t, u = e / 2, d = [], h = [];
    for (let y = 0, _ = 0, E = -u; y <= t; y++, E += l) {
      d.push(-u, 0, E, u, 0, E), d.push(E, 0, -u, E, 0, u);
      const w = y === o ? n : r;
      w.toArray(h, _), _ += 3, w.toArray(h, _), _ += 3, w.toArray(h, _), _ += 3, w.toArray(h, _), _ += 3;
    }
    const m = new gn();
    m.setAttribute("position", new Ot(d, 3)), m.setAttribute("color", new Ot(h, 3));
    const g = new os({ vertexColors: !0, toneMapped: !1 });
    super(m, g), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class o4 extends So {
  constructor(e = 10, t = 16, n = 8, r = 64, o = 4473924, l = 8947848) {
    o = new Tt(o), l = new Tt(l);
    const u = [], d = [];
    if (t > 1)
      for (let g = 0; g < t; g++) {
        const y = g / t * (Math.PI * 2), _ = Math.sin(y) * e, E = Math.cos(y) * e;
        u.push(0, 0, 0), u.push(_, 0, E);
        const w = g & 1 ? o : l;
        d.push(w.r, w.g, w.b), d.push(w.r, w.g, w.b);
      }
    for (let g = 0; g < n; g++) {
      const y = g & 1 ? o : l, _ = e - e / n * g;
      for (let E = 0; E < r; E++) {
        let w = E / r * (Math.PI * 2), T = Math.sin(w) * _, M = Math.cos(w) * _;
        u.push(T, 0, M), d.push(y.r, y.g, y.b), w = (E + 1) / r * (Math.PI * 2), T = Math.sin(w) * _, M = Math.cos(w) * _, u.push(T, 0, M), d.push(y.r, y.g, y.b);
      }
    }
    const h = new gn();
    h.setAttribute("position", new Ot(u, 3)), h.setAttribute("color", new Ot(d, 3));
    const m = new os({ vertexColors: !0, toneMapped: !1 });
    super(h, m), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const sR = /* @__PURE__ */ new j(), by = /* @__PURE__ */ new j(), aR = /* @__PURE__ */ new j();
class l4 extends Dn {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let r = new gn();
    r.setAttribute("position", new Ot([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const o = new os({ fog: !1, toneMapped: !1 });
    this.lightPlane = new yu(r, o), this.add(this.lightPlane), r = new gn(), r.setAttribute("position", new Ot([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new yu(r, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), sR.setFromMatrixPosition(this.light.matrixWorld), by.setFromMatrixPosition(this.light.target.matrixWorld), aR.subVectors(by, sR), this.lightPlane.lookAt(by), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(by), this.targetLine.scale.z = aR.length();
  }
}
const Ty = /* @__PURE__ */ new j(), Si = /* @__PURE__ */ new Nm();
class u4 extends So {
  constructor(e) {
    const t = new gn(), n = new os({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], o = [], l = {};
    u("n1", "n2"), u("n2", "n4"), u("n4", "n3"), u("n3", "n1"), u("f1", "f2"), u("f2", "f4"), u("f4", "f3"), u("f3", "f1"), u("n1", "f1"), u("n2", "f2"), u("n3", "f3"), u("n4", "f4"), u("p", "n1"), u("p", "n2"), u("p", "n3"), u("p", "n4"), u("u1", "u2"), u("u2", "u3"), u("u3", "u1"), u("c", "t"), u("p", "c"), u("cn1", "cn2"), u("cn3", "cn4"), u("cf1", "cf2"), u("cf3", "cf4");
    function u(E, w) {
      d(E), d(w);
    }
    function d(E) {
      r.push(0, 0, 0), o.push(0, 0, 0), l[E] === void 0 && (l[E] = []), l[E].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ot(r, 3)), t.setAttribute("color", new Ot(o, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
    const h = new Tt(16755200), m = new Tt(16711680), g = new Tt(43775), y = new Tt(16777215), _ = new Tt(3355443);
    this.setColors(h, m, g, y, _);
  }
  setColors(e, t, n, r, o) {
    const u = this.geometry.getAttribute("color");
    u.setXYZ(0, e.r, e.g, e.b), u.setXYZ(1, e.r, e.g, e.b), u.setXYZ(2, e.r, e.g, e.b), u.setXYZ(3, e.r, e.g, e.b), u.setXYZ(4, e.r, e.g, e.b), u.setXYZ(5, e.r, e.g, e.b), u.setXYZ(6, e.r, e.g, e.b), u.setXYZ(7, e.r, e.g, e.b), u.setXYZ(8, e.r, e.g, e.b), u.setXYZ(9, e.r, e.g, e.b), u.setXYZ(10, e.r, e.g, e.b), u.setXYZ(11, e.r, e.g, e.b), u.setXYZ(12, e.r, e.g, e.b), u.setXYZ(13, e.r, e.g, e.b), u.setXYZ(14, e.r, e.g, e.b), u.setXYZ(15, e.r, e.g, e.b), u.setXYZ(16, e.r, e.g, e.b), u.setXYZ(17, e.r, e.g, e.b), u.setXYZ(18, e.r, e.g, e.b), u.setXYZ(19, e.r, e.g, e.b), u.setXYZ(20, e.r, e.g, e.b), u.setXYZ(21, e.r, e.g, e.b), u.setXYZ(22, e.r, e.g, e.b), u.setXYZ(23, e.r, e.g, e.b), u.setXYZ(24, t.r, t.g, t.b), u.setXYZ(25, t.r, t.g, t.b), u.setXYZ(26, t.r, t.g, t.b), u.setXYZ(27, t.r, t.g, t.b), u.setXYZ(28, t.r, t.g, t.b), u.setXYZ(29, t.r, t.g, t.b), u.setXYZ(30, t.r, t.g, t.b), u.setXYZ(31, t.r, t.g, t.b), u.setXYZ(32, n.r, n.g, n.b), u.setXYZ(33, n.r, n.g, n.b), u.setXYZ(34, n.r, n.g, n.b), u.setXYZ(35, n.r, n.g, n.b), u.setXYZ(36, n.r, n.g, n.b), u.setXYZ(37, n.r, n.g, n.b), u.setXYZ(38, r.r, r.g, r.b), u.setXYZ(39, r.r, r.g, r.b), u.setXYZ(40, o.r, o.g, o.b), u.setXYZ(41, o.r, o.g, o.b), u.setXYZ(42, o.r, o.g, o.b), u.setXYZ(43, o.r, o.g, o.b), u.setXYZ(44, o.r, o.g, o.b), u.setXYZ(45, o.r, o.g, o.b), u.setXYZ(46, o.r, o.g, o.b), u.setXYZ(47, o.r, o.g, o.b), u.setXYZ(48, o.r, o.g, o.b), u.setXYZ(49, o.r, o.g, o.b), u.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, r = 1;
    Si.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ni("c", t, e, Si, 0, 0, -1), Ni("t", t, e, Si, 0, 0, 1), Ni("n1", t, e, Si, -n, -r, -1), Ni("n2", t, e, Si, n, -r, -1), Ni("n3", t, e, Si, -n, r, -1), Ni("n4", t, e, Si, n, r, -1), Ni("f1", t, e, Si, -n, -r, 1), Ni("f2", t, e, Si, n, -r, 1), Ni("f3", t, e, Si, -n, r, 1), Ni("f4", t, e, Si, n, r, 1), Ni("u1", t, e, Si, n * 0.7, r * 1.1, -1), Ni("u2", t, e, Si, -n * 0.7, r * 1.1, -1), Ni("u3", t, e, Si, 0, r * 2, -1), Ni("cf1", t, e, Si, -n, 0, 1), Ni("cf2", t, e, Si, n, 0, 1), Ni("cf3", t, e, Si, 0, -r, 1), Ni("cf4", t, e, Si, 0, r, 1), Ni("cn1", t, e, Si, -n, 0, -1), Ni("cn2", t, e, Si, n, 0, -1), Ni("cn3", t, e, Si, 0, -r, -1), Ni("cn4", t, e, Si, 0, r, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Ni(i, e, t, n, r, o, l) {
  Ty.set(r, o, l).unproject(n);
  const u = e[i];
  if (u !== void 0) {
    const d = t.getAttribute("position");
    for (let h = 0, m = u.length; h < m; h++)
      d.setXYZ(u[h], Ty.x, Ty.y, Ty.z);
  }
}
const wy = /* @__PURE__ */ new as();
class c4 extends So {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), o = new gn();
    o.setIndex(new Vn(n, 1)), o.setAttribute("position", new Vn(r, 3)), super(o, new os({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && wy.setFromObject(this.object), wy.isEmpty()) return;
    const t = wy.min, n = wy.max, r = this.geometry.attributes.position, o = r.array;
    o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = t.x, o[4] = n.y, o[5] = n.z, o[6] = t.x, o[7] = t.y, o[8] = n.z, o[9] = n.x, o[10] = t.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = t.z, o[15] = t.x, o[16] = n.y, o[17] = t.z, o[18] = t.x, o[19] = t.y, o[20] = t.z, o[21] = n.x, o[22] = t.y, o[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class f4 extends So {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new gn();
    o.setIndex(new Vn(n, 1)), o.setAttribute("position", new Ot(r, 3)), super(o, new os({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class d4 extends yu {
  constructor(e, t = 1, n = 16776960) {
    const r = n, o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], l = new gn();
    l.setAttribute("position", new Ot(o, 3)), l.computeBoundingSphere(), super(l, new os({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], d = new gn();
    d.setAttribute("position", new Ot(u, 3)), d.computeBoundingSphere(), this.add(new ir(d, new Mu({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const oR = /* @__PURE__ */ new j();
let Ay, kS;
class h4 extends Dn {
  // dir is assumed to be normalized
  constructor(e = new j(0, 0, 1), t = new j(0, 0, 0), n = 1, r = 16776960, o = n * 0.2, l = o * 0.2) {
    super(), this.type = "ArrowHelper", Ay === void 0 && (Ay = new gn(), Ay.setAttribute("position", new Ot([0, 0, 0, 0, 1, 0], 3)), kS = new uh(0, 0.5, 1, 5, 1), kS.translate(0, -0.5, 0)), this.position.copy(t), this.line = new yu(Ay, new os({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ir(kS, new Mu({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, o, l);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      oR.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(oR, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class p4 extends So {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new gn();
    r.setAttribute("position", new Ot(t, 3)), r.setAttribute("color", new Ot(n, 3));
    const o = new os({ vertexColors: !0, toneMapped: !1 });
    super(r, o), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const r = new Tt(), o = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(o, 0), r.toArray(o, 3), r.set(t), r.toArray(o, 6), r.toArray(o, 9), r.set(n), r.toArray(o, 12), r.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class m4 {
  constructor() {
    this.type = "ShapePath", this.color = new Tt(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new ym(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, r) {
    return this.currentPath.quadraticCurveTo(e, t, n, r), this;
  }
  bezierCurveTo(e, t, n, r, o, l) {
    return this.currentPath.bezierCurveTo(e, t, n, r, o, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(M) {
      const C = [];
      for (let A = 0, N = M.length; A < N; A++) {
        const z = M[A], I = new Fc();
        I.curves = z.curves, C.push(I);
      }
      return C;
    }
    function n(M, C) {
      const A = C.length;
      let N = !1;
      for (let z = A - 1, I = 0; I < A; z = I++) {
        let V = C[z], W = C[I], U = W.x - V.x, O = W.y - V.y;
        if (Math.abs(O) > Number.EPSILON) {
          if (O < 0 && (V = C[I], U = -U, W = C[z], O = -O), M.y < V.y || M.y > W.y) continue;
          if (M.y === V.y) {
            if (M.x === V.x) return !0;
          } else {
            const q = O * (M.x - V.x) - U * (M.y - V.y);
            if (q === 0) return !0;
            if (q < 0) continue;
            N = !N;
          }
        } else {
          if (M.y !== V.y) continue;
          if (W.x <= M.x && M.x <= V.x || V.x <= M.x && M.x <= W.x) return !0;
        }
      }
      return N;
    }
    const r = go.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    let l, u, d;
    const h = [];
    if (o.length === 1)
      return u = o[0], d = new Fc(), d.curves = u.curves, h.push(d), h;
    let m = !r(o[0].getPoints());
    m = e ? !m : m;
    const g = [], y = [];
    let _ = [], E = 0, w;
    y[E] = void 0, _[E] = [];
    for (let M = 0, C = o.length; M < C; M++)
      u = o[M], w = u.getPoints(), l = r(w), l = e ? !l : l, l ? (!m && y[E] && E++, y[E] = { s: new Fc(), p: w }, y[E].s.curves = u.curves, m && E++, _[E] = []) : _[E].push({ h: u, p: w[0] });
    if (!y[0]) return t(o);
    if (y.length > 1) {
      let M = !1, C = 0;
      for (let A = 0, N = y.length; A < N; A++)
        g[A] = [];
      for (let A = 0, N = y.length; A < N; A++) {
        const z = _[A];
        for (let I = 0; I < z.length; I++) {
          const V = z[I];
          let W = !0;
          for (let U = 0; U < y.length; U++)
            n(V.p, y[U].p) && (A !== U && C++, W ? (W = !1, g[U].push(V)) : M = !0);
          W && g[A].push(V);
        }
      }
      C > 0 && M === !1 && (_ = g);
    }
    let T;
    for (let M = 0, C = y.length; M < C; M++) {
      d = y[M].s, h.push(d), T = _[M];
      for (let A = 0, N = T.length; A < N; A++)
        d.holes.push(T[A].h);
    }
    return h;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: l0
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = l0);
const v4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: wE,
  AddEquation: uu,
  AddOperation: fP,
  AdditiveAnimationBlendMode: OE,
  AdditiveBlending: gM,
  AgXToneMapping: vP,
  AlphaFormat: _P,
  AlwaysCompare: zP,
  AlwaysDepth: rP,
  AlwaysStencilFunc: qM,
  AmbientLight: zL,
  AnimationAction: jL,
  AnimationClip: bm,
  AnimationLoader: yk,
  AnimationMixer: Yk,
  AnimationObjectGroup: Xk,
  AnimationUtils: pk,
  ArcCurve: cL,
  ArrayCamera: eL,
  ArrowHelper: h4,
  AttachedBindMode: MM,
  Audio: WL,
  AudioAnalyser: Ok,
  AudioContext: fb,
  AudioListener: Dk,
  AudioLoader: Ck,
  AxesHelper: p4,
  BackSide: ss,
  BasicDepthPacking: CP,
  BasicShadowMap: VC,
  BatchedMesh: oL,
  Bone: KE,
  BooleanKeyframeTrack: Xc,
  Box2: $k,
  Box3: as,
  Box3Helper: f4,
  BoxGeometry: Wc,
  BoxHelper: c4,
  BufferAttribute: Vn,
  BufferGeometry: gn,
  BufferGeometryLoader: GL,
  ByteType: yP,
  Cache: el,
  Camera: Nm,
  CameraHelper: u4,
  CanvasTexture: zH,
  CapsuleGeometry: M0,
  CatmullRomCurve3: fL,
  CineonToneMapping: pP,
  CircleGeometry: E0,
  ClampToEdgeWrapping: Wr,
  Clock: db,
  Color: Tt,
  ColorKeyframeTrack: lb,
  ColorManagement: zn,
  CompressedArrayTexture: IH,
  CompressedCubeTexture: FH,
  CompressedTexture: _0,
  CompressedTextureLoader: xk,
  ConeGeometry: b0,
  ConstantAlphaFactor: tP,
  ConstantColorFactor: $C,
  CubeCamera: XP,
  CubeReflectionMapping: al,
  CubeRefractionMapping: vu,
  CubeTexture: Um,
  CubeTextureLoader: _k,
  CubeUVReflectionMapping: oh,
  CubicBezierCurve: $E,
  CubicBezierCurve3: dL,
  CubicInterpolant: PL,
  CullFaceBack: vM,
  CullFaceFront: BC,
  CullFaceFrontBack: TO,
  CullFaceNone: zC,
  Curve: Ga,
  CurvePath: pL,
  CustomBlending: HC,
  CustomToneMapping: mP,
  CylinderGeometry: uh,
  Cylindrical: Qk,
  Data3DTexture: VE,
  DataArrayTexture: p0,
  DataTexture: Ic,
  DataTextureLoader: Sk,
  DataUtils: OI,
  DecrementStencilOp: FO,
  DecrementWrapStencilOp: BO,
  DefaultLoadingManager: NL,
  DepthFormat: fu,
  DepthStencilFormat: Bc,
  DepthTexture: WE,
  DetachedBindMode: gP,
  DirectionalLight: FL,
  DirectionalLightHelper: l4,
  DiscreteInterpolant: LL,
  DisplayP3ColorSpace: h0,
  DodecahedronGeometry: T0,
  DoubleSide: po,
  DstAlphaFactor: qC,
  DstColorFactor: KC,
  DynamicCopyUsage: eI,
  DynamicDrawUsage: qO,
  DynamicReadUsage: JO,
  EdgesGeometry: mL,
  EllipseCurve: S0,
  EqualCompare: UP,
  EqualDepth: aP,
  EqualStencilFunc: GO,
  EquirectangularReflectionMapping: am,
  EquirectangularRefractionMapping: om,
  Euler: Dm,
  EventDispatcher: ul,
  ExtrudeGeometry: A0,
  FileLoader: ol,
  Float16BufferAttribute: HI,
  Float32BufferAttribute: Ot,
  Float64BufferAttribute: kI,
  FloatType: Va,
  Fog: g0,
  FogExp2: v0,
  FramebufferTexture: OH,
  FrontSide: sl,
  Frustum: Om,
  GLBufferAttribute: Jk,
  GLSL1: nI,
  GLSL3: ZM,
  GreaterCompare: OP,
  GreaterDepth: lP,
  GreaterEqualCompare: FP,
  GreaterEqualDepth: oP,
  GreaterEqualStencilFunc: YO,
  GreaterStencilFunc: XO,
  GridHelper: a4,
  Group: Wd,
  HalfFloatType: Qd,
  HemisphereLight: UL,
  HemisphereLightHelper: s4,
  IcosahedronGeometry: R0,
  ImageBitmapLoader: Rk,
  ImageLoader: Tm,
  ImageUtils: BE,
  IncrementStencilOp: IO,
  IncrementWrapStencilOp: zO,
  InstancedBufferAttribute: nh,
  InstancedBufferGeometry: kL,
  InstancedInterleavedBuffer: Kk,
  InstancedMesh: aL,
  Int16BufferAttribute: BI,
  Int32BufferAttribute: VI,
  Int8BufferAttribute: II,
  IntType: RE,
  InterleavedBuffer: y0,
  InterleavedBufferAttribute: Vc,
  Interpolant: Vm,
  InterpolateDiscrete: cm,
  InterpolateLinear: fm,
  InterpolateSmooth: Hy,
  InvertStencilOp: VO,
  KeepStencilOp: Mc,
  KeyframeTrack: Wa,
  LOD: rL,
  LatheGeometry: Fm,
  Layers: Oc,
  LessCompare: NP,
  LessDepth: sP,
  LessEqualCompare: FE,
  LessEqualDepth: sm,
  LessEqualStencilFunc: WO,
  LessStencilFunc: kO,
  Light: bu,
  LightProbe: HL,
  Line: yu,
  Line3: e4,
  LineBasicMaterial: os,
  LineCurve: eb,
  LineCurve3: hL,
  LineDashedMaterial: AL,
  LineLoop: lL,
  LineSegments: So,
  LinearDisplayP3ColorSpace: Lm,
  LinearEncoding: IE,
  LinearFilter: Oi,
  LinearInterpolant: ob,
  LinearMipMapLinearFilter: PO,
  LinearMipMapNearestFilter: CO,
  LinearMipmapLinearFilter: gu,
  LinearMipmapNearestFilter: AE,
  LinearSRGBColorSpace: xo,
  LinearToneMapping: dP,
  LinearTransfer: hm,
  Loader: Ts,
  LoaderUtils: iE,
  LoadingManager: ub,
  LoopOnce: wP,
  LoopPingPong: RP,
  LoopRepeat: AP,
  LuminanceAlphaFormat: MP,
  LuminanceFormat: SP,
  MOUSE: _c,
  Material: Yr,
  MaterialLoader: O0,
  MathUtils: gI,
  Matrix3: vn,
  Matrix4: $t,
  MaxEquation: SM,
  Mesh: ir,
  MeshBasicMaterial: Mu,
  MeshDepthMaterial: XE,
  MeshDistanceMaterial: jE,
  MeshLambertMaterial: TL,
  MeshMatcapMaterial: wL,
  MeshNormalMaterial: bL,
  MeshPhongMaterial: ML,
  MeshPhysicalMaterial: sb,
  MeshStandardMaterial: rb,
  MeshToonMaterial: EL,
  MinEquation: _M,
  MirroredRepeatWrapping: um,
  MixOperation: cP,
  MultiplyBlending: xM,
  MultiplyOperation: Pm,
  NearestFilter: Ui,
  NearestMipMapLinearFilter: RO,
  NearestMipMapNearestFilter: AO,
  NearestMipmapLinearFilter: Kp,
  NearestMipmapNearestFilter: qy,
  NeverCompare: DP,
  NeverDepth: iP,
  NeverStencilFunc: HO,
  NoBlending: nl,
  NoColorSpace: Vs,
  NoToneMapping: mo,
  NormalAnimationBlendMode: d0,
  NormalBlending: Nc,
  NotEqualCompare: IP,
  NotEqualDepth: uP,
  NotEqualStencilFunc: jO,
  NumberKeyframeTrack: Mm,
  Object3D: Dn,
  ObjectLoader: wk,
  ObjectSpaceNormalMap: LP,
  OctahedronGeometry: zm,
  OneFactor: XC,
  OneMinusConstantAlphaFactor: nP,
  OneMinusConstantColorFactor: eP,
  OneMinusDstAlphaFactor: ZC,
  OneMinusDstColorFactor: JC,
  OneMinusSrcAlphaFactor: Yy,
  OneMinusSrcColorFactor: YC,
  OrthographicCamera: hu,
  P3Primaries: mm,
  PCFShadowMap: u0,
  PCFSoftShadowMap: Zp,
  PMREMGenerator: JM,
  Path: ym,
  PerspectiveCamera: Ii,
  Plane: Jo,
  PlaneGeometry: Im,
  PlaneHelper: d4,
  PointLight: IL,
  PointLightHelper: i4,
  Points: uL,
  PointsMaterial: JE,
  PolarGridHelper: o4,
  PolyhedronGeometry: Eu,
  PositionalAudio: Uk,
  PropertyBinding: Pn,
  PropertyMixer: XL,
  QuadraticBezierCurve: tb,
  QuadraticBezierCurve3: nb,
  Quaternion: Xr,
  QuaternionKeyframeTrack: ch,
  QuaternionLinearInterpolant: DL,
  RED_GREEN_RGTC2_Format: jM,
  RED_RGTC1_Format: TP,
  REVISION: l0,
  RGBADepthPacking: PP,
  RGBAFormat: is,
  RGBAIntegerFormat: NE,
  RGBA_ASTC_10x10_Format: VM,
  RGBA_ASTC_10x5_Format: FM,
  RGBA_ASTC_10x6_Format: zM,
  RGBA_ASTC_10x8_Format: BM,
  RGBA_ASTC_12x10_Format: HM,
  RGBA_ASTC_12x12_Format: kM,
  RGBA_ASTC_4x4_Format: CM,
  RGBA_ASTC_5x4_Format: PM,
  RGBA_ASTC_5x5_Format: LM,
  RGBA_ASTC_6x5_Format: DM,
  RGBA_ASTC_6x6_Format: NM,
  RGBA_ASTC_8x5_Format: UM,
  RGBA_ASTC_8x6_Format: OM,
  RGBA_ASTC_8x8_Format: IM,
  RGBA_BPTC_Format: Vy,
  RGBA_ETC2_EAC_Format: RM,
  RGBA_PVRTC_2BPPV1_Format: wM,
  RGBA_PVRTC_4BPPV1_Format: TM,
  RGBA_S3TC_DXT1_Format: Fy,
  RGBA_S3TC_DXT3_Format: zy,
  RGBA_S3TC_DXT5_Format: By,
  RGB_BPTC_SIGNED_Format: GM,
  RGB_BPTC_UNSIGNED_Format: WM,
  RGB_ETC1_Format: UE,
  RGB_ETC2_Format: AM,
  RGB_PVRTC_2BPPV1_Format: bM,
  RGB_PVRTC_4BPPV1_Format: EM,
  RGB_S3TC_DXT1_Format: Iy,
  RGFormat: bP,
  RGIntegerFormat: DE,
  RawShaderMaterial: SL,
  Ray: Gc,
  Raycaster: YL,
  Rec709Primaries: pm,
  RectAreaLight: BL,
  RedFormat: EP,
  RedIntegerFormat: LE,
  ReinhardToneMapping: hP,
  RenderTarget: HP,
  RepeatWrapping: lm,
  ReplaceStencilOp: OO,
  ReverseSubtractEquation: GC,
  RingGeometry: C0,
  SIGNED_RED_GREEN_RGTC2_Format: YM,
  SIGNED_RED_RGTC1_Format: XM,
  SRGBColorSpace: nr,
  SRGBTransfer: Yn,
  Scene: qE,
  ShaderChunk: fn,
  ShaderLib: Ba,
  ShaderMaterial: _o,
  ShadowMaterial: _L,
  Shape: Fc,
  ShapeGeometry: P0,
  ShapePath: m4,
  ShapeUtils: go,
  ShortType: xP,
  Skeleton: x0,
  SkeletonHelper: n4,
  SkinnedMesh: sL,
  Source: Pc,
  Sphere: jr,
  SphereGeometry: Bm,
  Spherical: sE,
  SphericalHarmonics3: VL,
  SplineCurve: ib,
  SpotLight: OL,
  SpotLightHelper: t4,
  Sprite: iL,
  SpriteMaterial: ZE,
  SrcAlphaFactor: jy,
  SrcAlphaSaturateFactor: QC,
  SrcColorFactor: jC,
  StaticCopyUsage: $O,
  StaticDrawUsage: vm,
  StaticReadUsage: KO,
  StereoCamera: Pk,
  StreamCopyUsage: tI,
  StreamDrawUsage: ZO,
  StreamReadUsage: QO,
  StringKeyframeTrack: jc,
  SubtractEquation: kC,
  SubtractiveBlending: yM,
  TOUCH: Sc,
  TangentSpaceNormalMap: Su,
  TetrahedronGeometry: L0,
  Texture: Fi,
  TextureLoader: Mk,
  TorusGeometry: D0,
  TorusKnotGeometry: N0,
  Triangle: Ms,
  TriangleFanDrawMode: NO,
  TriangleStripDrawMode: DO,
  TrianglesDrawMode: LO,
  TubeGeometry: U0,
  TwoPassDoubleSide: wO,
  UVMapping: c0,
  Uint16BufferAttribute: HE,
  Uint32BufferAttribute: kE,
  Uint8BufferAttribute: FI,
  Uint8ClampedBufferAttribute: zI,
  Uniform: mb,
  UniformsGroup: Zk,
  UniformsLib: ft,
  UniformsUtils: WP,
  UnsignedByteType: vo,
  UnsignedInt248Type: cu,
  UnsignedIntType: $o,
  UnsignedShort4444Type: CE,
  UnsignedShort5551Type: PE,
  UnsignedShortType: f0,
  VSMShadowMap: za,
  Vector2: Oe,
  Vector3: j,
  Vector4: Bn,
  VectorKeyframeTrack: Em,
  VideoTexture: UH,
  WebGL1Renderer: tL,
  WebGL3DRenderTarget: EI,
  WebGLArrayRenderTarget: MI,
  WebGLCoordinateSystem: Ha,
  WebGLCubeRenderTarget: jP,
  WebGLMultipleRenderTargets: bI,
  WebGLRenderTarget: ka,
  WebGLRenderer: YE,
  WebGLUtils: $P,
  WebGPUCoordinateSystem: $d,
  WireframeGeometry: xL,
  WrapAroundEnding: dm,
  ZeroCurvatureEnding: Rc,
  ZeroFactor: WC,
  ZeroSlopeEnding: Cc,
  ZeroStencilOp: UO,
  _SRGBAFormat: Zy,
  createCanvasElement: VP,
  sRGBEncoding: du
}, Symbol.toStringTag, { value: "Module" }));
var aE = { exports: {} }, ru = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lR;
function g4() {
  return lR || (lR = 1, ru.ConcurrentRoot = 1, ru.ContinuousEventPriority = 4, ru.DefaultEventPriority = 16, ru.DiscreteEventPriority = 1, ru.IdleEventPriority = 536870912, ru.LegacyRoot = 0), ru;
}
var su = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uR;
function y4() {
  return uR || (uR = 1, process.env.NODE_ENV !== "production" && function() {
    var i = (
      /*                        */
      1
    ), e = (
      /*            */
      4
    ), t = (
      /*                    */
      16
    ), n = (
      /*                       */
      536870912
    ), r = i, o = e, l = t, u = n, d = 0, h = 1;
    su.ConcurrentRoot = h, su.ContinuousEventPriority = o, su.DefaultEventPriority = l, su.DiscreteEventPriority = r, su.IdleEventPriority = u, su.LegacyRoot = d;
  }()), su;
}
process.env.NODE_ENV === "production" ? aE.exports = g4() : aE.exports = y4();
var jd = aE.exports;
function x4(i) {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (h, m) => {
    const g = typeof h == "function" ? h(e) : h;
    if (g !== e) {
      const y = e;
      e = m ? g : Object.assign({}, e, g), t.forEach((_) => _(e, y));
    }
  }, r = () => e, o = (h, m = r, g = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let y = m(e);
    function _() {
      const E = m(e);
      if (!g(y, E)) {
        const w = y;
        h(y = E, w);
      }
    }
    return t.add(_), () => t.delete(_);
  }, d = { setState: n, getState: r, subscribe: (h, m, g) => m || g ? o(h, m, g) : (t.add(h), () => t.delete(h)), destroy: () => t.clear() };
  return e = i(n, r, d), d;
}
const _4 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), cR = _4 ? Hs : IC;
function S4(i) {
  const e = typeof i == "function" ? x4(i) : i, t = (n = e.getState, r = Object.is) => {
    const [, o] = pO((T) => T + 1, 0), l = e.getState(), u = fr(l), d = fr(n), h = fr(r), m = fr(!1), g = fr();
    g.current === void 0 && (g.current = n(l));
    let y, _ = !1;
    (u.current !== l || d.current !== n || h.current !== r || m.current) && (y = n(l), _ = !r(g.current, y)), cR(() => {
      _ && (g.current = y), u.current = l, d.current = n, h.current = r, m.current = !1;
    });
    const E = fr(l);
    cR(() => {
      const T = () => {
        try {
          const C = e.getState(), A = d.current(C);
          h.current(g.current, A) || (u.current = C, g.current = A, o());
        } catch {
          m.current = !0, o();
        }
      }, M = e.subscribe(T);
      return e.getState() !== E.current && T(), M;
    }, []);
    const w = _ ? y : g.current;
    return mO(w), w;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const n = [t, e];
    return {
      next() {
        const r = n.length <= 0;
        return { value: n.shift(), done: r };
      }
    };
  }, t;
}
var oE = { exports: {} }, lE = { exports: {} }, GS = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fR;
function M4() {
  return fR || (fR = 1, function(i) {
    function e(Q, se) {
      var re = Q.length;
      Q.push(se);
      e: for (; 0 < re; ) {
        var ue = re - 1 >>> 1, Le = Q[ue];
        if (0 < r(Le, se)) Q[ue] = se, Q[re] = Le, re = ue;
        else break e;
      }
    }
    function t(Q) {
      return Q.length === 0 ? null : Q[0];
    }
    function n(Q) {
      if (Q.length === 0) return null;
      var se = Q[0], re = Q.pop();
      if (re !== se) {
        Q[0] = re;
        e: for (var ue = 0, Le = Q.length, pe = Le >>> 1; ue < pe; ) {
          var Ae = 2 * (ue + 1) - 1, qe = Q[Ae], je = Ae + 1, $e = Q[je];
          if (0 > r(qe, re)) je < Le && 0 > r($e, qe) ? (Q[ue] = $e, Q[je] = re, ue = je) : (Q[ue] = qe, Q[Ae] = re, ue = Ae);
          else if (je < Le && 0 > r($e, re)) Q[ue] = $e, Q[je] = re, ue = je;
          else break e;
        }
      }
      return se;
    }
    function r(Q, se) {
      var re = Q.sortIndex - se.sortIndex;
      return re !== 0 ? re : Q.id - se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      i.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, u = l.now();
      i.unstable_now = function() {
        return l.now() - u;
      };
    }
    var d = [], h = [], m = 1, g = null, y = 3, _ = !1, E = !1, w = !1, T = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, C = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function A(Q) {
      for (var se = t(h); se !== null; ) {
        if (se.callback === null) n(h);
        else if (se.startTime <= Q) n(h), se.sortIndex = se.expirationTime, e(d, se);
        else break;
        se = t(h);
      }
    }
    function N(Q) {
      if (w = !1, A(Q), !E) if (t(d) !== null) E = !0, ie(z);
      else {
        var se = t(h);
        se !== null && Ee(N, se.startTime - Q);
      }
    }
    function z(Q, se) {
      E = !1, w && (w = !1, M(W), W = -1), _ = !0;
      var re = y;
      try {
        for (A(se), g = t(d); g !== null && (!(g.expirationTime > se) || Q && !q()); ) {
          var ue = g.callback;
          if (typeof ue == "function") {
            g.callback = null, y = g.priorityLevel;
            var Le = ue(g.expirationTime <= se);
            se = i.unstable_now(), typeof Le == "function" ? g.callback = Le : g === t(d) && n(d), A(se);
          } else n(d);
          g = t(d);
        }
        if (g !== null) var pe = !0;
        else {
          var Ae = t(h);
          Ae !== null && Ee(N, Ae.startTime - se), pe = !1;
        }
        return pe;
      } finally {
        g = null, y = re, _ = !1;
      }
    }
    var I = !1, V = null, W = -1, U = 5, O = -1;
    function q() {
      return !(i.unstable_now() - O < U);
    }
    function le() {
      if (V !== null) {
        var Q = i.unstable_now();
        O = Q;
        var se = !0;
        try {
          se = V(!0, Q);
        } finally {
          se ? ye() : (I = !1, V = null);
        }
      } else I = !1;
    }
    var ye;
    if (typeof C == "function") ye = function() {
      C(le);
    };
    else if (typeof MessageChannel < "u") {
      var K = new MessageChannel(), oe = K.port2;
      K.port1.onmessage = le, ye = function() {
        oe.postMessage(null);
      };
    } else ye = function() {
      T(le, 0);
    };
    function ie(Q) {
      V = Q, I || (I = !0, ye());
    }
    function Ee(Q, se) {
      W = T(function() {
        Q(i.unstable_now());
      }, se);
    }
    i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function(Q) {
      Q.callback = null;
    }, i.unstable_continueExecution = function() {
      E || _ || (E = !0, ie(z));
    }, i.unstable_forceFrameRate = function(Q) {
      0 > Q || 125 < Q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : U = 0 < Q ? Math.floor(1e3 / Q) : 5;
    }, i.unstable_getCurrentPriorityLevel = function() {
      return y;
    }, i.unstable_getFirstCallbackNode = function() {
      return t(d);
    }, i.unstable_next = function(Q) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var se = 3;
          break;
        default:
          se = y;
      }
      var re = y;
      y = se;
      try {
        return Q();
      } finally {
        y = re;
      }
    }, i.unstable_pauseExecution = function() {
    }, i.unstable_requestPaint = function() {
    }, i.unstable_runWithPriority = function(Q, se) {
      switch (Q) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Q = 3;
      }
      var re = y;
      y = Q;
      try {
        return se();
      } finally {
        y = re;
      }
    }, i.unstable_scheduleCallback = function(Q, se, re) {
      var ue = i.unstable_now();
      switch (typeof re == "object" && re !== null ? (re = re.delay, re = typeof re == "number" && 0 < re ? ue + re : ue) : re = ue, Q) {
        case 1:
          var Le = -1;
          break;
        case 2:
          Le = 250;
          break;
        case 5:
          Le = 1073741823;
          break;
        case 4:
          Le = 1e4;
          break;
        default:
          Le = 5e3;
      }
      return Le = re + Le, Q = { id: m++, callback: se, priorityLevel: Q, startTime: re, expirationTime: Le, sortIndex: -1 }, re > ue ? (Q.sortIndex = re, e(h, Q), t(d) === null && Q === t(h) && (w ? (M(W), W = -1) : w = !0, Ee(N, re - ue))) : (Q.sortIndex = Le, e(d, Q), E || _ || (E = !0, ie(z))), Q;
    }, i.unstable_shouldYield = q, i.unstable_wrapCallback = function(Q) {
      var se = y;
      return function() {
        var re = y;
        y = se;
        try {
          return Q.apply(this, arguments);
        } finally {
          y = re;
        }
      };
    };
  }(GS)), GS;
}
var WS = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dR;
function E4() {
  return dR || (dR = 1, function(i) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = 5;
      function n(de, nt) {
        var lt = de.length;
        de.push(nt), l(de, nt, lt);
      }
      function r(de) {
        return de.length === 0 ? null : de[0];
      }
      function o(de) {
        if (de.length === 0)
          return null;
        var nt = de[0], lt = de.pop();
        return lt !== nt && (de[0] = lt, u(de, lt, 0)), nt;
      }
      function l(de, nt, lt) {
        for (var Xe = lt; Xe > 0; ) {
          var dt = Xe - 1 >>> 1, at = de[dt];
          if (d(at, nt) > 0)
            de[dt] = nt, de[Xe] = at, Xe = dt;
          else
            return;
        }
      }
      function u(de, nt, lt) {
        for (var Xe = lt, dt = de.length, at = dt >>> 1; Xe < at; ) {
          var Y = (Xe + 1) * 2 - 1, he = de[Y], Ze = Y + 1, Ve = de[Ze];
          if (d(he, nt) < 0)
            Ze < dt && d(Ve, he) < 0 ? (de[Xe] = Ve, de[Ze] = nt, Xe = Ze) : (de[Xe] = he, de[Y] = nt, Xe = Y);
          else if (Ze < dt && d(Ve, nt) < 0)
            de[Xe] = Ve, de[Ze] = nt, Xe = Ze;
          else
            return;
        }
      }
      function d(de, nt) {
        var lt = de.sortIndex - nt.sortIndex;
        return lt !== 0 ? lt : de.id - nt.id;
      }
      var h = 1, m = 2, g = 3, y = 4, _ = 5;
      function E(de, nt) {
      }
      var w = typeof performance == "object" && typeof performance.now == "function";
      if (w) {
        var T = performance;
        i.unstable_now = function() {
          return T.now();
        };
      } else {
        var M = Date, C = M.now();
        i.unstable_now = function() {
          return M.now() - C;
        };
      }
      var A = 1073741823, N = -1, z = 250, I = 5e3, V = 1e4, W = A, U = [], O = [], q = 1, le = null, ye = g, K = !1, oe = !1, ie = !1, Ee = typeof setTimeout == "function" ? setTimeout : null, Q = typeof clearTimeout == "function" ? clearTimeout : null, se = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function re(de) {
        for (var nt = r(O); nt !== null; ) {
          if (nt.callback === null)
            o(O);
          else if (nt.startTime <= de)
            o(O), nt.sortIndex = nt.expirationTime, n(U, nt);
          else
            return;
          nt = r(O);
        }
      }
      function ue(de) {
        if (ie = !1, re(de), !oe)
          if (r(U) !== null)
            oe = !0, Mt(Le);
          else {
            var nt = r(O);
            nt !== null && it(ue, nt.startTime - de);
          }
      }
      function Le(de, nt) {
        oe = !1, ie && (ie = !1, mt()), K = !0;
        var lt = ye;
        try {
          var Xe;
          if (!e) return pe(de, nt);
        } finally {
          le = null, ye = lt, K = !1;
        }
      }
      function pe(de, nt) {
        var lt = nt;
        for (re(lt), le = r(U); le !== null && !(le.expirationTime > lt && (!de || rt())); ) {
          var Xe = le.callback;
          if (typeof Xe == "function") {
            le.callback = null, ye = le.priorityLevel;
            var dt = le.expirationTime <= lt, at = Xe(dt);
            lt = i.unstable_now(), typeof at == "function" ? le.callback = at : le === r(U) && o(U), re(lt);
          } else
            o(U);
          le = r(U);
        }
        if (le !== null)
          return !0;
        var Y = r(O);
        return Y !== null && it(ue, Y.startTime - lt), !1;
      }
      function Ae(de, nt) {
        switch (de) {
          case h:
          case m:
          case g:
          case y:
          case _:
            break;
          default:
            de = g;
        }
        var lt = ye;
        ye = de;
        try {
          return nt();
        } finally {
          ye = lt;
        }
      }
      function qe(de) {
        var nt;
        switch (ye) {
          case h:
          case m:
          case g:
            nt = g;
            break;
          default:
            nt = ye;
            break;
        }
        var lt = ye;
        ye = nt;
        try {
          return de();
        } finally {
          ye = lt;
        }
      }
      function je(de) {
        var nt = ye;
        return function() {
          var lt = ye;
          ye = nt;
          try {
            return de.apply(this, arguments);
          } finally {
            ye = lt;
          }
        };
      }
      function $e(de, nt, lt) {
        var Xe = i.unstable_now(), dt;
        if (typeof lt == "object" && lt !== null) {
          var at = lt.delay;
          typeof at == "number" && at > 0 ? dt = Xe + at : dt = Xe;
        } else
          dt = Xe;
        var Y;
        switch (de) {
          case h:
            Y = N;
            break;
          case m:
            Y = z;
            break;
          case _:
            Y = W;
            break;
          case y:
            Y = V;
            break;
          case g:
          default:
            Y = I;
            break;
        }
        var he = dt + Y, Ze = {
          id: q++,
          callback: nt,
          priorityLevel: de,
          startTime: dt,
          expirationTime: he,
          sortIndex: -1
        };
        return dt > Xe ? (Ze.sortIndex = dt, n(O, Ze), r(U) === null && Ze === r(O) && (ie ? mt() : ie = !0, it(ue, dt - Xe))) : (Ze.sortIndex = he, n(U, Ze), !oe && !K && (oe = !0, Mt(Le))), Ze;
      }
      function Rt() {
      }
      function Ut() {
        !oe && !K && (oe = !0, Mt(Le));
      }
      function ot() {
        return r(U);
      }
      function pt(de) {
        de.callback = null;
      }
      function J() {
        return ye;
      }
      var Be = !1, Pe = null, He = -1, Re = t, _t = -1;
      function rt() {
        var de = i.unstable_now() - _t;
        return !(de < Re);
      }
      function G() {
      }
      function B(de) {
        if (de < 0 || de > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        de > 0 ? Re = Math.floor(1e3 / de) : Re = t;
      }
      var ce = function() {
        if (Pe !== null) {
          var de = i.unstable_now();
          _t = de;
          var nt = !0, lt = !0;
          try {
            lt = Pe(nt, de);
          } finally {
            lt ? Fe() : (Be = !1, Pe = null);
          }
        } else
          Be = !1;
      }, Fe;
      if (typeof se == "function")
        Fe = function() {
          se(ce);
        };
      else if (typeof MessageChannel < "u") {
        var ze = new MessageChannel(), Ie = ze.port2;
        ze.port1.onmessage = ce, Fe = function() {
          Ie.postMessage(null);
        };
      } else
        Fe = function() {
          Ee(ce, 0);
        };
      function Mt(de) {
        Pe = de, Be || (Be = !0, Fe());
      }
      function it(de, nt) {
        He = Ee(function() {
          de(i.unstable_now());
        }, nt);
      }
      function mt() {
        Q(He), He = -1;
      }
      var Dt = G, Ht = null;
      i.unstable_IdlePriority = _, i.unstable_ImmediatePriority = h, i.unstable_LowPriority = y, i.unstable_NormalPriority = g, i.unstable_Profiling = Ht, i.unstable_UserBlockingPriority = m, i.unstable_cancelCallback = pt, i.unstable_continueExecution = Ut, i.unstable_forceFrameRate = B, i.unstable_getCurrentPriorityLevel = J, i.unstable_getFirstCallbackNode = ot, i.unstable_next = qe, i.unstable_pauseExecution = Rt, i.unstable_requestPaint = Dt, i.unstable_runWithPriority = Ae, i.unstable_scheduleCallback = $e, i.unstable_shouldYield = rt, i.unstable_wrapCallback = je, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(WS)), WS;
}
process.env.NODE_ENV === "production" ? lE.exports = M4() : lE.exports = E4();
var Qy = lE.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XS, hR;
function b4() {
  return hR || (hR = 1, XS = function(e) {
    var t = {}, n = kc, r = Qy, o = Object.assign;
    function l(c) {
      for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, x = 1; x < arguments.length; x++) f += "&args[]=" + encodeURIComponent(arguments[x]);
      return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, d = Symbol.for("react.element"), h = Symbol.for("react.portal"), m = Symbol.for("react.fragment"), g = Symbol.for("react.strict_mode"), y = Symbol.for("react.profiler"), _ = Symbol.for("react.provider"), E = Symbol.for("react.context"), w = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), C = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), z = Symbol.iterator;
    function I(c) {
      return c === null || typeof c != "object" ? null : (c = z && c[z] || c["@@iterator"], typeof c == "function" ? c : null);
    }
    function V(c) {
      if (c == null) return null;
      if (typeof c == "function") return c.displayName || c.name || null;
      if (typeof c == "string") return c;
      switch (c) {
        case m:
          return "Fragment";
        case h:
          return "Portal";
        case y:
          return "Profiler";
        case g:
          return "StrictMode";
        case T:
          return "Suspense";
        case M:
          return "SuspenseList";
      }
      if (typeof c == "object") switch (c.$$typeof) {
        case E:
          return (c.displayName || "Context") + ".Consumer";
        case _:
          return (c._context.displayName || "Context") + ".Provider";
        case w:
          var f = c.render;
          return c = c.displayName, c || (c = f.displayName || f.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
        case C:
          return f = c.displayName || null, f !== null ? f : V(c.type) || "Memo";
        case A:
          f = c._payload, c = c._init;
          try {
            return V(c(f));
          } catch {
          }
      }
      return null;
    }
    function W(c) {
      var f = c.type;
      switch (c.tag) {
        case 24:
          return "Cache";
        case 9:
          return (f.displayName || "Context") + ".Consumer";
        case 10:
          return (f._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return c = f.render, c = c.displayName || c.name || "", f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return f;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return V(f);
        case 8:
          return f === g ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof f == "function") return f.displayName || f.name || null;
          if (typeof f == "string") return f;
      }
      return null;
    }
    function U(c) {
      var f = c, x = c;
      if (c.alternate) for (; f.return; ) f = f.return;
      else {
        c = f;
        do
          f = c, f.flags & 4098 && (x = f.return), c = f.return;
        while (c);
      }
      return f.tag === 3 ? x : null;
    }
    function O(c) {
      if (U(c) !== c) throw Error(l(188));
    }
    function q(c) {
      var f = c.alternate;
      if (!f) {
        if (f = U(c), f === null) throw Error(l(188));
        return f !== c ? null : c;
      }
      for (var x = c, b = f; ; ) {
        var P = x.return;
        if (P === null) break;
        var D = P.alternate;
        if (D === null) {
          if (b = P.return, b !== null) {
            x = b;
            continue;
          }
          break;
        }
        if (P.child === D.child) {
          for (D = P.child; D; ) {
            if (D === x) return O(P), c;
            if (D === b) return O(P), f;
            D = D.sibling;
          }
          throw Error(l(188));
        }
        if (x.return !== b.return) x = P, b = D;
        else {
          for (var X = !1, ae = P.child; ae; ) {
            if (ae === x) {
              X = !0, x = P, b = D;
              break;
            }
            if (ae === b) {
              X = !0, b = P, x = D;
              break;
            }
            ae = ae.sibling;
          }
          if (!X) {
            for (ae = D.child; ae; ) {
              if (ae === x) {
                X = !0, x = D, b = P;
                break;
              }
              if (ae === b) {
                X = !0, b = D, x = P;
                break;
              }
              ae = ae.sibling;
            }
            if (!X) throw Error(l(189));
          }
        }
        if (x.alternate !== b) throw Error(l(190));
      }
      if (x.tag !== 3) throw Error(l(188));
      return x.stateNode.current === x ? c : f;
    }
    function le(c) {
      return c = q(c), c !== null ? ye(c) : null;
    }
    function ye(c) {
      if (c.tag === 5 || c.tag === 6) return c;
      for (c = c.child; c !== null; ) {
        var f = ye(c);
        if (f !== null) return f;
        c = c.sibling;
      }
      return null;
    }
    function K(c) {
      if (c.tag === 5 || c.tag === 6) return c;
      for (c = c.child; c !== null; ) {
        if (c.tag !== 4) {
          var f = K(c);
          if (f !== null) return f;
        }
        c = c.sibling;
      }
      return null;
    }
    var oe = Array.isArray, ie = e.getPublicInstance, Ee = e.getRootHostContext, Q = e.getChildHostContext, se = e.prepareForCommit, re = e.resetAfterCommit, ue = e.createInstance, Le = e.appendInitialChild, pe = e.finalizeInitialChildren, Ae = e.prepareUpdate, qe = e.shouldSetTextContent, je = e.createTextInstance, $e = e.scheduleTimeout, Rt = e.cancelTimeout, Ut = e.noTimeout, ot = e.isPrimaryRenderer, pt = e.supportsMutation, J = e.supportsPersistence, Be = e.supportsHydration, Pe = e.getInstanceFromNode, He = e.preparePortalMount, Re = e.getCurrentEventPriority, _t = e.detachDeletedInstance, rt = e.supportsMicrotasks, G = e.scheduleMicrotask, B = e.supportsTestSelectors, ce = e.findFiberRoot, Fe = e.getBoundingRect, ze = e.getTextContent, Ie = e.isHiddenSubtree, Mt = e.matchAccessibilityRole, it = e.setFocusIfFocusable, mt = e.setupIntersectionObserver, Dt = e.appendChild, Ht = e.appendChildToContainer, de = e.commitTextUpdate, nt = e.commitMount, lt = e.commitUpdate, Xe = e.insertBefore, dt = e.insertInContainerBefore, at = e.removeChild, Y = e.removeChildFromContainer, he = e.resetTextContent, Ze = e.hideInstance, Ve = e.hideTextInstance, Te = e.unhideInstance, ee = e.unhideTextInstance, Ke = e.clearContainer, st = e.cloneInstance, zt = e.createContainerChildSet, Ye = e.appendChildToContainerChildSet, qt = e.finalizeContainerChildren, tn = e.replaceContainerChildren, Sn = e.cloneHiddenInstance, bn = e.cloneHiddenTextInstance, Jt = e.canHydrateInstance, di = e.canHydrateTextInstance, hi = e.canHydrateSuspenseInstance, va = e.isSuspenseInstancePending, Mo = e.isSuspenseInstanceFallback, ws = e.registerSuspenseInstanceRetry, Zn = e.getNextHydratableSibling, $ = e.getFirstHydratableChild, ke = e.getFirstHydratableChildWithinContainer, vt = e.getFirstHydratableChildWithinSuspenseInstance, Ft = e.hydrateInstance, xn = e.hydrateTextInstance, hn = e.hydrateSuspenseInstance, k = e.getNextHydratableInstanceAfterSuspenseInstance, ne = e.commitHydratedContainer, ge = e.commitHydratedSuspenseInstance, ve = e.clearSuspenseBoundary, me = e.clearSuspenseBoundaryFromContainer, Qe = e.shouldDeleteUnhydratedTailInstances, wt = e.didNotMatchHydratedContainerTextInstance, Ct = e.didNotMatchHydratedTextInstance, At;
    function Wt(c) {
      if (At === void 0) try {
        throw Error();
      } catch (x) {
        var f = x.stack.trim().match(/\n( *(at )?)/);
        At = f && f[1] || "";
      }
      return `
` + At + c;
    }
    var Xt = !1;
    function Zt(c, f) {
      if (!c || Xt) return "";
      Xt = !0;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (f) if (f = function() {
          throw Error();
        }, Object.defineProperty(f.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(f, []);
          } catch (et) {
            var b = et;
          }
          Reflect.construct(c, [], f);
        } else {
          try {
            f.call();
          } catch (et) {
            b = et;
          }
          c.call(f.prototype);
        }
        else {
          try {
            throw Error();
          } catch (et) {
            b = et;
          }
          c();
        }
      } catch (et) {
        if (et && b && typeof et.stack == "string") {
          for (var P = et.stack.split(`
`), D = b.stack.split(`
`), X = P.length - 1, ae = D.length - 1; 1 <= X && 0 <= ae && P[X] !== D[ae]; ) ae--;
          for (; 1 <= X && 0 <= ae; X--, ae--) if (P[X] !== D[ae]) {
            if (X !== 1 || ae !== 1)
              do
                if (X--, ae--, 0 > ae || P[X] !== D[ae]) {
                  var Ce = `
` + P[X].replace(" at new ", " at ");
                  return c.displayName && Ce.includes("<anonymous>") && (Ce = Ce.replace("<anonymous>", c.displayName)), Ce;
                }
              while (1 <= X && 0 <= ae);
            break;
          }
        }
      } finally {
        Xt = !1, Error.prepareStackTrace = x;
      }
      return (c = c ? c.displayName || c.name : "") ? Wt(c) : "";
    }
    var kn = Object.prototype.hasOwnProperty, zi = [], Gn = -1;
    function bi(c) {
      return { current: c };
    }
    function jt(c) {
      0 > Gn || (c.current = zi[Gn], zi[Gn] = null, Gn--);
    }
    function ht(c, f) {
      Gn++, zi[Gn] = c.current, c.current = f;
    }
    var Ar = {}, on = bi(Ar), ti = bi(!1), Ws = Ar;
    function ls(c, f) {
      var x = c.type.contextTypes;
      if (!x) return Ar;
      var b = c.stateNode;
      if (b && b.__reactInternalMemoizedUnmaskedChildContext === f) return b.__reactInternalMemoizedMaskedChildContext;
      var P = {}, D;
      for (D in x) P[D] = f[D];
      return b && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = f, c.__reactInternalMemoizedMaskedChildContext = P), P;
    }
    function Bi(c) {
      return c = c.childContextTypes, c != null;
    }
    function Kn() {
      jt(ti), jt(on);
    }
    function As(c, f, x) {
      if (on.current !== Ar) throw Error(l(168));
      ht(on, f), ht(ti, x);
    }
    function Eo(c, f, x) {
      var b = c.stateNode;
      if (f = f.childContextTypes, typeof b.getChildContext != "function") return x;
      b = b.getChildContext();
      for (var P in b) if (!(P in f)) throw Error(l(108, W(c) || "Unknown", P));
      return o({}, x, b);
    }
    function Ti(c) {
      return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || Ar, Ws = on.current, ht(on, c), ht(ti, ti.current), !0;
    }
    function bo(c, f, x) {
      var b = c.stateNode;
      if (!b) throw Error(l(169));
      x ? (c = Eo(c, f, Ws), b.__reactInternalMemoizedMergedChildContext = c, jt(ti), jt(on), ht(on, c)) : jt(ti), ht(ti, x);
    }
    var Rr = Math.clz32 ? Math.clz32 : Kc, Zc = Math.log, fh = Math.LN2;
    function Kc(c) {
      return c >>>= 0, c === 0 ? 32 : 31 - (Zc(c) / fh | 0) | 0;
    }
    var Jc = 64, Cr = 4194304;
    function Xa(c) {
      switch (c & -c) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return c & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return c & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return c;
      }
    }
    function ar(c, f) {
      var x = c.pendingLanes;
      if (x === 0) return 0;
      var b = 0, P = c.suspendedLanes, D = c.pingedLanes, X = x & 268435455;
      if (X !== 0) {
        var ae = X & ~P;
        ae !== 0 ? b = Xa(ae) : (D &= X, D !== 0 && (b = Xa(D)));
      } else X = x & ~P, X !== 0 ? b = Xa(X) : D !== 0 && (b = Xa(D));
      if (b === 0) return 0;
      if (f !== 0 && f !== b && !(f & P) && (P = b & -b, D = f & -f, P >= D || P === 16 && (D & 4194240) !== 0)) return f;
      if (b & 4 && (b |= x & 16), f = c.entangledLanes, f !== 0) for (c = c.entanglements, f &= b; 0 < f; ) x = 31 - Rr(f), P = 1 << x, b |= c[x], f &= ~P;
      return b;
    }
    function W0(c, f) {
      switch (c) {
        case 1:
        case 2:
        case 4:
          return f + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return f + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function X0(c, f) {
      for (var x = c.suspendedLanes, b = c.pingedLanes, P = c.expirationTimes, D = c.pendingLanes; 0 < D; ) {
        var X = 31 - Rr(D), ae = 1 << X, Ce = P[X];
        Ce === -1 ? (!(ae & x) || ae & b) && (P[X] = W0(ae, f)) : Ce <= f && (c.expiredLanes |= ae), D &= ~ae;
      }
    }
    function dh(c) {
      return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
    }
    function hh(c) {
      for (var f = [], x = 0; 31 > x; x++) f.push(c);
      return f;
    }
    function wu(c, f, x) {
      c.pendingLanes |= f, f !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, f = 31 - Rr(f), c[f] = x;
    }
    function j0(c, f) {
      var x = c.pendingLanes & ~f;
      c.pendingLanes = f, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= f, c.mutableReadLanes &= f, c.entangledLanes &= f, f = c.entanglements;
      var b = c.eventTimes;
      for (c = c.expirationTimes; 0 < x; ) {
        var P = 31 - Rr(x), D = 1 << P;
        f[P] = 0, b[P] = -1, c[P] = -1, x &= ~D;
      }
    }
    function ja(c, f) {
      var x = c.entangledLanes |= f;
      for (c = c.entanglements; x; ) {
        var b = 31 - Rr(x), P = 1 << b;
        P & f | c[b] & f && (c[b] |= f), x &= ~P;
      }
    }
    var An = 0;
    function Ym(c) {
      return c &= -c, 1 < c ? 4 < c ? c & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var ph = r.unstable_scheduleCallback, cl = r.unstable_cancelCallback, Y0 = r.unstable_shouldYield, q0 = r.unstable_requestPaint, Vi = r.unstable_now, mh = r.unstable_ImmediatePriority, Z0 = r.unstable_UserBlockingPriority, vh = r.unstable_NormalPriority, K0 = r.unstable_IdlePriority, Qc = null, Xs = null;
    function J0(c) {
      if (Xs && typeof Xs.onCommitFiberRoot == "function") try {
        Xs.onCommitFiberRoot(Qc, c, void 0, (c.current.flags & 128) === 128);
      } catch {
      }
    }
    function Q0(c, f) {
      return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f;
    }
    var js = typeof Object.is == "function" ? Object.is : Q0, Ys = null, $c = !1, gh = !1;
    function qm(c) {
      Ys === null ? Ys = [c] : Ys.push(c);
    }
    function $0(c) {
      $c = !0, qm(c);
    }
    function qs() {
      if (!gh && Ys !== null) {
        gh = !0;
        var c = 0, f = An;
        try {
          var x = Ys;
          for (An = 1; c < x.length; c++) {
            var b = x[c];
            do
              b = b(!0);
            while (b !== null);
          }
          Ys = null, $c = !1;
        } catch (P) {
          throw Ys !== null && (Ys = Ys.slice(c + 1)), ph(mh, qs), P;
        } finally {
          An = f, gh = !1;
        }
      }
      return null;
    }
    var ex = u.ReactCurrentBatchConfig;
    function Au(c, f) {
      if (js(c, f)) return !0;
      if (typeof c != "object" || c === null || typeof f != "object" || f === null) return !1;
      var x = Object.keys(c), b = Object.keys(f);
      if (x.length !== b.length) return !1;
      for (b = 0; b < x.length; b++) {
        var P = x[b];
        if (!kn.call(f, P) || !js(c[P], f[P])) return !1;
      }
      return !0;
    }
    function Zm(c) {
      switch (c.tag) {
        case 5:
          return Wt(c.type);
        case 16:
          return Wt("Lazy");
        case 13:
          return Wt("Suspense");
        case 19:
          return Wt("SuspenseList");
        case 0:
        case 2:
        case 15:
          return c = Zt(c.type, !1), c;
        case 11:
          return c = Zt(c.type.render, !1), c;
        case 1:
          return c = Zt(c.type, !0), c;
        default:
          return "";
      }
    }
    function Rs(c, f) {
      if (c && c.defaultProps) {
        f = o({}, f), c = c.defaultProps;
        for (var x in c) f[x] === void 0 && (f[x] = c[x]);
        return f;
      }
      return f;
    }
    var Ru = bi(null), Cu = null, To = null, yh = null;
    function xh() {
      yh = To = Cu = null;
    }
    function Km(c, f, x) {
      ot ? (ht(Ru, f._currentValue), f._currentValue = x) : (ht(Ru, f._currentValue2), f._currentValue2 = x);
    }
    function ef(c) {
      var f = Ru.current;
      jt(Ru), ot ? c._currentValue = f : c._currentValue2 = f;
    }
    function Pu(c, f, x) {
      for (; c !== null; ) {
        var b = c.alternate;
        if ((c.childLanes & f) !== f ? (c.childLanes |= f, b !== null && (b.childLanes |= f)) : b !== null && (b.childLanes & f) !== f && (b.childLanes |= f), c === x) break;
        c = c.return;
      }
    }
    function fl(c, f) {
      Cu = c, yh = To = null, c = c.dependencies, c !== null && c.firstContext !== null && (c.lanes & f && (Zr = !0), c.firstContext = null);
    }
    function dr(c) {
      var f = ot ? c._currentValue : c._currentValue2;
      if (yh !== c) if (c = { context: c, memoizedValue: f, next: null }, To === null) {
        if (Cu === null) throw Error(l(308));
        To = c, Cu.dependencies = { lanes: 0, firstContext: c };
      } else To = To.next = c;
      return f;
    }
    var Zs = null, Ya = !1;
    function _h(c) {
      c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Jm(c, f) {
      c = c.updateQueue, f.updateQueue === c && (f.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects });
    }
    function ga(c, f) {
      return { eventTime: c, lane: f, tag: 0, payload: null, callback: null, next: null };
    }
    function qa(c, f) {
      var x = c.updateQueue;
      x !== null && (x = x.shared, gi !== null && c.mode & 1 && !(un & 2) ? (c = x.interleaved, c === null ? (f.next = f, Zs === null ? Zs = [x] : Zs.push(x)) : (f.next = c.next, c.next = f), x.interleaved = f) : (c = x.pending, c === null ? f.next = f : (f.next = c.next, c.next = f), x.pending = f));
    }
    function tf(c, f, x) {
      if (f = f.updateQueue, f !== null && (f = f.shared, (x & 4194240) !== 0)) {
        var b = f.lanes;
        b &= c.pendingLanes, x |= b, f.lanes = x, ja(c, x);
      }
    }
    function Sh(c, f) {
      var x = c.updateQueue, b = c.alternate;
      if (b !== null && (b = b.updateQueue, x === b)) {
        var P = null, D = null;
        if (x = x.firstBaseUpdate, x !== null) {
          do {
            var X = { eventTime: x.eventTime, lane: x.lane, tag: x.tag, payload: x.payload, callback: x.callback, next: null };
            D === null ? P = D = X : D = D.next = X, x = x.next;
          } while (x !== null);
          D === null ? P = D = f : D = D.next = f;
        } else P = D = f;
        x = { baseState: b.baseState, firstBaseUpdate: P, lastBaseUpdate: D, shared: b.shared, effects: b.effects }, c.updateQueue = x;
        return;
      }
      c = x.lastBaseUpdate, c === null ? x.firstBaseUpdate = f : c.next = f, x.lastBaseUpdate = f;
    }
    function nf(c, f, x, b) {
      var P = c.updateQueue;
      Ya = !1;
      var D = P.firstBaseUpdate, X = P.lastBaseUpdate, ae = P.shared.pending;
      if (ae !== null) {
        P.shared.pending = null;
        var Ce = ae, et = Ce.next;
        Ce.next = null, X === null ? D = et : X.next = et, X = Ce;
        var bt = c.alternate;
        bt !== null && (bt = bt.updateQueue, ae = bt.lastBaseUpdate, ae !== X && (ae === null ? bt.firstBaseUpdate = et : ae.next = et, bt.lastBaseUpdate = Ce));
      }
      if (D !== null) {
        var en = P.baseState;
        X = 0, bt = et = Ce = null, ae = D;
        do {
          var Bt = ae.lane, Nn = ae.eventTime;
          if ((b & Bt) === Bt) {
            bt !== null && (bt = bt.next = {
              eventTime: Nn,
              lane: 0,
              tag: ae.tag,
              payload: ae.payload,
              callback: ae.callback,
              next: null
            });
            e: {
              var Nt = c, ki = ae;
              switch (Bt = f, Nn = x, ki.tag) {
                case 1:
                  if (Nt = ki.payload, typeof Nt == "function") {
                    en = Nt.call(Nn, en, Bt);
                    break e;
                  }
                  en = Nt;
                  break e;
                case 3:
                  Nt.flags = Nt.flags & -65537 | 128;
                case 0:
                  if (Nt = ki.payload, Bt = typeof Nt == "function" ? Nt.call(Nn, en, Bt) : Nt, Bt == null) break e;
                  en = o({}, en, Bt);
                  break e;
                case 2:
                  Ya = !0;
              }
            }
            ae.callback !== null && ae.lane !== 0 && (c.flags |= 64, Bt = P.effects, Bt === null ? P.effects = [ae] : Bt.push(ae));
          } else Nn = { eventTime: Nn, lane: Bt, tag: ae.tag, payload: ae.payload, callback: ae.callback, next: null }, bt === null ? (et = bt = Nn, Ce = en) : bt = bt.next = Nn, X |= Bt;
          if (ae = ae.next, ae === null) {
            if (ae = P.shared.pending, ae === null) break;
            Bt = ae, ae = Bt.next, Bt.next = null, P.lastBaseUpdate = Bt, P.shared.pending = null;
          }
        } while (!0);
        if (bt === null && (Ce = en), P.baseState = Ce, P.firstBaseUpdate = et, P.lastBaseUpdate = bt, f = P.shared.interleaved, f !== null) {
          P = f;
          do
            X |= P.lane, P = P.next;
          while (P !== f);
        } else D === null && (P.shared.lanes = 0);
        Pl |= X, c.lanes = X, c.memoizedState = en;
      }
    }
    function Qm(c, f, x) {
      if (c = f.effects, f.effects = null, c !== null) for (f = 0; f < c.length; f++) {
        var b = c[f], P = b.callback;
        if (P !== null) {
          if (b.callback = null, b = x, typeof P != "function") throw Error(l(191, P));
          P.call(b);
        }
      }
    }
    var $m = new n.Component().refs;
    function Mh(c, f, x, b) {
      f = c.memoizedState, x = x(b, f), x = x == null ? f : o({}, f, x), c.memoizedState = x, c.lanes === 0 && (c.updateQueue.baseState = x);
    }
    var rf = { isMounted: function(c) {
      return (c = c._reactInternals) ? U(c) === c : !1;
    }, enqueueSetState: function(c, f, x) {
      c = c._reactInternals;
      var b = gr(), P = Pi(c), D = ga(b, P);
      D.payload = f, x != null && (D.callback = x), qa(c, D), f = xi(c, P, b), f !== null && tf(f, c, P);
    }, enqueueReplaceState: function(c, f, x) {
      c = c._reactInternals;
      var b = gr(), P = Pi(c), D = ga(b, P);
      D.tag = 1, D.payload = f, x != null && (D.callback = x), qa(c, D), f = xi(c, P, b), f !== null && tf(f, c, P);
    }, enqueueForceUpdate: function(c, f) {
      c = c._reactInternals;
      var x = gr(), b = Pi(c), P = ga(
        x,
        b
      );
      P.tag = 2, f != null && (P.callback = f), qa(c, P), f = xi(c, b, x), f !== null && tf(f, c, b);
    } };
    function ev(c, f, x, b, P, D, X) {
      return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(b, D, X) : f.prototype && f.prototype.isPureReactComponent ? !Au(x, b) || !Au(P, D) : !0;
    }
    function tv(c, f, x) {
      var b = !1, P = Ar, D = f.contextType;
      return typeof D == "object" && D !== null ? D = dr(D) : (P = Bi(f) ? Ws : on.current, b = f.contextTypes, D = (b = b != null) ? ls(c, P) : Ar), f = new f(x, D), c.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null, f.updater = rf, c.stateNode = f, f._reactInternals = c, b && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = P, c.__reactInternalMemoizedMaskedChildContext = D), f;
    }
    function nv(c, f, x, b) {
      c = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(x, b), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(x, b), f.state !== c && rf.enqueueReplaceState(f, f.state, null);
    }
    function Eh(c, f, x, b) {
      var P = c.stateNode;
      P.props = x, P.state = c.memoizedState, P.refs = $m, _h(c);
      var D = f.contextType;
      typeof D == "object" && D !== null ? P.context = dr(D) : (D = Bi(f) ? Ws : on.current, P.context = ls(c, D)), P.state = c.memoizedState, D = f.getDerivedStateFromProps, typeof D == "function" && (Mh(c, f, D, x), P.state = c.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof P.getSnapshotBeforeUpdate == "function" || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (f = P.state, typeof P.componentWillMount == "function" && P.componentWillMount(), typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount(), f !== P.state && rf.enqueueReplaceState(P, P.state, null), nf(c, x, P, b), P.state = c.memoizedState), typeof P.componentDidMount == "function" && (c.flags |= 4194308);
    }
    var dl = [], hl = 0, sf = null, af = 0, us = [], cs = 0, wo = null, ya = 1, xa = "";
    function Ao(c, f) {
      dl[hl++] = af, dl[hl++] = sf, sf = c, af = f;
    }
    function pl(c, f, x) {
      us[cs++] = ya, us[cs++] = xa, us[cs++] = wo, wo = c;
      var b = ya;
      c = xa;
      var P = 32 - Rr(b) - 1;
      b &= ~(1 << P), x += 1;
      var D = 32 - Rr(f) + P;
      if (30 < D) {
        var X = P - P % 5;
        D = (b & (1 << X) - 1).toString(32), b >>= X, P -= X, ya = 1 << 32 - Rr(f) + P | x << P | b, xa = D + c;
      } else ya = 1 << D | x << P | b, xa = c;
    }
    function of(c) {
      c.return !== null && (Ao(c, 1), pl(c, 1, 0));
    }
    function lf(c) {
      for (; c === sf; ) sf = dl[--hl], dl[hl] = null, af = dl[--hl], dl[hl] = null;
      for (; c === wo; ) wo = us[--cs], us[cs] = null, xa = us[--cs], us[cs] = null, ya = us[--cs], us[cs] = null;
    }
    var Pr = null, Lr = null, Wn = !1, ml = !1, fs = null;
    function bh(c, f) {
      var x = xr(5, null, null, 0);
      x.elementType = "DELETED", x.stateNode = f, x.return = c, f = c.deletions, f === null ? (c.deletions = [x], c.flags |= 16) : f.push(x);
    }
    function iv(c, f) {
      switch (c.tag) {
        case 5:
          return f = Jt(f, c.type, c.pendingProps), f !== null ? (c.stateNode = f, Pr = c, Lr = $(f), !0) : !1;
        case 6:
          return f = di(f, c.pendingProps), f !== null ? (c.stateNode = f, Pr = c, Lr = null, !0) : !1;
        case 13:
          if (f = hi(f), f !== null) {
            var x = wo !== null ? { id: ya, overflow: xa } : null;
            return c.memoizedState = { dehydrated: f, treeContext: x, retryLane: 1073741824 }, x = xr(18, null, null, 0), x.stateNode = f, x.return = c, c.child = x, Pr = c, Lr = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function Th(c) {
      return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
    }
    function Lu(c) {
      if (Wn) {
        var f = Lr;
        if (f) {
          var x = f;
          if (!iv(c, f)) {
            if (Th(c)) throw Error(l(418));
            f = Zn(x);
            var b = Pr;
            f && iv(c, f) ? bh(b, x) : (c.flags = c.flags & -4097 | 2, Wn = !1, Pr = c);
          }
        } else {
          if (Th(c)) throw Error(l(418));
          c.flags = c.flags & -4097 | 2, Wn = !1, Pr = c;
        }
      }
    }
    function uf(c) {
      for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; ) c = c.return;
      Pr = c;
    }
    function ds(c) {
      if (!Be || c !== Pr) return !1;
      if (!Wn) return uf(c), Wn = !0, !1;
      if (c.tag !== 3 && (c.tag !== 5 || Qe(c.type) && !qe(c.type, c.memoizedProps))) {
        var f = Lr;
        if (f) {
          if (Th(c)) {
            for (c = Lr; c; ) c = Zn(c);
            throw Error(l(418));
          }
          for (; f; ) bh(c, f), f = Zn(f);
        }
      }
      if (uf(c), c.tag === 13) {
        if (!Be) throw Error(l(316));
        if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(l(317));
        Lr = k(c);
      } else Lr = Pr ? Zn(c.stateNode) : null;
      return !0;
    }
    function Za() {
      Be && (Lr = Pr = null, ml = Wn = !1);
    }
    function vl(c) {
      fs === null ? fs = [c] : fs.push(c);
    }
    function Du(c, f, x) {
      if (c = x.ref, c !== null && typeof c != "function" && typeof c != "object") {
        if (x._owner) {
          if (x = x._owner, x) {
            if (x.tag !== 1) throw Error(l(309));
            var b = x.stateNode;
          }
          if (!b) throw Error(l(147, c));
          var P = b, D = "" + c;
          return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === D ? f.ref : (f = function(X) {
            var ae = P.refs;
            ae === $m && (ae = P.refs = {}), X === null ? delete ae[D] : ae[D] = X;
          }, f._stringRef = D, f);
        }
        if (typeof c != "string") throw Error(l(284));
        if (!x._owner) throw Error(l(290, c));
      }
      return c;
    }
    function gl(c, f) {
      throw c = Object.prototype.toString.call(f), Error(l(31, c === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : c));
    }
    function rv(c) {
      var f = c._init;
      return f(c._payload);
    }
    function cf(c) {
      function f(Se, fe) {
        if (c) {
          var be = Se.deletions;
          be === null ? (Se.deletions = [fe], Se.flags |= 16) : be.push(fe);
        }
      }
      function x(Se, fe) {
        if (!c) return null;
        for (; fe !== null; ) f(Se, fe), fe = fe.sibling;
        return null;
      }
      function b(Se, fe) {
        for (Se = /* @__PURE__ */ new Map(); fe !== null; ) fe.key !== null ? Se.set(fe.key, fe) : Se.set(fe.index, fe), fe = fe.sibling;
        return Se;
      }
      function P(Se, fe) {
        return Se = Ra(Se, fe), Se.index = 0, Se.sibling = null, Se;
      }
      function D(Se, fe, be) {
        return Se.index = be, c ? (be = Se.alternate, be !== null ? (be = be.index, be < fe ? (Se.flags |= 2, fe) : be) : (Se.flags |= 2, fe)) : (Se.flags |= 1048576, fe);
      }
      function X(Se) {
        return c && Se.alternate === null && (Se.flags |= 2), Se;
      }
      function ae(Se, fe, be, ut) {
        return fe === null || fe.tag !== 6 ? (fe = Jr(be, Se.mode, ut), fe.return = Se, fe) : (fe = P(fe, be), fe.return = Se, fe);
      }
      function Ce(Se, fe, be, ut) {
        var Pt = be.type;
        return Pt === m ? bt(Se, fe, be.props.children, ut, be.key) : fe !== null && (fe.elementType === Pt || typeof Pt == "object" && Pt !== null && Pt.$$typeof === A && rv(Pt) === fe.type) ? (ut = P(fe, be.props), ut.ref = Du(Se, fe, be), ut.return = Se, ut) : (ut = zl(be.type, be.key, be.props, null, Se.mode, ut), ut.ref = Du(Se, fe, be), ut.return = Se, ut);
      }
      function et(Se, fe, be, ut) {
        return fe === null || fe.tag !== 4 || fe.stateNode.containerInfo !== be.containerInfo || fe.stateNode.implementation !== be.implementation ? (fe = Bl(be, Se.mode, ut), fe.return = Se, fe) : (fe = P(fe, be.children || []), fe.return = Se, fe);
      }
      function bt(Se, fe, be, ut, Pt) {
        return fe === null || fe.tag !== 7 ? (fe = Io(be, Se.mode, ut, Pt), fe.return = Se, fe) : (fe = P(fe, be), fe.return = Se, fe);
      }
      function en(Se, fe, be) {
        if (typeof fe == "string" && fe !== "" || typeof fe == "number") return fe = Jr("" + fe, Se.mode, be), fe.return = Se, fe;
        if (typeof fe == "object" && fe !== null) {
          switch (fe.$$typeof) {
            case d:
              return be = zl(fe.type, fe.key, fe.props, null, Se.mode, be), be.ref = Du(Se, null, fe), be.return = Se, be;
            case h:
              return fe = Bl(fe, Se.mode, be), fe.return = Se, fe;
            case A:
              var ut = fe._init;
              return en(Se, ut(fe._payload), be);
          }
          if (oe(fe) || I(fe)) return fe = Io(fe, Se.mode, be, null), fe.return = Se, fe;
          gl(Se, fe);
        }
        return null;
      }
      function Bt(Se, fe, be, ut) {
        var Pt = fe !== null ? fe.key : null;
        if (typeof be == "string" && be !== "" || typeof be == "number") return Pt !== null ? null : ae(Se, fe, "" + be, ut);
        if (typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case d:
              return be.key === Pt ? Ce(Se, fe, be, ut) : null;
            case h:
              return be.key === Pt ? et(Se, fe, be, ut) : null;
            case A:
              return Pt = be._init, Bt(
                Se,
                fe,
                Pt(be._payload),
                ut
              );
          }
          if (oe(be) || I(be)) return Pt !== null ? null : bt(Se, fe, be, ut, null);
          gl(Se, be);
        }
        return null;
      }
      function Nn(Se, fe, be, ut, Pt) {
        if (typeof ut == "string" && ut !== "" || typeof ut == "number") return Se = Se.get(be) || null, ae(fe, Se, "" + ut, Pt);
        if (typeof ut == "object" && ut !== null) {
          switch (ut.$$typeof) {
            case d:
              return Se = Se.get(ut.key === null ? be : ut.key) || null, Ce(fe, Se, ut, Pt);
            case h:
              return Se = Se.get(ut.key === null ? be : ut.key) || null, et(fe, Se, ut, Pt);
            case A:
              var sn = ut._init;
              return Nn(Se, fe, be, sn(ut._payload), Pt);
          }
          if (oe(ut) || I(ut)) return Se = Se.get(be) || null, bt(fe, Se, ut, Pt, null);
          gl(fe, ut);
        }
        return null;
      }
      function Nt(Se, fe, be, ut) {
        for (var Pt = null, sn = null, rn = fe, Mn = fe = 0, Gi = null; rn !== null && Mn < be.length; Mn++) {
          rn.index > Mn ? (Gi = rn, rn = null) : Gi = rn.sibling;
          var wn = Bt(Se, rn, be[Mn], ut);
          if (wn === null) {
            rn === null && (rn = Gi);
            break;
          }
          c && rn && wn.alternate === null && f(Se, rn), fe = D(wn, fe, Mn), sn === null ? Pt = wn : sn.sibling = wn, sn = wn, rn = Gi;
        }
        if (Mn === be.length) return x(Se, rn), Wn && Ao(Se, Mn), Pt;
        if (rn === null) {
          for (; Mn < be.length; Mn++) rn = en(Se, be[Mn], ut), rn !== null && (fe = D(rn, fe, Mn), sn === null ? Pt = rn : sn.sibling = rn, sn = rn);
          return Wn && Ao(Se, Mn), Pt;
        }
        for (rn = b(Se, rn); Mn < be.length; Mn++) Gi = Nn(rn, Se, Mn, be[Mn], ut), Gi !== null && (c && Gi.alternate !== null && rn.delete(Gi.key === null ? Mn : Gi.key), fe = D(Gi, fe, Mn), sn === null ? Pt = Gi : sn.sibling = Gi, sn = Gi);
        return c && rn.forEach(function(Ns) {
          return f(Se, Ns);
        }), Wn && Ao(Se, Mn), Pt;
      }
      function ki(Se, fe, be, ut) {
        var Pt = I(be);
        if (typeof Pt != "function") throw Error(l(150));
        if (be = Pt.call(be), be == null) throw Error(l(151));
        for (var sn = Pt = null, rn = fe, Mn = fe = 0, Gi = null, wn = be.next(); rn !== null && !wn.done; Mn++, wn = be.next()) {
          rn.index > Mn ? (Gi = rn, rn = null) : Gi = rn.sibling;
          var Ns = Bt(Se, rn, wn.value, ut);
          if (Ns === null) {
            rn === null && (rn = Gi);
            break;
          }
          c && rn && Ns.alternate === null && f(Se, rn), fe = D(Ns, fe, Mn), sn === null ? Pt = Ns : sn.sibling = Ns, sn = Ns, rn = Gi;
        }
        if (wn.done) return x(
          Se,
          rn
        ), Wn && Ao(Se, Mn), Pt;
        if (rn === null) {
          for (; !wn.done; Mn++, wn = be.next()) wn = en(Se, wn.value, ut), wn !== null && (fe = D(wn, fe, Mn), sn === null ? Pt = wn : sn.sibling = wn, sn = wn);
          return Wn && Ao(Se, Mn), Pt;
        }
        for (rn = b(Se, rn); !wn.done; Mn++, wn = be.next()) wn = Nn(rn, Se, Mn, wn.value, ut), wn !== null && (c && wn.alternate !== null && rn.delete(wn.key === null ? Mn : wn.key), fe = D(wn, fe, Mn), sn === null ? Pt = wn : sn.sibling = wn, sn = wn);
        return c && rn.forEach(function(Tv) {
          return f(Se, Tv);
        }), Wn && Ao(Se, Mn), Pt;
      }
      function _r(Se, fe, be, ut) {
        if (typeof be == "object" && be !== null && be.type === m && be.key === null && (be = be.props.children), typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case d:
              e: {
                for (var Pt = be.key, sn = fe; sn !== null; ) {
                  if (sn.key === Pt) {
                    if (Pt = be.type, Pt === m) {
                      if (sn.tag === 7) {
                        x(Se, sn.sibling), fe = P(sn, be.props.children), fe.return = Se, Se = fe;
                        break e;
                      }
                    } else if (sn.elementType === Pt || typeof Pt == "object" && Pt !== null && Pt.$$typeof === A && rv(Pt) === sn.type) {
                      x(Se, sn.sibling), fe = P(sn, be.props), fe.ref = Du(Se, sn, be), fe.return = Se, Se = fe;
                      break e;
                    }
                    x(Se, sn);
                    break;
                  } else f(Se, sn);
                  sn = sn.sibling;
                }
                be.type === m ? (fe = Io(be.props.children, Se.mode, ut, be.key), fe.return = Se, Se = fe) : (ut = zl(be.type, be.key, be.props, null, Se.mode, ut), ut.ref = Du(Se, fe, be), ut.return = Se, Se = ut);
              }
              return X(Se);
            case h:
              e: {
                for (sn = be.key; fe !== null; ) {
                  if (fe.key === sn) if (fe.tag === 4 && fe.stateNode.containerInfo === be.containerInfo && fe.stateNode.implementation === be.implementation) {
                    x(Se, fe.sibling), fe = P(fe, be.children || []), fe.return = Se, Se = fe;
                    break e;
                  } else {
                    x(Se, fe);
                    break;
                  }
                  else f(Se, fe);
                  fe = fe.sibling;
                }
                fe = Bl(be, Se.mode, ut), fe.return = Se, Se = fe;
              }
              return X(Se);
            case A:
              return sn = be._init, _r(Se, fe, sn(be._payload), ut);
          }
          if (oe(be)) return Nt(Se, fe, be, ut);
          if (I(be)) return ki(Se, fe, be, ut);
          gl(Se, be);
        }
        return typeof be == "string" && be !== "" || typeof be == "number" ? (be = "" + be, fe !== null && fe.tag === 6 ? (x(Se, fe.sibling), fe = P(fe, be), fe.return = Se, Se = fe) : (x(Se, fe), fe = Jr(be, Se.mode, ut), fe.return = Se, Se = fe), X(Se)) : x(Se, fe);
      }
      return _r;
    }
    var yl = cf(!0), ff = cf(!1), xl = {}, qr = bi(xl), _l = bi(xl), _a = bi(xl);
    function pi(c) {
      if (c === xl) throw Error(l(174));
      return c;
    }
    function Nu(c, f) {
      ht(_a, f), ht(_l, c), ht(qr, xl), c = Ee(f), jt(qr), ht(qr, c);
    }
    function Sa() {
      jt(qr), jt(_l), jt(_a);
    }
    function Ks(c) {
      var f = pi(_a.current), x = pi(qr.current);
      f = Q(x, c.type, f), x !== f && (ht(_l, c), ht(qr, f));
    }
    function Js(c) {
      _l.current === c && (jt(qr), jt(_l));
    }
    var pn = bi(0);
    function mi(c) {
      for (var f = c; f !== null; ) {
        if (f.tag === 13) {
          var x = f.memoizedState;
          if (x !== null && (x = x.dehydrated, x === null || va(x) || Mo(x))) return f;
        } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
          if (f.flags & 128) return f;
        } else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === c) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === c) return null;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return null;
    }
    var Uu = [];
    function hr() {
      for (var c = 0; c < Uu.length; c++) {
        var f = Uu[c];
        ot ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null;
      }
      Uu.length = 0;
    }
    var hs = u.ReactCurrentDispatcher, ni = u.ReactCurrentBatchConfig, Ka = 0, In = null, Yi = null, Jn = null, Ro = !1, Dr = !1, Ja = 0, wh = 0;
    function qi() {
      throw Error(l(321));
    }
    function df(c, f) {
      if (f === null) return !1;
      for (var x = 0; x < f.length && x < c.length; x++) if (!js(c[x], f[x])) return !1;
      return !0;
    }
    function Sl(c, f, x, b, P, D) {
      if (Ka = D, In = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, hs.current = c === null || c.memoizedState === null ? Dh : Nh, c = x(b, P), Dr) {
        D = 0;
        do {
          if (Dr = !1, Ja = 0, 25 <= D) throw Error(l(301));
          D += 1, Jn = Yi = null, f.updateQueue = null, hs.current = Uh, c = x(b, P);
        } while (Dr);
      }
      if (hs.current = El, f = Yi !== null && Yi.next !== null, Ka = 0, Jn = Yi = In = null, Ro = !1, f) throw Error(l(300));
      return c;
    }
    function hf() {
      var c = Ja !== 0;
      return Ja = 0, c;
    }
    function Ma() {
      var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Jn === null ? In.memoizedState = Jn = c : Jn = Jn.next = c, Jn;
    }
    function pr() {
      if (Yi === null) {
        var c = In.alternate;
        c = c !== null ? c.memoizedState : null;
      } else c = Yi.next;
      var f = Jn === null ? In.memoizedState : Jn.next;
      if (f !== null) Jn = f, Yi = c;
      else {
        if (c === null) throw Error(l(310));
        Yi = c, c = { memoizedState: Yi.memoizedState, baseState: Yi.baseState, baseQueue: Yi.baseQueue, queue: Yi.queue, next: null }, Jn === null ? In.memoizedState = Jn = c : Jn = Jn.next = c;
      }
      return Jn;
    }
    function Qa(c, f) {
      return typeof f == "function" ? f(c) : f;
    }
    function Yt(c) {
      var f = pr(), x = f.queue;
      if (x === null) throw Error(l(311));
      x.lastRenderedReducer = c;
      var b = Yi, P = b.baseQueue, D = x.pending;
      if (D !== null) {
        if (P !== null) {
          var X = P.next;
          P.next = D.next, D.next = X;
        }
        b.baseQueue = P = D, x.pending = null;
      }
      if (P !== null) {
        D = P.next, b = b.baseState;
        var ae = X = null, Ce = null, et = D;
        do {
          var bt = et.lane;
          if ((Ka & bt) === bt) Ce !== null && (Ce = Ce.next = { lane: 0, action: et.action, hasEagerState: et.hasEagerState, eagerState: et.eagerState, next: null }), b = et.hasEagerState ? et.eagerState : c(b, et.action);
          else {
            var en = {
              lane: bt,
              action: et.action,
              hasEagerState: et.hasEagerState,
              eagerState: et.eagerState,
              next: null
            };
            Ce === null ? (ae = Ce = en, X = b) : Ce = Ce.next = en, In.lanes |= bt, Pl |= bt;
          }
          et = et.next;
        } while (et !== null && et !== D);
        Ce === null ? X = b : Ce.next = ae, js(b, f.memoizedState) || (Zr = !0), f.memoizedState = b, f.baseState = X, f.baseQueue = Ce, x.lastRenderedState = b;
      }
      if (c = x.interleaved, c !== null) {
        P = c;
        do
          D = P.lane, In.lanes |= D, Pl |= D, P = P.next;
        while (P !== c);
      } else P === null && (x.lanes = 0);
      return [f.memoizedState, x.dispatch];
    }
    function Rn(c) {
      var f = pr(), x = f.queue;
      if (x === null) throw Error(l(311));
      x.lastRenderedReducer = c;
      var b = x.dispatch, P = x.pending, D = f.memoizedState;
      if (P !== null) {
        x.pending = null;
        var X = P = P.next;
        do
          D = c(D, X.action), X = X.next;
        while (X !== P);
        js(D, f.memoizedState) || (Zr = !0), f.memoizedState = D, f.baseQueue === null && (f.baseState = D), x.lastRenderedState = D;
      }
      return [D, b];
    }
    function Tn() {
    }
    function ii(c, f) {
      var x = In, b = pr(), P = f(), D = !js(b.memoizedState, P);
      if (D && (b.memoizedState = P, Zr = !0), b = b.queue, ps(sv.bind(null, x, b, c), [c]), b.getSnapshot !== f || D || Jn !== null && Jn.memoizedState.tag & 1) {
        if (x.flags |= 2048, Co(9, Ah.bind(null, x, b, P, f), void 0, null), gi === null) throw Error(l(349));
        Ka & 30 || Cs(x, f, P);
      }
      return P;
    }
    function Cs(c, f, x) {
      c.flags |= 16384, c = { getSnapshot: f, value: x }, f = In.updateQueue, f === null ? (f = { lastEffect: null, stores: null }, In.updateQueue = f, f.stores = [c]) : (x = f.stores, x === null ? f.stores = [c] : x.push(c));
    }
    function Ah(c, f, x, b) {
      f.value = x, f.getSnapshot = b, av(f) && xi(c, 1, -1);
    }
    function sv(c, f, x) {
      return x(function() {
        av(f) && xi(c, 1, -1);
      });
    }
    function av(c) {
      var f = c.getSnapshot;
      c = c.value;
      try {
        var x = f();
        return !js(c, x);
      } catch {
        return !0;
      }
    }
    function Rh(c) {
      var f = Ma();
      return typeof c == "function" && (c = c()), f.memoizedState = f.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Qa, lastRenderedState: c }, f.queue = c, c = c.dispatch = Lh.bind(null, In, c), [f.memoizedState, c];
    }
    function Co(c, f, x, b) {
      return c = { tag: c, create: f, destroy: x, deps: b, next: null }, f = In.updateQueue, f === null ? (f = { lastEffect: null, stores: null }, In.updateQueue = f, f.lastEffect = c.next = c) : (x = f.lastEffect, x === null ? f.lastEffect = c.next = c : (b = x.next, x.next = c, c.next = b, f.lastEffect = c)), c;
    }
    function Ge() {
      return pr().memoizedState;
    }
    function ri(c, f, x, b) {
      var P = Ma();
      In.flags |= c, P.memoizedState = Co(1 | f, x, void 0, b === void 0 ? null : b);
    }
    function ln(c, f, x, b) {
      var P = pr();
      b = b === void 0 ? null : b;
      var D = void 0;
      if (Yi !== null) {
        var X = Yi.memoizedState;
        if (D = X.destroy, b !== null && df(b, X.deps)) {
          P.memoizedState = Co(f, x, D, b);
          return;
        }
      }
      In.flags |= c, P.memoizedState = Co(1 | f, x, D, b);
    }
    function $a(c, f) {
      return ri(8390656, 8, c, f);
    }
    function ps(c, f) {
      return ln(2048, 8, c, f);
    }
    function eo(c, f) {
      return ln(4, 2, c, f);
    }
    function Qs(c, f) {
      return ln(4, 4, c, f);
    }
    function Ml(c, f) {
      if (typeof f == "function") return c = c(), f(c), function() {
        f(null);
      };
      if (f != null) return c = c(), f.current = c, function() {
        f.current = null;
      };
    }
    function Po(c, f, x) {
      return x = x != null ? x.concat([c]) : null, ln(4, 4, Ml.bind(null, f, c), x);
    }
    function Lo() {
    }
    function pf(c, f) {
      var x = pr();
      f = f === void 0 ? null : f;
      var b = x.memoizedState;
      return b !== null && f !== null && df(f, b[1]) ? b[0] : (x.memoizedState = [c, f], c);
    }
    function mf(c, f) {
      var x = pr();
      f = f === void 0 ? null : f;
      var b = x.memoizedState;
      return b !== null && f !== null && df(f, b[1]) ? b[0] : (c = c(), x.memoizedState = [c, f], c);
    }
    function Ch(c, f) {
      var x = An;
      An = x !== 0 && 4 > x ? x : 4, c(!0);
      var b = ni.transition;
      ni.transition = {};
      try {
        c(!1), f();
      } finally {
        An = x, ni.transition = b;
      }
    }
    function vf() {
      return pr().memoizedState;
    }
    function Ph(c, f, x) {
      var b = Pi(c);
      x = { lane: b, action: x, hasEagerState: !1, eagerState: null, next: null }, gf(c) ? yf(f, x) : (xf(c, f, x), x = gr(), c = xi(c, b, x), c !== null && _f(c, f, b));
    }
    function Lh(c, f, x) {
      var b = Pi(c), P = { lane: b, action: x, hasEagerState: !1, eagerState: null, next: null };
      if (gf(c)) yf(f, P);
      else {
        xf(c, f, P);
        var D = c.alternate;
        if (c.lanes === 0 && (D === null || D.lanes === 0) && (D = f.lastRenderedReducer, D !== null)) try {
          var X = f.lastRenderedState, ae = D(X, x);
          if (P.hasEagerState = !0, P.eagerState = ae, js(ae, X)) return;
        } catch {
        } finally {
        }
        x = gr(), c = xi(c, b, x), c !== null && _f(c, f, b);
      }
    }
    function gf(c) {
      var f = c.alternate;
      return c === In || f !== null && f === In;
    }
    function yf(c, f) {
      Dr = Ro = !0;
      var x = c.pending;
      x === null ? f.next = f : (f.next = x.next, x.next = f), c.pending = f;
    }
    function xf(c, f, x) {
      gi !== null && c.mode & 1 && !(un & 2) ? (c = f.interleaved, c === null ? (x.next = x, Zs === null ? Zs = [f] : Zs.push(f)) : (x.next = c.next, c.next = x), f.interleaved = x) : (c = f.pending, c === null ? x.next = x : (x.next = c.next, c.next = x), f.pending = x);
    }
    function _f(c, f, x) {
      if (x & 4194240) {
        var b = f.lanes;
        b &= c.pendingLanes, x |= b, f.lanes = x, ja(c, x);
      }
    }
    var El = { readContext: dr, useCallback: qi, useContext: qi, useEffect: qi, useImperativeHandle: qi, useInsertionEffect: qi, useLayoutEffect: qi, useMemo: qi, useReducer: qi, useRef: qi, useState: qi, useDebugValue: qi, useDeferredValue: qi, useTransition: qi, useMutableSource: qi, useSyncExternalStore: qi, useId: qi, unstable_isNewReconciler: !1 }, Dh = { readContext: dr, useCallback: function(c, f) {
      return Ma().memoizedState = [c, f === void 0 ? null : f], c;
    }, useContext: dr, useEffect: $a, useImperativeHandle: function(c, f, x) {
      return x = x != null ? x.concat([c]) : null, ri(
        4194308,
        4,
        Ml.bind(null, f, c),
        x
      );
    }, useLayoutEffect: function(c, f) {
      return ri(4194308, 4, c, f);
    }, useInsertionEffect: function(c, f) {
      return ri(4, 2, c, f);
    }, useMemo: function(c, f) {
      var x = Ma();
      return f = f === void 0 ? null : f, c = c(), x.memoizedState = [c, f], c;
    }, useReducer: function(c, f, x) {
      var b = Ma();
      return f = x !== void 0 ? x(f) : f, b.memoizedState = b.baseState = f, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: f }, b.queue = c, c = c.dispatch = Ph.bind(null, In, c), [b.memoizedState, c];
    }, useRef: function(c) {
      var f = Ma();
      return c = { current: c }, f.memoizedState = c;
    }, useState: Rh, useDebugValue: Lo, useDeferredValue: function(c) {
      var f = Rh(c), x = f[0], b = f[1];
      return $a(function() {
        var P = ni.transition;
        ni.transition = {};
        try {
          b(c);
        } finally {
          ni.transition = P;
        }
      }, [c]), x;
    }, useTransition: function() {
      var c = Rh(!1), f = c[0];
      return c = Ch.bind(null, c[1]), Ma().memoizedState = c, [f, c];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(c, f, x) {
      var b = In, P = Ma();
      if (Wn) {
        if (x === void 0) throw Error(l(407));
        x = x();
      } else {
        if (x = f(), gi === null) throw Error(l(349));
        Ka & 30 || Cs(b, f, x);
      }
      P.memoizedState = x;
      var D = { value: x, getSnapshot: f };
      return P.queue = D, $a(sv.bind(null, b, D, c), [c]), b.flags |= 2048, Co(9, Ah.bind(null, b, D, x, f), void 0, null), x;
    }, useId: function() {
      var c = Ma(), f = gi.identifierPrefix;
      if (Wn) {
        var x = xa, b = ya;
        x = (b & ~(1 << 32 - Rr(b) - 1)).toString(32) + x, f = ":" + f + "R" + x, x = Ja++, 0 < x && (f += "H" + x.toString(32)), f += ":";
      } else x = wh++, f = ":" + f + "r" + x.toString(32) + ":";
      return c.memoizedState = f;
    }, unstable_isNewReconciler: !1 }, Nh = {
      readContext: dr,
      useCallback: pf,
      useContext: dr,
      useEffect: ps,
      useImperativeHandle: Po,
      useInsertionEffect: eo,
      useLayoutEffect: Qs,
      useMemo: mf,
      useReducer: Yt,
      useRef: Ge,
      useState: function() {
        return Yt(Qa);
      },
      useDebugValue: Lo,
      useDeferredValue: function(c) {
        var f = Yt(Qa), x = f[0], b = f[1];
        return ps(function() {
          var P = ni.transition;
          ni.transition = {};
          try {
            b(c);
          } finally {
            ni.transition = P;
          }
        }, [c]), x;
      },
      useTransition: function() {
        var c = Yt(Qa)[0], f = pr().memoizedState;
        return [c, f];
      },
      useMutableSource: Tn,
      useSyncExternalStore: ii,
      useId: vf,
      unstable_isNewReconciler: !1
    }, Uh = {
      readContext: dr,
      useCallback: pf,
      useContext: dr,
      useEffect: ps,
      useImperativeHandle: Po,
      useInsertionEffect: eo,
      useLayoutEffect: Qs,
      useMemo: mf,
      useReducer: Rn,
      useRef: Ge,
      useState: function() {
        return Rn(Qa);
      },
      useDebugValue: Lo,
      useDeferredValue: function(c) {
        var f = Rn(Qa), x = f[0], b = f[1];
        return ps(function() {
          var P = ni.transition;
          ni.transition = {};
          try {
            b(c);
          } finally {
            ni.transition = P;
          }
        }, [c]), x;
      },
      useTransition: function() {
        var c = Rn(Qa)[0], f = pr().memoizedState;
        return [c, f];
      },
      useMutableSource: Tn,
      useSyncExternalStore: ii,
      useId: vf,
      unstable_isNewReconciler: !1
    };
    function Ou(c, f) {
      try {
        var x = "", b = f;
        do
          x += Zm(b), b = b.return;
        while (b);
        var P = x;
      } catch (D) {
        P = `
Error generating stack: ` + D.message + `
` + D.stack;
      }
      return { value: c, source: f, stack: P };
    }
    function bl(c, f) {
      try {
        console.error(f.value);
      } catch (x) {
        setTimeout(function() {
          throw x;
        });
      }
    }
    var Tl = typeof WeakMap == "function" ? WeakMap : Map;
    function Sf(c, f, x) {
      x = ga(-1, x), x.tag = 3, x.payload = { element: null };
      var b = f.value;
      return x.callback = function() {
        Hf || (Hf = !0, jh = b), bl(c, f);
      }, x;
    }
    function Mf(c, f, x) {
      x = ga(-1, x), x.tag = 3;
      var b = c.type.getDerivedStateFromError;
      if (typeof b == "function") {
        var P = f.value;
        x.payload = function() {
          return b(P);
        }, x.callback = function() {
          bl(c, f);
        };
      }
      var D = c.stateNode;
      return D !== null && typeof D.componentDidCatch == "function" && (x.callback = function() {
        bl(c, f), typeof b != "function" && (so === null ? so = /* @__PURE__ */ new Set([this]) : so.add(this));
        var X = f.stack;
        this.componentDidCatch(f.value, { componentStack: X !== null ? X : "" });
      }), x;
    }
    function Ef(c, f, x) {
      var b = c.pingCache;
      if (b === null) {
        b = c.pingCache = new Tl();
        var P = /* @__PURE__ */ new Set();
        b.set(f, P);
      } else P = b.get(f), P === void 0 && (P = /* @__PURE__ */ new Set(), b.set(f, P));
      P.has(x) || (P.add(x), c = Xu.bind(null, c, f, x), f.then(c, c));
    }
    function bf(c) {
      do {
        var f;
        if ((f = c.tag === 13) && (f = c.memoizedState, f = f !== null ? f.dehydrated !== null : !0), f) return c;
        c = c.return;
      } while (c !== null);
      return null;
    }
    function Oh(c, f, x, b, P) {
      return c.mode & 1 ? (c.flags |= 65536, c.lanes = P, c) : (c === f ? c.flags |= 65536 : (c.flags |= 128, x.flags |= 131072, x.flags &= -52805, x.tag === 1 && (x.alternate === null ? x.tag = 17 : (f = ga(-1, 1), f.tag = 2, qa(x, f))), x.lanes |= 1), c);
    }
    function Nr(c) {
      c.flags |= 4;
    }
    function Ih(c, f) {
      if (c !== null && c.child === f.child) return !0;
      if (f.flags & 16) return !1;
      for (c = f.child; c !== null; ) {
        if (c.flags & 12854 || c.subtreeFlags & 12854) return !1;
        c = c.sibling;
      }
      return !0;
    }
    var Ea, Ps, or, Tf;
    if (pt) Ea = function(c, f) {
      for (var x = f.child; x !== null; ) {
        if (x.tag === 5 || x.tag === 6) Le(c, x.stateNode);
        else if (x.tag !== 4 && x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === f) break;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === f) return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }, Ps = function() {
    }, or = function(c, f, x, b, P) {
      if (c = c.memoizedProps, c !== b) {
        var D = f.stateNode, X = pi(qr.current);
        x = Ae(D, x, c, b, P, X), (f.updateQueue = x) && Nr(f);
      }
    }, Tf = function(c, f, x, b) {
      x !== b && Nr(f);
    };
    else if (J) {
      Ea = function(c, f, x, b) {
        for (var P = f.child; P !== null; ) {
          if (P.tag === 5) {
            var D = P.stateNode;
            x && b && (D = Sn(D, P.type, P.memoizedProps, P)), Le(c, D);
          } else if (P.tag === 6) D = P.stateNode, x && b && (D = bn(D, P.memoizedProps, P)), Le(c, D);
          else if (P.tag !== 4) {
            if (P.tag === 22 && P.memoizedState !== null) D = P.child, D !== null && (D.return = P), Ea(c, P, !0, !0);
            else if (P.child !== null) {
              P.child.return = P, P = P.child;
              continue;
            }
          }
          if (P === f) break;
          for (; P.sibling === null; ) {
            if (P.return === null || P.return === f) return;
            P = P.return;
          }
          P.sibling.return = P.return, P = P.sibling;
        }
      };
      var Fn = function(c, f, x, b) {
        for (var P = f.child; P !== null; ) {
          if (P.tag === 5) {
            var D = P.stateNode;
            x && b && (D = Sn(D, P.type, P.memoizedProps, P)), Ye(c, D);
          } else if (P.tag === 6) D = P.stateNode, x && b && (D = bn(D, P.memoizedProps, P)), Ye(c, D);
          else if (P.tag !== 4) {
            if (P.tag === 22 && P.memoizedState !== null) D = P.child, D !== null && (D.return = P), Fn(c, P, !0, !0);
            else if (P.child !== null) {
              P.child.return = P, P = P.child;
              continue;
            }
          }
          if (P === f) break;
          for (; P.sibling === null; ) {
            if (P.return === null || P.return === f) return;
            P = P.return;
          }
          P.sibling.return = P.return, P = P.sibling;
        }
      };
      Ps = function(c, f) {
        var x = f.stateNode;
        if (!Ih(c, f)) {
          c = x.containerInfo;
          var b = zt(c);
          Fn(b, f, !1, !1), x.pendingChildren = b, Nr(f), qt(c, b);
        }
      }, or = function(c, f, x, b, P) {
        var D = c.stateNode, X = c.memoizedProps;
        if ((c = Ih(c, f)) && X === b) f.stateNode = D;
        else {
          var ae = f.stateNode, Ce = pi(qr.current), et = null;
          X !== b && (et = Ae(ae, x, X, b, P, Ce)), c && et === null ? f.stateNode = D : (D = st(D, et, x, X, b, f, c, ae), pe(D, x, b, P, Ce) && Nr(f), f.stateNode = D, c ? Nr(f) : Ea(D, f, !1, !1));
        }
      }, Tf = function(c, f, x, b) {
        x !== b ? (c = pi(_a.current), x = pi(qr.current), f.stateNode = je(b, c, x, f), Nr(f)) : f.stateNode = c.stateNode;
      };
    } else Ps = function() {
    }, or = function() {
    }, Tf = function() {
    };
    function to(c, f) {
      if (!Wn) switch (c.tailMode) {
        case "hidden":
          f = c.tail;
          for (var x = null; f !== null; ) f.alternate !== null && (x = f), f = f.sibling;
          x === null ? c.tail = null : x.sibling = null;
          break;
        case "collapsed":
          x = c.tail;
          for (var b = null; x !== null; ) x.alternate !== null && (b = x), x = x.sibling;
          b === null ? f || c.tail === null ? c.tail = null : c.tail.sibling = null : b.sibling = null;
      }
    }
    function wi(c) {
      var f = c.alternate !== null && c.alternate.child === c.child, x = 0, b = 0;
      if (f) for (var P = c.child; P !== null; ) x |= P.lanes | P.childLanes, b |= P.subtreeFlags & 14680064, b |= P.flags & 14680064, P.return = c, P = P.sibling;
      else for (P = c.child; P !== null; ) x |= P.lanes | P.childLanes, b |= P.subtreeFlags, b |= P.flags, P.return = c, P = P.sibling;
      return c.subtreeFlags |= b, c.childLanes = x, f;
    }
    function Iu(c, f, x) {
      var b = f.pendingProps;
      switch (lf(f), f.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return wi(f), null;
        case 1:
          return Bi(f.type) && Kn(), wi(f), null;
        case 3:
          return b = f.stateNode, Sa(), jt(ti), jt(on), hr(), b.pendingContext && (b.context = b.pendingContext, b.pendingContext = null), (c === null || c.child === null) && (ds(f) ? Nr(f) : c === null || c.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024, fs !== null && (Xf(fs), fs = null))), Ps(c, f), wi(f), null;
        case 5:
          Js(f), x = pi(_a.current);
          var P = f.type;
          if (c !== null && f.stateNode != null) or(c, f, P, b, x), c.ref !== f.ref && (f.flags |= 512, f.flags |= 2097152);
          else {
            if (!b) {
              if (f.stateNode === null) throw Error(l(166));
              return wi(f), null;
            }
            if (c = pi(qr.current), ds(f)) {
              if (!Be) throw Error(l(175));
              c = Ft(f.stateNode, f.type, f.memoizedProps, x, c, f, !ml), f.updateQueue = c, c !== null && Nr(f);
            } else {
              var D = ue(P, b, x, c, f);
              Ea(D, f, !1, !1), f.stateNode = D, pe(D, P, b, x, c) && Nr(f);
            }
            f.ref !== null && (f.flags |= 512, f.flags |= 2097152);
          }
          return wi(f), null;
        case 6:
          if (c && f.stateNode != null) Tf(c, f, c.memoizedProps, b);
          else {
            if (typeof b != "string" && f.stateNode === null) throw Error(l(166));
            if (c = pi(_a.current), x = pi(qr.current), ds(f)) {
              if (!Be) throw Error(l(176));
              if (c = f.stateNode, b = f.memoizedProps, (x = xn(c, b, f, !ml)) && (P = Pr, P !== null)) switch (D = (P.mode & 1) !== 0, P.tag) {
                case 3:
                  wt(P.stateNode.containerInfo, c, b, D);
                  break;
                case 5:
                  Ct(P.type, P.memoizedProps, P.stateNode, c, b, D);
              }
              x && Nr(f);
            } else f.stateNode = je(b, c, x, f);
          }
          return wi(f), null;
        case 13:
          if (jt(pn), b = f.memoizedState, Wn && Lr !== null && f.mode & 1 && !(f.flags & 128)) {
            for (c = Lr; c; ) c = Zn(c);
            return Za(), f.flags |= 98560, f;
          }
          if (b !== null && b.dehydrated !== null) {
            if (b = ds(f), c === null) {
              if (!b) throw Error(l(318));
              if (!Be) throw Error(l(344));
              if (c = f.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(l(317));
              hn(c, f);
            } else Za(), !(f.flags & 128) && (f.memoizedState = null), f.flags |= 4;
            return wi(f), null;
          }
          return fs !== null && (Xf(fs), fs = null), f.flags & 128 ? (f.lanes = x, f) : (b = b !== null, x = !1, c === null ? ds(f) : x = c.memoizedState !== null, b && !x && (f.child.flags |= 8192, f.mode & 1 && (c === null || pn.current & 1 ? Ci === 0 && (Ci = 3) : jf())), f.updateQueue !== null && (f.flags |= 4), wi(f), null);
        case 4:
          return Sa(), Ps(c, f), c === null && He(f.stateNode.containerInfo), wi(f), null;
        case 10:
          return ef(f.type._context), wi(f), null;
        case 17:
          return Bi(f.type) && Kn(), wi(f), null;
        case 19:
          if (jt(pn), P = f.memoizedState, P === null) return wi(f), null;
          if (b = (f.flags & 128) !== 0, D = P.rendering, D === null) if (b) to(P, !1);
          else {
            if (Ci !== 0 || c !== null && c.flags & 128) for (c = f.child; c !== null; ) {
              if (D = mi(c), D !== null) {
                for (f.flags |= 128, to(P, !1), c = D.updateQueue, c !== null && (f.updateQueue = c, f.flags |= 4), f.subtreeFlags = 0, c = x, b = f.child; b !== null; ) x = b, P = c, x.flags &= 14680066, D = x.alternate, D === null ? (x.childLanes = 0, x.lanes = P, x.child = null, x.subtreeFlags = 0, x.memoizedProps = null, x.memoizedState = null, x.updateQueue = null, x.dependencies = null, x.stateNode = null) : (x.childLanes = D.childLanes, x.lanes = D.lanes, x.child = D.child, x.subtreeFlags = 0, x.deletions = null, x.memoizedProps = D.memoizedProps, x.memoizedState = D.memoizedState, x.updateQueue = D.updateQueue, x.type = D.type, P = D.dependencies, x.dependencies = P === null ? null : { lanes: P.lanes, firstContext: P.firstContext }), b = b.sibling;
                return ht(pn, pn.current & 1 | 2), f.child;
              }
              c = c.sibling;
            }
            P.tail !== null && Vi() > Xh && (f.flags |= 128, b = !0, to(P, !1), f.lanes = 4194304);
          }
          else {
            if (!b) if (c = mi(D), c !== null) {
              if (f.flags |= 128, b = !0, c = c.updateQueue, c !== null && (f.updateQueue = c, f.flags |= 4), to(P, !0), P.tail === null && P.tailMode === "hidden" && !D.alternate && !Wn) return wi(f), null;
            } else 2 * Vi() - P.renderingStartTime > Xh && x !== 1073741824 && (f.flags |= 128, b = !0, to(P, !1), f.lanes = 4194304);
            P.isBackwards ? (D.sibling = f.child, f.child = D) : (c = P.last, c !== null ? c.sibling = D : f.child = D, P.last = D);
          }
          return P.tail !== null ? (f = P.tail, P.rendering = f, P.tail = f.sibling, P.renderingStartTime = Vi(), f.sibling = null, c = pn.current, ht(pn, b ? c & 1 | 2 : c & 1), f) : (wi(f), null);
        case 22:
        case 23:
          return Kh(), b = f.memoizedState !== null, c !== null && c.memoizedState !== null !== b && (f.flags |= 8192), b && f.mode & 1 ? Zi & 1073741824 && (wi(f), pt && f.subtreeFlags & 6 && (f.flags |= 8192)) : wi(f), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(l(156, f.tag));
    }
    var wf = u.ReactCurrentOwner, Zr = !1;
    function mr(c, f, x, b) {
      f.child = c === null ? ff(f, null, x, b) : yl(f, c.child, x, b);
    }
    function ov(c, f, x, b, P) {
      x = x.render;
      var D = f.ref;
      return fl(f, P), b = Sl(c, f, x, b, D, P), x = hf(), c !== null && !Zr ? (f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~P, $s(c, f, P)) : (Wn && x && of(f), f.flags |= 1, mr(c, f, b, P), f.child);
    }
    function lv(c, f, x, b, P) {
      if (c === null) {
        var D = x.type;
        return typeof D == "function" && !Yf(D) && D.defaultProps === void 0 && x.compare === null && x.defaultProps === void 0 ? (f.tag = 15, f.type = D, Af(c, f, D, b, P)) : (c = zl(x.type, null, b, f, f.mode, P), c.ref = f.ref, c.return = f, f.child = c);
      }
      if (D = c.child, !(c.lanes & P)) {
        var X = D.memoizedProps;
        if (x = x.compare, x = x !== null ? x : Au, x(X, b) && c.ref === f.ref) return $s(c, f, P);
      }
      return f.flags |= 1, c = Ra(D, b), c.ref = f.ref, c.return = f, f.child = c;
    }
    function Af(c, f, x, b, P) {
      if (c !== null && Au(c.memoizedProps, b) && c.ref === f.ref) if (Zr = !1, (c.lanes & P) !== 0) c.flags & 131072 && (Zr = !0);
      else return f.lanes = c.lanes, $s(c, f, P);
      return Cf(c, f, x, b, P);
    }
    function uv(c, f, x) {
      var b = f.pendingProps, P = b.children, D = c !== null ? c.memoizedState : null;
      if (b.mode === "hidden") if (!(f.mode & 1)) f.memoizedState = { baseLanes: 0, cachePool: null }, ht(Ds, Zi), Zi |= x;
      else if (x & 1073741824) f.memoizedState = { baseLanes: 0, cachePool: null }, b = D !== null ? D.baseLanes : x, ht(Ds, Zi), Zi |= b;
      else return c = D !== null ? D.baseLanes | x : x, f.lanes = f.childLanes = 1073741824, f.memoizedState = { baseLanes: c, cachePool: null }, f.updateQueue = null, ht(Ds, Zi), Zi |= c, null;
      else D !== null ? (b = D.baseLanes | x, f.memoizedState = null) : b = x, ht(Ds, Zi), Zi |= b;
      return mr(c, f, P, x), f.child;
    }
    function Rf(c, f) {
      var x = f.ref;
      (c === null && x !== null || c !== null && c.ref !== x) && (f.flags |= 512, f.flags |= 2097152);
    }
    function Cf(c, f, x, b, P) {
      var D = Bi(x) ? Ws : on.current;
      return D = ls(f, D), fl(f, P), x = Sl(c, f, x, b, D, P), b = hf(), c !== null && !Zr ? (f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~P, $s(c, f, P)) : (Wn && b && of(f), f.flags |= 1, mr(c, f, x, P), f.child);
    }
    function cv(c, f, x, b, P) {
      if (Bi(x)) {
        var D = !0;
        Ti(f);
      } else D = !1;
      if (fl(f, P), f.stateNode === null) c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), tv(f, x, b), Eh(f, x, b, P), b = !0;
      else if (c === null) {
        var X = f.stateNode, ae = f.memoizedProps;
        X.props = ae;
        var Ce = X.context, et = x.contextType;
        typeof et == "object" && et !== null ? et = dr(et) : (et = Bi(x) ? Ws : on.current, et = ls(f, et));
        var bt = x.getDerivedStateFromProps, en = typeof bt == "function" || typeof X.getSnapshotBeforeUpdate == "function";
        en || typeof X.UNSAFE_componentWillReceiveProps != "function" && typeof X.componentWillReceiveProps != "function" || (ae !== b || Ce !== et) && nv(f, X, b, et), Ya = !1;
        var Bt = f.memoizedState;
        X.state = Bt, nf(f, b, X, P), Ce = f.memoizedState, ae !== b || Bt !== Ce || ti.current || Ya ? (typeof bt == "function" && (Mh(f, x, bt, b), Ce = f.memoizedState), (ae = Ya || ev(f, x, ae, b, Bt, Ce, et)) ? (en || typeof X.UNSAFE_componentWillMount != "function" && typeof X.componentWillMount != "function" || (typeof X.componentWillMount == "function" && X.componentWillMount(), typeof X.UNSAFE_componentWillMount == "function" && X.UNSAFE_componentWillMount()), typeof X.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof X.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = b, f.memoizedState = Ce), X.props = b, X.state = Ce, X.context = et, b = ae) : (typeof X.componentDidMount == "function" && (f.flags |= 4194308), b = !1);
      } else {
        X = f.stateNode, Jm(c, f), ae = f.memoizedProps, et = f.type === f.elementType ? ae : Rs(f.type, ae), X.props = et, en = f.pendingProps, Bt = X.context, Ce = x.contextType, typeof Ce == "object" && Ce !== null ? Ce = dr(Ce) : (Ce = Bi(x) ? Ws : on.current, Ce = ls(f, Ce));
        var Nn = x.getDerivedStateFromProps;
        (bt = typeof Nn == "function" || typeof X.getSnapshotBeforeUpdate == "function") || typeof X.UNSAFE_componentWillReceiveProps != "function" && typeof X.componentWillReceiveProps != "function" || (ae !== en || Bt !== Ce) && nv(f, X, b, Ce), Ya = !1, Bt = f.memoizedState, X.state = Bt, nf(f, b, X, P);
        var Nt = f.memoizedState;
        ae !== en || Bt !== Nt || ti.current || Ya ? (typeof Nn == "function" && (Mh(f, x, Nn, b), Nt = f.memoizedState), (et = Ya || ev(f, x, et, b, Bt, Nt, Ce) || !1) ? (bt || typeof X.UNSAFE_componentWillUpdate != "function" && typeof X.componentWillUpdate != "function" || (typeof X.componentWillUpdate == "function" && X.componentWillUpdate(
          b,
          Nt,
          Ce
        ), typeof X.UNSAFE_componentWillUpdate == "function" && X.UNSAFE_componentWillUpdate(b, Nt, Ce)), typeof X.componentDidUpdate == "function" && (f.flags |= 4), typeof X.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof X.componentDidUpdate != "function" || ae === c.memoizedProps && Bt === c.memoizedState || (f.flags |= 4), typeof X.getSnapshotBeforeUpdate != "function" || ae === c.memoizedProps && Bt === c.memoizedState || (f.flags |= 1024), f.memoizedProps = b, f.memoizedState = Nt), X.props = b, X.state = Nt, X.context = Ce, b = et) : (typeof X.componentDidUpdate != "function" || ae === c.memoizedProps && Bt === c.memoizedState || (f.flags |= 4), typeof X.getSnapshotBeforeUpdate != "function" || ae === c.memoizedProps && Bt === c.memoizedState || (f.flags |= 1024), b = !1);
      }
      return wl(c, f, x, b, D, P);
    }
    function wl(c, f, x, b, P, D) {
      Rf(c, f);
      var X = (f.flags & 128) !== 0;
      if (!b && !X) return P && bo(f, x, !1), $s(c, f, D);
      b = f.stateNode, wf.current = f;
      var ae = X && typeof x.getDerivedStateFromError != "function" ? null : b.render();
      return f.flags |= 1, c !== null && X ? (f.child = yl(f, c.child, null, D), f.child = yl(f, null, ae, D)) : mr(c, f, ae, D), f.memoizedState = b.state, P && bo(f, x, !0), f.child;
    }
    function fv(c) {
      var f = c.stateNode;
      f.pendingContext ? As(c, f.pendingContext, f.pendingContext !== f.context) : f.context && As(c, f.context, !1), Nu(c, f.containerInfo);
    }
    function Fh(c, f, x, b, P) {
      return Za(), vl(P), f.flags |= 256, mr(c, f, x, b), f.child;
    }
    var Pf = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Lf(c) {
      return { baseLanes: c, cachePool: null };
    }
    function no(c, f, x) {
      var b = f.pendingProps, P = pn.current, D = !1, X = (f.flags & 128) !== 0, ae;
      if ((ae = X) || (ae = c !== null && c.memoizedState === null ? !1 : (P & 2) !== 0), ae ? (D = !0, f.flags &= -129) : (c === null || c.memoizedState !== null) && (P |= 1), ht(pn, P & 1), c === null)
        return Lu(f), c = f.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? (f.mode & 1 ? Mo(c) ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1, null) : (P = b.children, c = b.fallback, D ? (b = f.mode, D = f.child, P = { mode: "hidden", children: P }, !(b & 1) && D !== null ? (D.childLanes = 0, D.pendingProps = P) : D = qf(P, b, 0, null), c = Io(c, b, x, null), D.return = f, c.return = f, D.sibling = c, f.child = D, f.child.memoizedState = Lf(x), f.memoizedState = Pf, c) : Do(f, P));
      if (P = c.memoizedState, P !== null) {
        if (ae = P.dehydrated, ae !== null) {
          if (X)
            return f.flags & 256 ? (f.flags &= -257, lr(c, f, x, Error(l(422)))) : f.memoizedState !== null ? (f.child = c.child, f.flags |= 128, null) : (D = b.fallback, P = f.mode, b = qf({ mode: "visible", children: b.children }, P, 0, null), D = Io(D, P, x, null), D.flags |= 2, b.return = f, D.return = f, b.sibling = D, f.child = b, f.mode & 1 && yl(
              f,
              c.child,
              null,
              x
            ), f.child.memoizedState = Lf(x), f.memoizedState = Pf, D);
          if (!(f.mode & 1)) f = lr(c, f, x, null);
          else if (Mo(ae)) f = lr(c, f, x, Error(l(419)));
          else if (b = (x & c.childLanes) !== 0, Zr || b) {
            if (b = gi, b !== null) {
              switch (x & -x) {
                case 4:
                  D = 2;
                  break;
                case 16:
                  D = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  D = 32;
                  break;
                case 536870912:
                  D = 268435456;
                  break;
                default:
                  D = 0;
              }
              b = D & (b.suspendedLanes | x) ? 0 : D, b !== 0 && b !== P.retryLane && (P.retryLane = b, xi(c, b, -1));
            }
            jf(), f = lr(c, f, x, Error(l(421)));
          } else va(ae) ? (f.flags |= 128, f.child = c.child, f = ju.bind(null, c), ws(ae, f), f = null) : (x = P.treeContext, Be && (Lr = vt(ae), Pr = f, Wn = !0, fs = null, ml = !1, x !== null && (us[cs++] = ya, us[cs++] = xa, us[cs++] = wo, ya = x.id, xa = x.overflow, wo = f)), f = Do(f, f.pendingProps.children), f.flags |= 4096);
          return f;
        }
        return D ? (b = Df(c, f, b.children, b.fallback, x), D = f.child, P = c.child.memoizedState, D.memoizedState = P === null ? Lf(x) : { baseLanes: P.baseLanes | x, cachePool: null }, D.childLanes = c.childLanes & ~x, f.memoizedState = Pf, b) : (x = io(c, f, b.children, x), f.memoizedState = null, x);
      }
      return D ? (b = Df(c, f, b.children, b.fallback, x), D = f.child, P = c.child.memoizedState, D.memoizedState = P === null ? Lf(x) : { baseLanes: P.baseLanes | x, cachePool: null }, D.childLanes = c.childLanes & ~x, f.memoizedState = Pf, b) : (x = io(c, f, b.children, x), f.memoizedState = null, x);
    }
    function Do(c, f) {
      return f = qf({ mode: "visible", children: f }, c.mode, 0, null), f.return = c, c.child = f;
    }
    function io(c, f, x, b) {
      var P = c.child;
      return c = P.sibling, x = Ra(P, { mode: "visible", children: x }), !(f.mode & 1) && (x.lanes = b), x.return = f, x.sibling = null, c !== null && (b = f.deletions, b === null ? (f.deletions = [c], f.flags |= 16) : b.push(c)), f.child = x;
    }
    function Df(c, f, x, b, P) {
      var D = f.mode;
      c = c.child;
      var X = c.sibling, ae = { mode: "hidden", children: x };
      return !(D & 1) && f.child !== c ? (x = f.child, x.childLanes = 0, x.pendingProps = ae, f.deletions = null) : (x = Ra(c, ae), x.subtreeFlags = c.subtreeFlags & 14680064), X !== null ? b = Ra(X, b) : (b = Io(b, D, P, null), b.flags |= 2), b.return = f, x.return = f, x.sibling = b, f.child = x, b;
    }
    function lr(c, f, x, b) {
      return b !== null && vl(b), yl(f, c.child, null, x), c = Do(f, f.pendingProps.children), c.flags |= 2, f.memoizedState = null, c;
    }
    function No(c, f, x) {
      c.lanes |= f;
      var b = c.alternate;
      b !== null && (b.lanes |= f), Pu(c.return, f, x);
    }
    function nn(c, f, x, b, P) {
      var D = c.memoizedState;
      D === null ? c.memoizedState = { isBackwards: f, rendering: null, renderingStartTime: 0, last: b, tail: x, tailMode: P } : (D.isBackwards = f, D.rendering = null, D.renderingStartTime = 0, D.last = b, D.tail = x, D.tailMode = P);
    }
    function Fu(c, f, x) {
      var b = f.pendingProps, P = b.revealOrder, D = b.tail;
      if (mr(c, f, b.children, x), b = pn.current, b & 2) b = b & 1 | 2, f.flags |= 128;
      else {
        if (c !== null && c.flags & 128) e: for (c = f.child; c !== null; ) {
          if (c.tag === 13) c.memoizedState !== null && No(c, x, f);
          else if (c.tag === 19) No(c, x, f);
          else if (c.child !== null) {
            c.child.return = c, c = c.child;
            continue;
          }
          if (c === f) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === f) break e;
            c = c.return;
          }
          c.sibling.return = c.return, c = c.sibling;
        }
        b &= 1;
      }
      if (ht(pn, b), !(f.mode & 1)) f.memoizedState = null;
      else switch (P) {
        case "forwards":
          for (x = f.child, P = null; x !== null; ) c = x.alternate, c !== null && mi(c) === null && (P = x), x = x.sibling;
          x = P, x === null ? (P = f.child, f.child = null) : (P = x.sibling, x.sibling = null), nn(f, !1, P, x, D);
          break;
        case "backwards":
          for (x = null, P = f.child, f.child = null; P !== null; ) {
            if (c = P.alternate, c !== null && mi(c) === null) {
              f.child = P;
              break;
            }
            c = P.sibling, P.sibling = x, x = P, P = c;
          }
          nn(f, !0, x, null, D);
          break;
        case "together":
          nn(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
      return f.child;
    }
    function $s(c, f, x) {
      if (c !== null && (f.dependencies = c.dependencies), Pl |= f.lanes, !(x & f.childLanes)) return null;
      if (c !== null && f.child !== c.child) throw Error(l(153));
      if (f.child !== null) {
        for (c = f.child, x = Ra(c, c.pendingProps), f.child = x, x.return = f; c.sibling !== null; ) c = c.sibling, x = x.sibling = Ra(c, c.pendingProps), x.return = f;
        x.sibling = null;
      }
      return f.child;
    }
    function Vb(c, f, x) {
      switch (f.tag) {
        case 3:
          fv(f), Za();
          break;
        case 5:
          Ks(f);
          break;
        case 1:
          Bi(f.type) && Ti(f);
          break;
        case 4:
          Nu(f, f.stateNode.containerInfo);
          break;
        case 10:
          Km(f, f.type._context, f.memoizedProps.value);
          break;
        case 13:
          var b = f.memoizedState;
          if (b !== null)
            return b.dehydrated !== null ? (ht(pn, pn.current & 1), f.flags |= 128, null) : x & f.child.childLanes ? no(c, f, x) : (ht(pn, pn.current & 1), c = $s(c, f, x), c !== null ? c.sibling : null);
          ht(pn, pn.current & 1);
          break;
        case 19:
          if (b = (x & f.childLanes) !== 0, c.flags & 128) {
            if (b) return Fu(
              c,
              f,
              x
            );
            f.flags |= 128;
          }
          var P = f.memoizedState;
          if (P !== null && (P.rendering = null, P.tail = null, P.lastEffect = null), ht(pn, pn.current), b) break;
          return null;
        case 22:
        case 23:
          return f.lanes = 0, uv(c, f, x);
      }
      return $s(c, f, x);
    }
    function tx(c, f) {
      switch (lf(f), f.tag) {
        case 1:
          return Bi(f.type) && Kn(), c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
        case 3:
          return Sa(), jt(ti), jt(on), hr(), c = f.flags, c & 65536 && !(c & 128) ? (f.flags = c & -65537 | 128, f) : null;
        case 5:
          return Js(f), null;
        case 13:
          if (jt(pn), c = f.memoizedState, c !== null && c.dehydrated !== null) {
            if (f.alternate === null) throw Error(l(340));
            Za();
          }
          return c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
        case 19:
          return jt(pn), null;
        case 4:
          return Sa(), null;
        case 10:
          return ef(f.type._context), null;
        case 22:
        case 23:
          return Kh(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Al = !1, Ls = !1, nx = typeof WeakSet == "function" ? WeakSet : Set, gt = null;
    function Nf(c, f) {
      var x = c.ref;
      if (x !== null) if (typeof x == "function") try {
        x(null);
      } catch (b) {
        _i(c, f, b);
      }
      else x.current = null;
    }
    function zu(c, f, x) {
      try {
        x();
      } catch (b) {
        _i(c, f, b);
      }
    }
    var dv = !1;
    function hv(c, f) {
      for (se(c.containerInfo), gt = f; gt !== null; ) if (c = gt, f = c.child, (c.subtreeFlags & 1028) !== 0 && f !== null) f.return = c, gt = f;
      else for (; gt !== null; ) {
        c = gt;
        try {
          var x = c.alternate;
          if (c.flags & 1024) switch (c.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (x !== null) {
                var b = x.memoizedProps, P = x.memoizedState, D = c.stateNode, X = D.getSnapshotBeforeUpdate(c.elementType === c.type ? b : Rs(c.type, b), P);
                D.__reactInternalSnapshotBeforeUpdate = X;
              }
              break;
            case 3:
              pt && Ke(c.stateNode.containerInfo);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(l(163));
          }
        } catch (ae) {
          _i(c, c.return, ae);
        }
        if (f = c.sibling, f !== null) {
          f.return = c.return, gt = f;
          break;
        }
        gt = c.return;
      }
      return x = dv, dv = !1, x;
    }
    function ro(c, f, x) {
      var b = f.updateQueue;
      if (b = b !== null ? b.lastEffect : null, b !== null) {
        var P = b = b.next;
        do {
          if ((P.tag & c) === c) {
            var D = P.destroy;
            P.destroy = void 0, D !== void 0 && zu(f, x, D);
          }
          P = P.next;
        } while (P !== b);
      }
    }
    function Ur(c, f) {
      if (f = f.updateQueue, f = f !== null ? f.lastEffect : null, f !== null) {
        var x = f = f.next;
        do {
          if ((x.tag & c) === c) {
            var b = x.create;
            x.destroy = b();
          }
          x = x.next;
        } while (x !== f);
      }
    }
    function Uo(c) {
      var f = c.ref;
      if (f !== null) {
        var x = c.stateNode;
        switch (c.tag) {
          case 5:
            c = ie(x);
            break;
          default:
            c = x;
        }
        typeof f == "function" ? f(c) : f.current = c;
      }
    }
    function Rl(c, f, x) {
      if (Xs && typeof Xs.onCommitFiberUnmount == "function") try {
        Xs.onCommitFiberUnmount(Qc, f);
      } catch {
      }
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (c = f.updateQueue, c !== null && (c = c.lastEffect, c !== null)) {
            var b = c = c.next;
            do {
              var P = b, D = P.destroy;
              P = P.tag, D !== void 0 && (P & 2 || P & 4) && zu(f, x, D), b = b.next;
            } while (b !== c);
          }
          break;
        case 1:
          if (Nf(f, x), c = f.stateNode, typeof c.componentWillUnmount == "function") try {
            c.props = f.memoizedProps, c.state = f.memoizedState, c.componentWillUnmount();
          } catch (X) {
            _i(
              f,
              x,
              X
            );
          }
          break;
        case 5:
          Nf(f, x);
          break;
        case 4:
          pt ? Vh(c, f, x) : J && J && (f = f.stateNode.containerInfo, x = zt(f), tn(f, x));
      }
    }
    function Uf(c, f, x) {
      for (var b = f; ; ) if (Rl(c, b, x), b.child === null || pt && b.tag === 4) {
        if (b === f) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === f) return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      } else b.child.return = b, b = b.child;
    }
    function Cl(c) {
      var f = c.alternate;
      f !== null && (c.alternate = null, Cl(f)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (f = c.stateNode, f !== null && _t(f)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
    }
    function ms(c) {
      return c.tag === 5 || c.tag === 3 || c.tag === 4;
    }
    function Ai(c) {
      e: for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || ms(c.return)) return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) return c.stateNode;
      }
    }
    function pv(c) {
      if (pt) {
        e: {
          for (var f = c.return; f !== null; ) {
            if (ms(f)) break e;
            f = f.return;
          }
          throw Error(l(160));
        }
        var x = f;
        switch (x.tag) {
          case 5:
            f = x.stateNode, x.flags & 32 && (he(f), x.flags &= -33), x = Ai(c), Bh(c, x, f);
            break;
          case 3:
          case 4:
            f = x.stateNode.containerInfo, x = Ai(c), zh(c, x, f);
            break;
          default:
            throw Error(l(161));
        }
      }
    }
    function zh(c, f, x) {
      var b = c.tag;
      if (b === 5 || b === 6) c = c.stateNode, f ? dt(x, c, f) : Ht(x, c);
      else if (b !== 4 && (c = c.child, c !== null)) for (zh(c, f, x), c = c.sibling; c !== null; ) zh(c, f, x), c = c.sibling;
    }
    function Bh(c, f, x) {
      var b = c.tag;
      if (b === 5 || b === 6) c = c.stateNode, f ? Xe(x, c, f) : Dt(x, c);
      else if (b !== 4 && (c = c.child, c !== null)) for (Bh(c, f, x), c = c.sibling; c !== null; ) Bh(c, f, x), c = c.sibling;
    }
    function Vh(c, f, x) {
      for (var b = f, P = !1, D, X; ; ) {
        if (!P) {
          P = b.return;
          e: for (; ; ) {
            if (P === null) throw Error(l(160));
            switch (D = P.stateNode, P.tag) {
              case 5:
                X = !1;
                break e;
              case 3:
                D = D.containerInfo, X = !0;
                break e;
              case 4:
                D = D.containerInfo, X = !0;
                break e;
            }
            P = P.return;
          }
          P = !0;
        }
        if (b.tag === 5 || b.tag === 6) Uf(c, b, x), X ? Y(D, b.stateNode) : at(D, b.stateNode);
        else if (b.tag === 18) X ? me(D, b.stateNode) : ve(D, b.stateNode);
        else if (b.tag === 4) {
          if (b.child !== null) {
            D = b.stateNode.containerInfo, X = !0, b.child.return = b, b = b.child;
            continue;
          }
        } else if (Rl(c, b, x), b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === f) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === f) return;
          b = b.return, b.tag === 4 && (P = !1);
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }
    function Of(c, f) {
      if (pt) {
        switch (f.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ro(3, f, f.return), Ur(3, f), ro(5, f, f.return);
            return;
          case 1:
            return;
          case 5:
            var x = f.stateNode;
            if (x != null) {
              var b = f.memoizedProps;
              c = c !== null ? c.memoizedProps : b;
              var P = f.type, D = f.updateQueue;
              f.updateQueue = null, D !== null && lt(x, D, P, c, b, f);
            }
            return;
          case 6:
            if (f.stateNode === null) throw Error(l(162));
            x = f.memoizedProps, de(f.stateNode, c !== null ? c.memoizedProps : x, x);
            return;
          case 3:
            Be && c !== null && c.memoizedState.isDehydrated && ne(f.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Bu(f);
            return;
          case 19:
            Bu(f);
            return;
          case 17:
            return;
        }
        throw Error(l(163));
      }
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ro(3, f, f.return), Ur(3, f), ro(5, f, f.return);
          return;
        case 12:
          return;
        case 13:
          Bu(f);
          return;
        case 19:
          Bu(f);
          return;
        case 3:
          Be && c !== null && c.memoizedState.isDehydrated && ne(f.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if (J) {
        switch (f.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            f = f.stateNode, tn(f.containerInfo, f.pendingChildren);
            break e;
        }
        throw Error(l(163));
      }
    }
    function Bu(c) {
      var f = c.updateQueue;
      if (f !== null) {
        c.updateQueue = null;
        var x = c.stateNode;
        x === null && (x = c.stateNode = new nx()), f.forEach(function(b) {
          var P = Yu.bind(null, c, b);
          x.has(b) || (x.add(b), b.then(P, P));
        });
      }
    }
    function ix(c, f) {
      for (gt = f; gt !== null; ) {
        f = gt;
        var x = f.deletions;
        if (x !== null) for (var b = 0; b < x.length; b++) {
          var P = x[b];
          try {
            var D = c;
            pt ? Vh(D, P, f) : Uf(D, P, f);
            var X = P.alternate;
            X !== null && (X.return = null), P.return = null;
          } catch (Pt) {
            _i(P, f, Pt);
          }
        }
        if (x = f.child, f.subtreeFlags & 12854 && x !== null) x.return = f, gt = x;
        else for (; gt !== null; ) {
          f = gt;
          try {
            var ae = f.flags;
            if (ae & 32 && pt && he(f.stateNode), ae & 512) {
              var Ce = f.alternate;
              if (Ce !== null) {
                var et = Ce.ref;
                et !== null && (typeof et == "function" ? et(null) : et.current = null);
              }
            }
            if (ae & 8192) switch (f.tag) {
              case 13:
                if (f.memoizedState !== null) {
                  var bt = f.alternate;
                  (bt === null || bt.memoizedState === null) && (Vf = Vi());
                }
                break;
              case 22:
                var en = f.memoizedState !== null, Bt = f.alternate, Nn = Bt !== null && Bt.memoizedState !== null;
                if (x = f, pt) {
                  e: if (b = x, P = en, D = null, pt) for (var Nt = b; ; ) {
                    if (Nt.tag === 5) {
                      if (D === null) {
                        D = Nt;
                        var ki = Nt.stateNode;
                        P ? Ze(ki) : Te(Nt.stateNode, Nt.memoizedProps);
                      }
                    } else if (Nt.tag === 6) {
                      if (D === null) {
                        var _r = Nt.stateNode;
                        P ? Ve(_r) : ee(_r, Nt.memoizedProps);
                      }
                    } else if ((Nt.tag !== 22 && Nt.tag !== 23 || Nt.memoizedState === null || Nt === b) && Nt.child !== null) {
                      Nt.child.return = Nt, Nt = Nt.child;
                      continue;
                    }
                    if (Nt === b) break;
                    for (; Nt.sibling === null; ) {
                      if (Nt.return === null || Nt.return === b) break e;
                      D === Nt && (D = null), Nt = Nt.return;
                    }
                    D === Nt && (D = null), Nt.sibling.return = Nt.return, Nt = Nt.sibling;
                  }
                }
                if (en && !Nn && x.mode & 1) {
                  gt = x;
                  for (var Se = x.child; Se !== null; ) {
                    for (x = gt = Se; gt !== null; ) {
                      b = gt;
                      var fe = b.child;
                      switch (b.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          ro(4, b, b.return);
                          break;
                        case 1:
                          Nf(b, b.return);
                          var be = b.stateNode;
                          if (typeof be.componentWillUnmount == "function") {
                            var ut = b.return;
                            try {
                              be.props = b.memoizedProps, be.state = b.memoizedState, be.componentWillUnmount();
                            } catch (Pt) {
                              _i(
                                b,
                                ut,
                                Pt
                              );
                            }
                          }
                          break;
                        case 5:
                          Nf(b, b.return);
                          break;
                        case 22:
                          if (b.memoizedState !== null) {
                            Vu(x);
                            continue;
                          }
                      }
                      fe !== null ? (fe.return = b, gt = fe) : Vu(x);
                    }
                    Se = Se.sibling;
                  }
                }
            }
            switch (ae & 4102) {
              case 2:
                pv(f), f.flags &= -3;
                break;
              case 6:
                pv(f), f.flags &= -3, Of(f.alternate, f);
                break;
              case 4096:
                f.flags &= -4097;
                break;
              case 4100:
                f.flags &= -4097, Of(f.alternate, f);
                break;
              case 4:
                Of(f.alternate, f);
            }
          } catch (Pt) {
            _i(f, f.return, Pt);
          }
          if (x = f.sibling, x !== null) {
            x.return = f.return, gt = x;
            break;
          }
          gt = f.return;
        }
      }
    }
    function rx(c, f, x) {
      gt = c, mv(c);
    }
    function mv(c, f, x) {
      for (var b = (c.mode & 1) !== 0; gt !== null; ) {
        var P = gt, D = P.child;
        if (P.tag === 22 && b) {
          var X = P.memoizedState !== null || Al;
          if (!X) {
            var ae = P.alternate, Ce = ae !== null && ae.memoizedState !== null || Ls;
            ae = Al;
            var et = Ls;
            if (Al = X, (Ls = Ce) && !et) for (gt = P; gt !== null; ) X = gt, Ce = X.child, X.tag === 22 && X.memoizedState !== null ? Hh(P) : Ce !== null ? (Ce.return = X, gt = Ce) : Hh(P);
            for (; D !== null; ) gt = D, mv(D), D = D.sibling;
            gt = P, Al = ae, Ls = et;
          }
          Ri(c);
        } else P.subtreeFlags & 8772 && D !== null ? (D.return = P, gt = D) : Ri(c);
      }
    }
    function Ri(c) {
      for (; gt !== null; ) {
        var f = gt;
        if (f.flags & 8772) {
          var x = f.alternate;
          try {
            if (f.flags & 8772) switch (f.tag) {
              case 0:
              case 11:
              case 15:
                Ls || Ur(5, f);
                break;
              case 1:
                var b = f.stateNode;
                if (f.flags & 4 && !Ls) if (x === null) b.componentDidMount();
                else {
                  var P = f.elementType === f.type ? x.memoizedProps : Rs(f.type, x.memoizedProps);
                  b.componentDidUpdate(P, x.memoizedState, b.__reactInternalSnapshotBeforeUpdate);
                }
                var D = f.updateQueue;
                D !== null && Qm(f, D, b);
                break;
              case 3:
                var X = f.updateQueue;
                if (X !== null) {
                  if (x = null, f.child !== null) switch (f.child.tag) {
                    case 5:
                      x = ie(f.child.stateNode);
                      break;
                    case 1:
                      x = f.child.stateNode;
                  }
                  Qm(f, X, x);
                }
                break;
              case 5:
                var ae = f.stateNode;
                x === null && f.flags & 4 && nt(ae, f.type, f.memoizedProps, f);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Be && f.memoizedState === null) {
                  var Ce = f.alternate;
                  if (Ce !== null) {
                    var et = Ce.memoizedState;
                    if (et !== null) {
                      var bt = et.dehydrated;
                      bt !== null && ge(bt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(l(163));
            }
            Ls || f.flags & 512 && Uo(f);
          } catch (en) {
            _i(f, f.return, en);
          }
        }
        if (f === c) {
          gt = null;
          break;
        }
        if (x = f.sibling, x !== null) {
          x.return = f.return, gt = x;
          break;
        }
        gt = f.return;
      }
    }
    function Vu(c) {
      for (; gt !== null; ) {
        var f = gt;
        if (f === c) {
          gt = null;
          break;
        }
        var x = f.sibling;
        if (x !== null) {
          x.return = f.return, gt = x;
          break;
        }
        gt = f.return;
      }
    }
    function Hh(c) {
      for (; gt !== null; ) {
        var f = gt;
        try {
          switch (f.tag) {
            case 0:
            case 11:
            case 15:
              var x = f.return;
              try {
                Ur(4, f);
              } catch (Ce) {
                _i(f, x, Ce);
              }
              break;
            case 1:
              var b = f.stateNode;
              if (typeof b.componentDidMount == "function") {
                var P = f.return;
                try {
                  b.componentDidMount();
                } catch (Ce) {
                  _i(f, P, Ce);
                }
              }
              var D = f.return;
              try {
                Uo(f);
              } catch (Ce) {
                _i(f, D, Ce);
              }
              break;
            case 5:
              var X = f.return;
              try {
                Uo(f);
              } catch (Ce) {
                _i(f, X, Ce);
              }
          }
        } catch (Ce) {
          _i(f, f.return, Ce);
        }
        if (f === c) {
          gt = null;
          break;
        }
        var ae = f.sibling;
        if (ae !== null) {
          ae.return = f.return, gt = ae;
          break;
        }
        gt = f.return;
      }
    }
    var ba = 0, Hu = 1, If = 2, Ff = 3, Ta = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var vi = Symbol.for;
      ba = vi("selector.component"), Hu = vi("selector.has_pseudo_class"), If = vi("selector.role"), Ff = vi("selector.test_id"), Ta = vi("selector.text");
    }
    function yt(c) {
      var f = Pe(c);
      if (f != null) {
        if (typeof f.memoizedProps["data-testname"] != "string") throw Error(l(364));
        return f;
      }
      if (c = ce(c), c === null) throw Error(l(362));
      return c.stateNode.current;
    }
    function vs(c, f) {
      switch (f.$$typeof) {
        case ba:
          if (c.type === f.value) return !0;
          break;
        case Hu:
          e: {
            f = f.value, c = [c, 0];
            for (var x = 0; x < c.length; ) {
              var b = c[x++], P = c[x++], D = f[P];
              if (b.tag !== 5 || !Ie(b)) {
                for (; D != null && vs(b, D); ) P++, D = f[P];
                if (P === f.length) {
                  f = !0;
                  break e;
                } else for (b = b.child; b !== null; ) c.push(b, P), b = b.sibling;
              }
            }
            f = !1;
          }
          return f;
        case If:
          if (c.tag === 5 && Mt(c.stateNode, f.value)) return !0;
          break;
        case Ta:
          if ((c.tag === 5 || c.tag === 6) && (c = ze(c), c !== null && 0 <= c.indexOf(f.value))) return !0;
          break;
        case Ff:
          if (c.tag === 5 && (c = c.memoizedProps["data-testname"], typeof c == "string" && c.toLowerCase() === f.value.toLowerCase())) return !0;
          break;
        default:
          throw Error(l(365));
      }
      return !1;
    }
    function Kr(c) {
      switch (c.$$typeof) {
        case ba:
          return "<" + (V(c.value) || "Unknown") + ">";
        case Hu:
          return ":has(" + (Kr(c) || "") + ")";
        case If:
          return '[role="' + c.value + '"]';
        case Ta:
          return '"' + c.value + '"';
        case Ff:
          return '[data-testname="' + c.value + '"]';
        default:
          throw Error(l(365));
      }
    }
    function vv(c, f) {
      var x = [];
      c = [c, 0];
      for (var b = 0; b < c.length; ) {
        var P = c[b++], D = c[b++], X = f[D];
        if (P.tag !== 5 || !Ie(P)) {
          for (; X != null && vs(P, X); ) D++, X = f[D];
          if (D === f.length) x.push(P);
          else for (P = P.child; P !== null; ) c.push(P, D), P = P.sibling;
        }
      }
      return x;
    }
    function kh(c, f) {
      if (!B) throw Error(l(363));
      c = yt(c), c = vv(c, f), f = [], c = Array.from(c);
      for (var x = 0; x < c.length; ) {
        var b = c[x++];
        if (b.tag === 5) Ie(b) || f.push(b.stateNode);
        else for (b = b.child; b !== null; ) c.push(b), b = b.sibling;
      }
      return f;
    }
    var sx = Math.ceil, zf = u.ReactCurrentDispatcher, Gh = u.ReactCurrentOwner, mn = u.ReactCurrentBatchConfig, un = 0, gi = null, yi = null, Hi = 0, Zi = 0, Ds = bi(0), Ci = 0, ku = null, Pl = 0, Bf = 0, Wh = 0, Gu = null, vr = null, Vf = 0, Xh = 1 / 0;
    function Ll() {
      Xh = Vi() + 500;
    }
    var Hf = !1, jh = null, so = null, kf = !1, wa = null, Gf = 0, Dl = 0, Yh = null, Wf = -1, Nl = 0;
    function gr() {
      return un & 6 ? Vi() : Wf !== -1 ? Wf : Wf = Vi();
    }
    function Pi(c) {
      return c.mode & 1 ? un & 2 && Hi !== 0 ? Hi & -Hi : ex.transition !== null ? (Nl === 0 && (c = Jc, Jc <<= 1, !(Jc & 4194240) && (Jc = 64), Nl = c), Nl) : (c = An, c !== 0 ? c : Re()) : 1;
    }
    function xi(c, f, x) {
      if (50 < Dl) throw Dl = 0, Yh = null, Error(l(185));
      var b = Ul(c, f);
      return b === null ? null : (wu(b, f, x), (!(un & 2) || b !== gi) && (b === gi && (!(un & 2) && (Bf |= f), Ci === 4 && Aa(b, Hi)), ur(b, x), f === 1 && un === 0 && !(c.mode & 1) && (Ll(), $c && qs())), b);
    }
    function Ul(c, f) {
      c.lanes |= f;
      var x = c.alternate;
      for (x !== null && (x.lanes |= f), x = c, c = c.return; c !== null; ) c.childLanes |= f, x = c.alternate, x !== null && (x.childLanes |= f), x = c, c = c.return;
      return x.tag === 3 ? x.stateNode : null;
    }
    function ur(c, f) {
      var x = c.callbackNode;
      X0(c, f);
      var b = ar(c, c === gi ? Hi : 0);
      if (b === 0) x !== null && cl(x), c.callbackNode = null, c.callbackPriority = 0;
      else if (f = b & -b, c.callbackPriority !== f) {
        if (x != null && cl(x), f === 1) c.tag === 0 ? $0(gv.bind(null, c)) : qm(gv.bind(null, c)), rt ? G(function() {
          un === 0 && qs();
        }) : ph(mh, qs), x = null;
        else {
          switch (Ym(b)) {
            case 1:
              x = mh;
              break;
            case 4:
              x = Z0;
              break;
            case 16:
              x = vh;
              break;
            case 536870912:
              x = K0;
              break;
            default:
              x = vh;
          }
          x = Fl(x, qh.bind(null, c));
        }
        c.callbackPriority = f, c.callbackNode = x;
      }
    }
    function qh(c, f) {
      if (Wf = -1, Nl = 0, un & 6) throw Error(l(327));
      var x = c.callbackNode;
      if (Ji() && c.callbackNode !== x) return null;
      var b = ar(c, c === gi ? Hi : 0);
      if (b === 0) return null;
      if (b & 30 || b & c.expiredLanes || f) f = yr(c, b);
      else {
        f = b;
        var P = un;
        un |= 2;
        var D = Jh();
        (gi !== c || Hi !== f) && (Ll(), ta(c, f));
        do
          try {
            ax();
            break;
          } catch (ae) {
            xv(c, ae);
          }
        while (!0);
        xh(), zf.current = D, un = P, yi !== null ? f = 0 : (gi = null, Hi = 0, f = Ci);
      }
      if (f !== 0) {
        if (f === 2 && (P = dh(c), P !== 0 && (b = P, f = Zh(c, P))), f === 1) throw x = ku, ta(c, 0), Aa(c, b), ur(c, Vi()), x;
        if (f === 6) Aa(c, b);
        else {
          if (P = c.current.alternate, !(b & 30) && !ea(P) && (f = yr(c, b), f === 2 && (D = dh(c), D !== 0 && (b = D, f = Zh(c, D))), f === 1)) throw x = ku, ta(c, 0), Aa(c, b), ur(c, Vi()), x;
          switch (c.finishedWork = P, c.finishedLanes = b, f) {
            case 0:
            case 1:
              throw Error(l(345));
            case 2:
              jn(c, vr);
              break;
            case 3:
              if (Aa(c, b), (b & 130023424) === b && (f = Vf + 500 - Vi(), 10 < f)) {
                if (ar(c, 0) !== 0) break;
                if (P = c.suspendedLanes, (P & b) !== b) {
                  gr(), c.pingedLanes |= c.suspendedLanes & P;
                  break;
                }
                c.timeoutHandle = $e(jn.bind(null, c, vr), f);
                break;
              }
              jn(c, vr);
              break;
            case 4:
              if (Aa(c, b), (b & 4194240) === b) break;
              for (f = c.eventTimes, P = -1; 0 < b; ) {
                var X = 31 - Rr(b);
                D = 1 << X, X = f[X], X > P && (P = X), b &= ~D;
              }
              if (b = P, b = Vi() - b, b = (120 > b ? 120 : 480 > b ? 480 : 1080 > b ? 1080 : 1920 > b ? 1920 : 3e3 > b ? 3e3 : 4320 > b ? 4320 : 1960 * sx(b / 1960)) - b, 10 < b) {
                c.timeoutHandle = $e(jn.bind(null, c, vr), b);
                break;
              }
              jn(c, vr);
              break;
            case 5:
              jn(c, vr);
              break;
            default:
              throw Error(l(329));
          }
        }
      }
      return ur(c, Vi()), c.callbackNode === x ? qh.bind(null, c) : null;
    }
    function Zh(c, f) {
      var x = Gu;
      return c.current.memoizedState.isDehydrated && (ta(c, f).flags |= 256), c = yr(c, f), c !== 2 && (f = vr, vr = x, f !== null && Xf(f)), c;
    }
    function Xf(c) {
      vr === null ? vr = c : vr.push.apply(vr, c);
    }
    function ea(c) {
      for (var f = c; ; ) {
        if (f.flags & 16384) {
          var x = f.updateQueue;
          if (x !== null && (x = x.stores, x !== null)) for (var b = 0; b < x.length; b++) {
            var P = x[b], D = P.getSnapshot;
            P = P.value;
            try {
              if (!js(D(), P)) return !1;
            } catch {
              return !1;
            }
          }
        }
        if (x = f.child, f.subtreeFlags & 16384 && x !== null) x.return = f, f = x;
        else {
          if (f === c) break;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === c) return !0;
            f = f.return;
          }
          f.sibling.return = f.return, f = f.sibling;
        }
      }
      return !0;
    }
    function Aa(c, f) {
      for (f &= ~Wh, f &= ~Bf, c.suspendedLanes |= f, c.pingedLanes &= ~f, c = c.expirationTimes; 0 < f; ) {
        var x = 31 - Rr(f), b = 1 << x;
        c[x] = -1, f &= ~b;
      }
    }
    function gv(c) {
      if (un & 6) throw Error(l(327));
      Ji();
      var f = ar(c, 0);
      if (!(f & 1)) return ur(c, Vi()), null;
      var x = yr(c, f);
      if (c.tag !== 0 && x === 2) {
        var b = dh(c);
        b !== 0 && (f = b, x = Zh(c, b));
      }
      if (x === 1) throw x = ku, ta(c, 0), Aa(c, f), ur(c, Vi()), x;
      if (x === 6) throw Error(l(345));
      return c.finishedWork = c.current.alternate, c.finishedLanes = f, jn(c, vr), ur(c, Vi()), null;
    }
    function yv(c) {
      wa !== null && wa.tag === 0 && !(un & 6) && Ji();
      var f = un;
      un |= 1;
      var x = mn.transition, b = An;
      try {
        if (mn.transition = null, An = 1, c) return c();
      } finally {
        An = b, mn.transition = x, un = f, !(un & 6) && qs();
      }
    }
    function Kh() {
      Zi = Ds.current, jt(Ds);
    }
    function ta(c, f) {
      c.finishedWork = null, c.finishedLanes = 0;
      var x = c.timeoutHandle;
      if (x !== Ut && (c.timeoutHandle = Ut, Rt(x)), yi !== null) for (x = yi.return; x !== null; ) {
        var b = x;
        switch (lf(b), b.tag) {
          case 1:
            b = b.type.childContextTypes, b != null && Kn();
            break;
          case 3:
            Sa(), jt(ti), jt(on), hr();
            break;
          case 5:
            Js(b);
            break;
          case 4:
            Sa();
            break;
          case 13:
            jt(pn);
            break;
          case 19:
            jt(pn);
            break;
          case 10:
            ef(b.type._context);
            break;
          case 22:
          case 23:
            Kh();
        }
        x = x.return;
      }
      if (gi = c, yi = c = Ra(c.current, null), Hi = Zi = f, Ci = 0, ku = null, Wh = Bf = Pl = 0, vr = Gu = null, Zs !== null) {
        for (f = 0; f < Zs.length; f++) if (x = Zs[f], b = x.interleaved, b !== null) {
          x.interleaved = null;
          var P = b.next, D = x.pending;
          if (D !== null) {
            var X = D.next;
            D.next = P, b.next = X;
          }
          x.pending = b;
        }
        Zs = null;
      }
      return c;
    }
    function xv(c, f) {
      do {
        var x = yi;
        try {
          if (xh(), hs.current = El, Ro) {
            for (var b = In.memoizedState; b !== null; ) {
              var P = b.queue;
              P !== null && (P.pending = null), b = b.next;
            }
            Ro = !1;
          }
          if (Ka = 0, Jn = Yi = In = null, Dr = !1, Ja = 0, Gh.current = null, x === null || x.return === null) {
            Ci = 1, ku = f, yi = null;
            break;
          }
          e: {
            var D = c, X = x.return, ae = x, Ce = f;
            if (f = Hi, ae.flags |= 32768, Ce !== null && typeof Ce == "object" && typeof Ce.then == "function") {
              var et = Ce, bt = ae, en = bt.tag;
              if (!(bt.mode & 1) && (en === 0 || en === 11 || en === 15)) {
                var Bt = bt.alternate;
                Bt ? (bt.updateQueue = Bt.updateQueue, bt.memoizedState = Bt.memoizedState, bt.lanes = Bt.lanes) : (bt.updateQueue = null, bt.memoizedState = null);
              }
              var Nn = bf(X);
              if (Nn !== null) {
                Nn.flags &= -257, Oh(Nn, X, ae, D, f), Nn.mode & 1 && Ef(D, et, f), f = Nn, Ce = et;
                var Nt = f.updateQueue;
                if (Nt === null) {
                  var ki = /* @__PURE__ */ new Set();
                  ki.add(Ce), f.updateQueue = ki;
                } else Nt.add(Ce);
                break e;
              } else {
                if (!(f & 1)) {
                  Ef(D, et, f), jf();
                  break e;
                }
                Ce = Error(l(426));
              }
            } else if (Wn && ae.mode & 1) {
              var _r = bf(X);
              if (_r !== null) {
                !(_r.flags & 65536) && (_r.flags |= 256), Oh(_r, X, ae, D, f), vl(Ce);
                break e;
              }
            }
            D = Ce, Ci !== 4 && (Ci = 2), Gu === null ? Gu = [D] : Gu.push(D), Ce = Ou(Ce, ae), ae = X;
            do {
              switch (ae.tag) {
                case 3:
                  ae.flags |= 65536, f &= -f, ae.lanes |= f;
                  var Se = Sf(ae, Ce, f);
                  Sh(ae, Se);
                  break e;
                case 1:
                  D = Ce;
                  var fe = ae.type, be = ae.stateNode;
                  if (!(ae.flags & 128) && (typeof fe.getDerivedStateFromError == "function" || be !== null && typeof be.componentDidCatch == "function" && (so === null || !so.has(be)))) {
                    ae.flags |= 65536, f &= -f, ae.lanes |= f;
                    var ut = Mf(ae, D, f);
                    Sh(ae, ut);
                    break e;
                  }
              }
              ae = ae.return;
            } while (ae !== null);
          }
          Ki(x);
        } catch (Pt) {
          f = Pt, yi === x && x !== null && (yi = x = x.return);
          continue;
        }
        break;
      } while (!0);
    }
    function Jh() {
      var c = zf.current;
      return zf.current = El, c === null ? El : c;
    }
    function jf() {
      (Ci === 0 || Ci === 3 || Ci === 2) && (Ci = 4), gi === null || !(Pl & 268435455) && !(Bf & 268435455) || Aa(gi, Hi);
    }
    function yr(c, f) {
      var x = un;
      un |= 2;
      var b = Jh();
      gi === c && Hi === f || ta(c, f);
      do
        try {
          Wu();
          break;
        } catch (P) {
          xv(c, P);
        }
      while (!0);
      if (xh(), un = x, zf.current = b, yi !== null) throw Error(l(261));
      return gi = null, Hi = 0, Ci;
    }
    function Wu() {
      for (; yi !== null; ) _v(yi);
    }
    function ax() {
      for (; yi !== null && !Y0(); ) _v(yi);
    }
    function _v(c) {
      var f = Il(c.alternate, c, Zi);
      c.memoizedProps = c.pendingProps, f === null ? Ki(c) : yi = f, Gh.current = null;
    }
    function Ki(c) {
      var f = c;
      do {
        var x = f.alternate;
        if (c = f.return, f.flags & 32768) {
          if (x = tx(x, f), x !== null) {
            x.flags &= 32767, yi = x;
            return;
          }
          if (c !== null) c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
          else {
            Ci = 6, yi = null;
            return;
          }
        } else if (x = Iu(x, f, Zi), x !== null) {
          yi = x;
          return;
        }
        if (f = f.sibling, f !== null) {
          yi = f;
          return;
        }
        yi = f = c;
      } while (f !== null);
      Ci === 0 && (Ci = 5);
    }
    function jn(c, f) {
      var x = An, b = mn.transition;
      try {
        mn.transition = null, An = 1, na(c, f, x);
      } finally {
        mn.transition = b, An = x;
      }
      return null;
    }
    function na(c, f, x) {
      do
        Ji();
      while (wa !== null);
      if (un & 6) throw Error(l(327));
      var b = c.finishedWork, P = c.finishedLanes;
      if (b === null) return null;
      if (c.finishedWork = null, c.finishedLanes = 0, b === c.current) throw Error(l(177));
      c.callbackNode = null, c.callbackPriority = 0;
      var D = b.lanes | b.childLanes;
      if (j0(c, D), c === gi && (yi = gi = null, Hi = 0), !(b.subtreeFlags & 2064) && !(b.flags & 2064) || kf || (kf = !0, Fl(vh, function() {
        return Ji(), null;
      })), D = (b.flags & 15990) !== 0, b.subtreeFlags & 15990 || D) {
        D = mn.transition, mn.transition = null;
        var X = An;
        An = 1;
        var ae = un;
        un |= 4, Gh.current = null, hv(c, b), ix(c, b), re(c.containerInfo), c.current = b, rx(b), q0(), un = ae, An = X, mn.transition = D;
      } else c.current = b;
      if (kf && (kf = !1, wa = c, Gf = P), D = c.pendingLanes, D === 0 && (so = null), J0(b.stateNode), ur(c, Vi()), f !== null) for (x = c.onRecoverableError, b = 0; b < f.length; b++) x(f[b]);
      if (Hf) throw Hf = !1, c = jh, jh = null, c;
      return Gf & 1 && c.tag !== 0 && Ji(), D = c.pendingLanes, D & 1 ? c === Yh ? Dl++ : (Dl = 0, Yh = c) : Dl = 0, qs(), null;
    }
    function Ji() {
      if (wa !== null) {
        var c = Ym(Gf), f = mn.transition, x = An;
        try {
          if (mn.transition = null, An = 16 > c ? 16 : c, wa === null) var b = !1;
          else {
            if (c = wa, wa = null, Gf = 0, un & 6) throw Error(l(331));
            var P = un;
            for (un |= 4, gt = c.current; gt !== null; ) {
              var D = gt, X = D.child;
              if (gt.flags & 16) {
                var ae = D.deletions;
                if (ae !== null) {
                  for (var Ce = 0; Ce < ae.length; Ce++) {
                    var et = ae[Ce];
                    for (gt = et; gt !== null; ) {
                      var bt = gt;
                      switch (bt.tag) {
                        case 0:
                        case 11:
                        case 15:
                          ro(8, bt, D);
                      }
                      var en = bt.child;
                      if (en !== null) en.return = bt, gt = en;
                      else for (; gt !== null; ) {
                        bt = gt;
                        var Bt = bt.sibling, Nn = bt.return;
                        if (Cl(bt), bt === et) {
                          gt = null;
                          break;
                        }
                        if (Bt !== null) {
                          Bt.return = Nn, gt = Bt;
                          break;
                        }
                        gt = Nn;
                      }
                    }
                  }
                  var Nt = D.alternate;
                  if (Nt !== null) {
                    var ki = Nt.child;
                    if (ki !== null) {
                      Nt.child = null;
                      do {
                        var _r = ki.sibling;
                        ki.sibling = null, ki = _r;
                      } while (ki !== null);
                    }
                  }
                  gt = D;
                }
              }
              if (D.subtreeFlags & 2064 && X !== null) X.return = D, gt = X;
              else e: for (; gt !== null; ) {
                if (D = gt, D.flags & 2048) switch (D.tag) {
                  case 0:
                  case 11:
                  case 15:
                    ro(9, D, D.return);
                }
                var Se = D.sibling;
                if (Se !== null) {
                  Se.return = D.return, gt = Se;
                  break e;
                }
                gt = D.return;
              }
            }
            var fe = c.current;
            for (gt = fe; gt !== null; ) {
              X = gt;
              var be = X.child;
              if (X.subtreeFlags & 2064 && be !== null) be.return = X, gt = be;
              else e: for (X = fe; gt !== null; ) {
                if (ae = gt, ae.flags & 2048) try {
                  switch (ae.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ur(9, ae);
                  }
                } catch (Pt) {
                  _i(ae, ae.return, Pt);
                }
                if (ae === X) {
                  gt = null;
                  break e;
                }
                var ut = ae.sibling;
                if (ut !== null) {
                  ut.return = ae.return, gt = ut;
                  break e;
                }
                gt = ae.return;
              }
            }
            if (un = P, qs(), Xs && typeof Xs.onPostCommitFiberRoot == "function") try {
              Xs.onPostCommitFiberRoot(Qc, c);
            } catch {
            }
            b = !0;
          }
          return b;
        } finally {
          An = x, mn.transition = f;
        }
      }
      return !1;
    }
    function Sv(c, f, x) {
      f = Ou(x, f), f = Sf(c, f, 1), qa(c, f), f = gr(), c = Ul(c, 1), c !== null && (wu(c, 1, f), ur(c, f));
    }
    function _i(c, f, x) {
      if (c.tag === 3) Sv(c, c, x);
      else for (; f !== null; ) {
        if (f.tag === 3) {
          Sv(f, c, x);
          break;
        } else if (f.tag === 1) {
          var b = f.stateNode;
          if (typeof f.type.getDerivedStateFromError == "function" || typeof b.componentDidCatch == "function" && (so === null || !so.has(b))) {
            c = Ou(x, c), c = Mf(f, c, 1), qa(f, c), c = gr(), f = Ul(f, 1), f !== null && (wu(f, 1, c), ur(f, c));
            break;
          }
        }
        f = f.return;
      }
    }
    function Xu(c, f, x) {
      var b = c.pingCache;
      b !== null && b.delete(f), f = gr(), c.pingedLanes |= c.suspendedLanes & x, gi === c && (Hi & x) === x && (Ci === 4 || Ci === 3 && (Hi & 130023424) === Hi && 500 > Vi() - Vf ? ta(c, 0) : Wh |= x), ur(c, f);
    }
    function Ol(c, f) {
      f === 0 && (c.mode & 1 ? (f = Cr, Cr <<= 1, !(Cr & 130023424) && (Cr = 4194304)) : f = 1);
      var x = gr();
      c = Ul(c, f), c !== null && (wu(c, f, x), ur(c, x));
    }
    function ju(c) {
      var f = c.memoizedState, x = 0;
      f !== null && (x = f.retryLane), Ol(c, x);
    }
    function Yu(c, f) {
      var x = 0;
      switch (c.tag) {
        case 13:
          var b = c.stateNode, P = c.memoizedState;
          P !== null && (x = P.retryLane);
          break;
        case 19:
          b = c.stateNode;
          break;
        default:
          throw Error(l(314));
      }
      b !== null && b.delete(f), Ol(c, x);
    }
    var Il;
    Il = function(c, f, x) {
      if (c !== null) if (c.memoizedProps !== f.pendingProps || ti.current) Zr = !0;
      else {
        if (!(c.lanes & x) && !(f.flags & 128)) return Zr = !1, Vb(c, f, x);
        Zr = !!(c.flags & 131072);
      }
      else Zr = !1, Wn && f.flags & 1048576 && pl(f, af, f.index);
      switch (f.lanes = 0, f.tag) {
        case 2:
          var b = f.type;
          c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), c = f.pendingProps;
          var P = ls(f, on.current);
          fl(f, x), P = Sl(null, f, b, c, P, x);
          var D = hf();
          return f.flags |= 1, typeof P == "object" && P !== null && typeof P.render == "function" && P.$$typeof === void 0 ? (f.tag = 1, f.memoizedState = null, f.updateQueue = null, Bi(b) ? (D = !0, Ti(f)) : D = !1, f.memoizedState = P.state !== null && P.state !== void 0 ? P.state : null, _h(f), P.updater = rf, f.stateNode = P, P._reactInternals = f, Eh(f, b, c, x), f = wl(null, f, b, !0, D, x)) : (f.tag = 0, Wn && D && of(f), mr(null, f, P, x), f = f.child), f;
        case 16:
          b = f.elementType;
          e: {
            switch (c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), c = f.pendingProps, P = b._init, b = P(b._payload), f.type = b, P = f.tag = Mv(b), c = Rs(b, c), P) {
              case 0:
                f = Cf(null, f, b, c, x);
                break e;
              case 1:
                f = cv(
                  null,
                  f,
                  b,
                  c,
                  x
                );
                break e;
              case 11:
                f = ov(null, f, b, c, x);
                break e;
              case 14:
                f = lv(null, f, b, Rs(b.type, c), x);
                break e;
            }
            throw Error(l(306, b, ""));
          }
          return f;
        case 0:
          return b = f.type, P = f.pendingProps, P = f.elementType === b ? P : Rs(b, P), Cf(c, f, b, P, x);
        case 1:
          return b = f.type, P = f.pendingProps, P = f.elementType === b ? P : Rs(b, P), cv(c, f, b, P, x);
        case 3:
          e: {
            if (fv(f), c === null) throw Error(l(387));
            b = f.pendingProps, D = f.memoizedState, P = D.element, Jm(c, f), nf(f, b, null, x);
            var X = f.memoizedState;
            if (b = X.element, Be && D.isDehydrated) if (D = {
              element: b,
              isDehydrated: !1,
              cache: X.cache,
              transitions: X.transitions
            }, f.updateQueue.baseState = D, f.memoizedState = D, f.flags & 256) {
              P = Error(l(423)), f = Fh(c, f, b, x, P);
              break e;
            } else if (b !== P) {
              P = Error(l(424)), f = Fh(c, f, b, x, P);
              break e;
            } else for (Be && (Lr = ke(f.stateNode.containerInfo), Pr = f, Wn = !0, fs = null, ml = !1), x = ff(f, null, b, x), f.child = x; x; ) x.flags = x.flags & -3 | 4096, x = x.sibling;
            else {
              if (Za(), b === P) {
                f = $s(c, f, x);
                break e;
              }
              mr(c, f, b, x);
            }
            f = f.child;
          }
          return f;
        case 5:
          return Ks(f), c === null && Lu(f), b = f.type, P = f.pendingProps, D = c !== null ? c.memoizedProps : null, X = P.children, qe(b, P) ? X = null : D !== null && qe(b, D) && (f.flags |= 32), Rf(c, f), mr(c, f, X, x), f.child;
        case 6:
          return c === null && Lu(f), null;
        case 13:
          return no(c, f, x);
        case 4:
          return Nu(f, f.stateNode.containerInfo), b = f.pendingProps, c === null ? f.child = yl(f, null, b, x) : mr(c, f, b, x), f.child;
        case 11:
          return b = f.type, P = f.pendingProps, P = f.elementType === b ? P : Rs(b, P), ov(c, f, b, P, x);
        case 7:
          return mr(c, f, f.pendingProps, x), f.child;
        case 8:
          return mr(c, f, f.pendingProps.children, x), f.child;
        case 12:
          return mr(c, f, f.pendingProps.children, x), f.child;
        case 10:
          e: {
            if (b = f.type._context, P = f.pendingProps, D = f.memoizedProps, X = P.value, Km(f, b, X), D !== null) if (js(D.value, X)) {
              if (D.children === P.children && !ti.current) {
                f = $s(c, f, x);
                break e;
              }
            } else for (D = f.child, D !== null && (D.return = f); D !== null; ) {
              var ae = D.dependencies;
              if (ae !== null) {
                X = D.child;
                for (var Ce = ae.firstContext; Ce !== null; ) {
                  if (Ce.context === b) {
                    if (D.tag === 1) {
                      Ce = ga(-1, x & -x), Ce.tag = 2;
                      var et = D.updateQueue;
                      if (et !== null) {
                        et = et.shared;
                        var bt = et.pending;
                        bt === null ? Ce.next = Ce : (Ce.next = bt.next, bt.next = Ce), et.pending = Ce;
                      }
                    }
                    D.lanes |= x, Ce = D.alternate, Ce !== null && (Ce.lanes |= x), Pu(D.return, x, f), ae.lanes |= x;
                    break;
                  }
                  Ce = Ce.next;
                }
              } else if (D.tag === 10) X = D.type === f.type ? null : D.child;
              else if (D.tag === 18) {
                if (X = D.return, X === null) throw Error(l(341));
                X.lanes |= x, ae = X.alternate, ae !== null && (ae.lanes |= x), Pu(X, x, f), X = D.sibling;
              } else X = D.child;
              if (X !== null) X.return = D;
              else for (X = D; X !== null; ) {
                if (X === f) {
                  X = null;
                  break;
                }
                if (D = X.sibling, D !== null) {
                  D.return = X.return, X = D;
                  break;
                }
                X = X.return;
              }
              D = X;
            }
            mr(c, f, P.children, x), f = f.child;
          }
          return f;
        case 9:
          return P = f.type, b = f.pendingProps.children, fl(f, x), P = dr(P), b = b(P), f.flags |= 1, mr(c, f, b, x), f.child;
        case 14:
          return b = f.type, P = Rs(b, f.pendingProps), P = Rs(b.type, P), lv(c, f, b, P, x);
        case 15:
          return Af(c, f, f.type, f.pendingProps, x);
        case 17:
          return b = f.type, P = f.pendingProps, P = f.elementType === b ? P : Rs(b, P), c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), f.tag = 1, Bi(b) ? (c = !0, Ti(f)) : c = !1, fl(f, x), tv(f, b, P), Eh(f, b, P, x), wl(null, f, b, !0, c, x);
        case 19:
          return Fu(c, f, x);
        case 22:
          return uv(c, f, x);
      }
      throw Error(l(156, f.tag));
    };
    function Fl(c, f) {
      return ph(c, f);
    }
    function Oo(c, f, x, b) {
      this.tag = c, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = b, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function xr(c, f, x, b) {
      return new Oo(c, f, x, b);
    }
    function Yf(c) {
      return c = c.prototype, !(!c || !c.isReactComponent);
    }
    function Mv(c) {
      if (typeof c == "function") return Yf(c) ? 1 : 0;
      if (c != null) {
        if (c = c.$$typeof, c === w) return 11;
        if (c === C) return 14;
      }
      return 2;
    }
    function Ra(c, f) {
      var x = c.alternate;
      return x === null ? (x = xr(c.tag, f, c.key, c.mode), x.elementType = c.elementType, x.type = c.type, x.stateNode = c.stateNode, x.alternate = c, c.alternate = x) : (x.pendingProps = f, x.type = c.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = c.flags & 14680064, x.childLanes = c.childLanes, x.lanes = c.lanes, x.child = c.child, x.memoizedProps = c.memoizedProps, x.memoizedState = c.memoizedState, x.updateQueue = c.updateQueue, f = c.dependencies, x.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }, x.sibling = c.sibling, x.index = c.index, x.ref = c.ref, x;
    }
    function zl(c, f, x, b, P, D) {
      var X = 2;
      if (b = c, typeof c == "function") Yf(c) && (X = 1);
      else if (typeof c == "string") X = 5;
      else e: switch (c) {
        case m:
          return Io(x.children, P, D, f);
        case g:
          X = 8, P |= 8;
          break;
        case y:
          return c = xr(12, x, f, P | 2), c.elementType = y, c.lanes = D, c;
        case T:
          return c = xr(13, x, f, P), c.elementType = T, c.lanes = D, c;
        case M:
          return c = xr(19, x, f, P), c.elementType = M, c.lanes = D, c;
        case N:
          return qf(x, P, D, f);
        default:
          if (typeof c == "object" && c !== null) switch (c.$$typeof) {
            case _:
              X = 10;
              break e;
            case E:
              X = 9;
              break e;
            case w:
              X = 11;
              break e;
            case C:
              X = 14;
              break e;
            case A:
              X = 16, b = null;
              break e;
          }
          throw Error(l(130, c == null ? c : typeof c, ""));
      }
      return f = xr(X, x, f, P), f.elementType = c, f.type = b, f.lanes = D, f;
    }
    function Io(c, f, x, b) {
      return c = xr(7, c, b, f), c.lanes = x, c;
    }
    function qf(c, f, x, b) {
      return c = xr(22, c, b, f), c.elementType = N, c.lanes = x, c.stateNode = {}, c;
    }
    function Jr(c, f, x) {
      return c = xr(6, c, null, f), c.lanes = x, c;
    }
    function Bl(c, f, x) {
      return f = xr(4, c.children !== null ? c.children : [], c.key, f), f.lanes = x, f.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, f;
    }
    function qu(c, f, x, b, P) {
      this.tag = f, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ut, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = hh(0), this.expirationTimes = hh(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = hh(0), this.identifierPrefix = b, this.onRecoverableError = P, Be && (this.mutableSourceEagerHydrationData = null);
    }
    function Zu(c, f, x, b, P, D, X, ae, Ce) {
      return c = new qu(c, f, x, ae, Ce), f === 1 ? (f = 1, D === !0 && (f |= 8)) : f = 0, D = xr(3, null, null, f), c.current = D, D.stateNode = c, D.memoizedState = { element: b, isDehydrated: x, cache: null, transitions: null }, _h(D), c;
    }
    function Fo(c) {
      if (!c) return Ar;
      c = c._reactInternals;
      e: {
        if (U(c) !== c || c.tag !== 1) throw Error(l(170));
        var f = c;
        do {
          switch (f.tag) {
            case 3:
              f = f.stateNode.context;
              break e;
            case 1:
              if (Bi(f.type)) {
                f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          f = f.return;
        } while (f !== null);
        throw Error(l(171));
      }
      if (c.tag === 1) {
        var x = c.type;
        if (Bi(x)) return Eo(c, x, f);
      }
      return f;
    }
    function Zf(c) {
      var f = c._reactInternals;
      if (f === void 0)
        throw typeof c.render == "function" ? Error(l(188)) : (c = Object.keys(c).join(","), Error(l(268, c)));
      return c = le(f), c === null ? null : c.stateNode;
    }
    function Ku(c, f) {
      if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
        var x = c.retryLane;
        c.retryLane = x !== 0 && x < f ? x : f;
      }
    }
    function Vl(c, f) {
      Ku(c, f), (c = c.alternate) && Ku(c, f);
    }
    function Ev(c) {
      return c = le(c), c === null ? null : c.stateNode;
    }
    function bv() {
      return null;
    }
    return t.attemptContinuousHydration = function(c) {
      if (c.tag === 13) {
        var f = gr();
        xi(c, 134217728, f), Vl(c, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(c) {
      if (c.tag === 13) {
        var f = gr(), x = Pi(c);
        xi(c, x, f), Vl(c, x);
      }
    }, t.attemptSynchronousHydration = function(c) {
      switch (c.tag) {
        case 3:
          var f = c.stateNode;
          if (f.current.memoizedState.isDehydrated) {
            var x = Xa(f.pendingLanes);
            x !== 0 && (ja(f, x | 1), ur(f, Vi()), !(un & 6) && (Ll(), qs()));
          }
          break;
        case 13:
          var b = gr();
          yv(function() {
            return xi(c, 1, b);
          }), Vl(c, 1);
      }
    }, t.batchedUpdates = function(c, f) {
      var x = un;
      un |= 1;
      try {
        return c(f);
      } finally {
        un = x, un === 0 && (Ll(), $c && qs());
      }
    }, t.createComponentSelector = function(c) {
      return { $$typeof: ba, value: c };
    }, t.createContainer = function(c, f, x, b, P, D, X) {
      return Zu(c, f, !1, null, x, b, P, D, X);
    }, t.createHasPseudoClassSelector = function(c) {
      return { $$typeof: Hu, value: c };
    }, t.createHydrationContainer = function(c, f, x, b, P, D, X, ae, Ce) {
      return c = Zu(x, b, !0, c, P, D, X, ae, Ce), c.context = Fo(null), x = c.current, b = gr(), P = Pi(x), D = ga(b, P), D.callback = f ?? null, qa(x, D), c.current.lanes = P, wu(c, P, b), ur(c, b), c;
    }, t.createPortal = function(c, f, x) {
      var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: h, key: b == null ? null : "" + b, children: c, containerInfo: f, implementation: x };
    }, t.createRoleSelector = function(c) {
      return { $$typeof: If, value: c };
    }, t.createTestNameSelector = function(c) {
      return { $$typeof: Ff, value: c };
    }, t.createTextSelector = function(c) {
      return { $$typeof: Ta, value: c };
    }, t.deferredUpdates = function(c) {
      var f = An, x = mn.transition;
      try {
        return mn.transition = null, An = 16, c();
      } finally {
        An = f, mn.transition = x;
      }
    }, t.discreteUpdates = function(c, f, x, b, P) {
      var D = An, X = mn.transition;
      try {
        return mn.transition = null, An = 1, c(f, x, b, P);
      } finally {
        An = D, mn.transition = X, un === 0 && Ll();
      }
    }, t.findAllNodes = kh, t.findBoundingRects = function(c, f) {
      if (!B) throw Error(l(363));
      f = kh(c, f), c = [];
      for (var x = 0; x < f.length; x++) c.push(Fe(f[x]));
      for (f = c.length - 1; 0 < f; f--) {
        x = c[f];
        for (var b = x.x, P = b + x.width, D = x.y, X = D + x.height, ae = f - 1; 0 <= ae; ae--) if (f !== ae) {
          var Ce = c[ae], et = Ce.x, bt = et + Ce.width, en = Ce.y, Bt = en + Ce.height;
          if (b >= et && D >= en && P <= bt && X <= Bt) {
            c.splice(f, 1);
            break;
          } else if (b !== et || x.width !== Ce.width || Bt < D || en > X) {
            if (!(D !== en || x.height !== Ce.height || bt < b || et > P)) {
              et > b && (Ce.width += et - b, Ce.x = b), bt < P && (Ce.width = P - et), c.splice(f, 1);
              break;
            }
          } else {
            en > D && (Ce.height += en - D, Ce.y = D), Bt < X && (Ce.height = X - en), c.splice(f, 1);
            break;
          }
        }
      }
      return c;
    }, t.findHostInstance = Zf, t.findHostInstanceWithNoPortals = function(c) {
      return c = q(c), c = c !== null ? K(c) : null, c === null ? null : c.stateNode;
    }, t.findHostInstanceWithWarning = function(c) {
      return Zf(c);
    }, t.flushControlled = function(c) {
      var f = un;
      un |= 1;
      var x = mn.transition, b = An;
      try {
        mn.transition = null, An = 1, c();
      } finally {
        An = b, mn.transition = x, un = f, un === 0 && (Ll(), qs());
      }
    }, t.flushPassiveEffects = Ji, t.flushSync = yv, t.focusWithin = function(c, f) {
      if (!B) throw Error(l(363));
      for (c = yt(c), f = vv(c, f), f = Array.from(f), c = 0; c < f.length; ) {
        var x = f[c++];
        if (!Ie(x)) {
          if (x.tag === 5 && it(x.stateNode)) return !0;
          for (x = x.child; x !== null; ) f.push(x), x = x.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return An;
    }, t.getFindAllNodesFailureDescription = function(c, f) {
      if (!B) throw Error(l(363));
      var x = 0, b = [];
      c = [yt(c), 0];
      for (var P = 0; P < c.length; ) {
        var D = c[P++], X = c[P++], ae = f[X];
        if ((D.tag !== 5 || !Ie(D)) && (vs(D, ae) && (b.push(Kr(ae)), X++, X > x && (x = X)), X < f.length)) for (D = D.child; D !== null; ) c.push(D, X), D = D.sibling;
      }
      if (x < f.length) {
        for (c = []; x < f.length; x++) c.push(Kr(f[x]));
        return `findAllNodes was able to match part of the selector:
  ` + (b.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(c) {
      if (c = c.current, !c.child) return null;
      switch (c.child.tag) {
        case 5:
          return ie(c.child.stateNode);
        default:
          return c.child.stateNode;
      }
    }, t.injectIntoDevTools = function(c) {
      if (c = { bundleType: c.bundleType, version: c.version, rendererPackageName: c.rendererPackageName, rendererConfig: c.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: u.ReactCurrentDispatcher, findHostInstanceByFiber: Ev, findFiberByHostInstance: c.findFiberByHostInstance || bv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") c = !1;
      else {
        var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (f.isDisabled || !f.supportsFiber) c = !0;
        else {
          try {
            Qc = f.inject(c), Xs = f;
          } catch {
          }
          c = !!f.checkDCE;
        }
      }
      return c;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(c, f, x, b) {
      if (!B) throw Error(l(363));
      c = kh(c, f);
      var P = mt(c, x, b).disconnect;
      return { disconnect: function() {
        P();
      } };
    }, t.registerMutableSourceForHydration = function(c, f) {
      var x = f._getVersion;
      x = x(f._source), c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [f, x] : c.mutableSourceEagerHydrationData.push(f, x);
    }, t.runWithPriority = function(c, f) {
      var x = An;
      try {
        return An = c, f();
      } finally {
        An = x;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(c, f, x, b) {
      var P = f.current, D = gr(), X = Pi(P);
      return x = Fo(x), f.context === null ? f.context = x : f.pendingContext = x, f = ga(D, X), f.payload = { element: c }, b = b === void 0 ? null : b, b !== null && (f.callback = b), qa(P, f), c = xi(P, X, D), c !== null && tf(c, P, X), X;
    }, t;
  }), XS;
}
var jS = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pR;
function T4() {
  return pR || (pR = 1, process.env.NODE_ENV !== "production" && (jS.exports = function(e) {
    var t = {}, n = kc, r = Qy, o = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = !1;
    function u(s) {
      l = s;
    }
    function d(s) {
      if (!l) {
        for (var a = arguments.length, p = new Array(a > 1 ? a - 1 : 0), v = 1; v < a; v++)
          p[v - 1] = arguments[v];
        m("warn", s, p);
      }
    }
    function h(s) {
      if (!l) {
        for (var a = arguments.length, p = new Array(a > 1 ? a - 1 : 0), v = 1; v < a; v++)
          p[v - 1] = arguments[v];
        m("error", s, p);
      }
    }
    function m(s, a, p) {
      {
        var v = o.ReactDebugCurrentFrame, S = v.getStackAddendum();
        S !== "" && (a += "%s", p = p.concat([S]));
        var R = p.map(function(L) {
          return String(L);
        });
        R.unshift("Warning: " + a), Function.prototype.apply.call(console[s], console, R);
      }
    }
    var g = Object.assign;
    function y(s) {
      return s._reactInternals;
    }
    function _(s, a) {
      s._reactInternals = a;
    }
    var E = !1, w = !1, T = !1, M = !1, C = !0, A = !0, N = !0, z = 0, I = 1, V = 2, W = 3, U = 4, O = 5, q = 6, le = 7, ye = 8, K = 9, oe = 10, ie = 11, Ee = 12, Q = 13, se = 14, re = 15, ue = 16, Le = 17, pe = 18, Ae = 19, qe = 21, je = 22, $e = 23, Rt = 24, Ut = 25, ot = Symbol.for("react.element"), pt = Symbol.for("react.portal"), J = Symbol.for("react.fragment"), Be = Symbol.for("react.strict_mode"), Pe = Symbol.for("react.profiler"), He = Symbol.for("react.provider"), Re = Symbol.for("react.context"), _t = Symbol.for("react.forward_ref"), rt = Symbol.for("react.suspense"), G = Symbol.for("react.suspense_list"), B = Symbol.for("react.memo"), ce = Symbol.for("react.lazy"), Fe = Symbol.for("react.scope"), ze = Symbol.for("react.debug_trace_mode"), Ie = Symbol.for("react.offscreen"), Mt = Symbol.for("react.legacy_hidden"), it = Symbol.for("react.cache"), mt = Symbol.for("react.tracing_marker"), Dt = Symbol.iterator, Ht = "@@iterator";
    function de(s) {
      if (s === null || typeof s != "object")
        return null;
      var a = Dt && s[Dt] || s[Ht];
      return typeof a == "function" ? a : null;
    }
    function nt(s, a, p) {
      var v = s.displayName;
      if (v)
        return v;
      var S = a.displayName || a.name || "";
      return S !== "" ? p + "(" + S + ")" : p;
    }
    function lt(s) {
      return s.displayName || "Context";
    }
    function Xe(s) {
      if (s == null)
        return null;
      if (typeof s.tag == "number" && h("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof s == "function")
        return s.displayName || s.name || null;
      if (typeof s == "string")
        return s;
      switch (s) {
        case J:
          return "Fragment";
        case pt:
          return "Portal";
        case Pe:
          return "Profiler";
        case Be:
          return "StrictMode";
        case rt:
          return "Suspense";
        case G:
          return "SuspenseList";
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case Re:
            var a = s;
            return lt(a) + ".Consumer";
          case He:
            var p = s;
            return lt(p._context) + ".Provider";
          case _t:
            return nt(s, s.render, "ForwardRef");
          case B:
            var v = s.displayName || null;
            return v !== null ? v : Xe(s.type) || "Memo";
          case ce: {
            var S = s, R = S._payload, L = S._init;
            try {
              return Xe(L(R));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function dt(s, a, p) {
      var v = a.displayName || a.name || "";
      return s.displayName || (v !== "" ? p + "(" + v + ")" : p);
    }
    function at(s) {
      return s.displayName || "Context";
    }
    function Y(s) {
      var a = s.tag, p = s.type;
      switch (a) {
        case Rt:
          return "Cache";
        case K:
          var v = p;
          return at(v) + ".Consumer";
        case oe:
          var S = p;
          return at(S._context) + ".Provider";
        case pe:
          return "DehydratedFragment";
        case ie:
          return dt(p, p.render, "ForwardRef");
        case le:
          return "Fragment";
        case O:
          return p;
        case U:
          return "Portal";
        case W:
          return "Root";
        case q:
          return "Text";
        case ue:
          return Xe(p);
        case ye:
          return p === Be ? "StrictMode" : "Mode";
        case je:
          return "Offscreen";
        case Ee:
          return "Profiler";
        case qe:
          return "Scope";
        case Q:
          return "Suspense";
        case Ae:
          return "SuspenseList";
        case Ut:
          return "TracingMarker";
        case I:
        case z:
        case Le:
        case V:
        case se:
        case re:
          if (typeof p == "function")
            return p.displayName || p.name || null;
          if (typeof p == "string")
            return p;
          break;
      }
      return null;
    }
    var he = (
      /*                      */
      0
    ), Ze = (
      /*                */
      1
    ), Ve = (
      /*                    */
      2
    ), Te = (
      /*                       */
      4
    ), ee = (
      /*           */
      Ve | Te
    ), Ke = (
      /*                */
      16
    ), st = (
      /*                 */
      32
    ), zt = (
      /*                     */
      64
    ), Ye = (
      /*                   */
      128
    ), qt = (
      /*            */
      256
    ), tn = (
      /*                          */
      512
    ), Sn = (
      /*                     */
      1024
    ), bn = (
      /*                      */
      2048
    ), Jt = (
      /*                    */
      4096
    ), di = (
      /*           */
      Jt | Te
    ), hi = (
      /*                   */
      8192
    ), va = (
      /*             */
      16384
    ), Mo = (
      /*               */
      32767
    ), ws = (
      /*                   */
      32768
    ), Zn = (
      /*                */
      65536
    ), $ = (
      /* */
      131072
    ), ke = (
      /*                       */
      1048576
    ), vt = (
      /*                    */
      2097152
    ), Ft = (
      /*                 */
      4194304
    ), xn = (
      /*                */
      8388608
    ), hn = (
      /*               */
      16777216
    ), k = (
      /*              */
      33554432
    ), ne = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Te | Sn | 0
    ), ge = Ve | Te | Ke | st | tn | Jt | hi, ve = Te | zt | tn | hi, me = bn | Ke, Qe = Ft | xn | vt, wt = o.ReactCurrentOwner;
    function Ct(s) {
      var a = s, p = s;
      if (s.alternate)
        for (; a.return; )
          a = a.return;
      else {
        var v = a;
        do
          a = v, (a.flags & (Ve | Jt)) !== he && (p = a.return), v = a.return;
        while (v);
      }
      return a.tag === W ? p : null;
    }
    function At(s) {
      return Ct(s) === s;
    }
    function Wt(s) {
      {
        var a = wt.current;
        if (a !== null && a.tag === I) {
          var p = a, v = p.stateNode;
          v._warnedAboutRefsInRender || h("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Y(p) || "A component"), v._warnedAboutRefsInRender = !0;
        }
      }
      var S = y(s);
      return S ? Ct(S) === S : !1;
    }
    function Xt(s) {
      if (Ct(s) !== s)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Zt(s) {
      var a = s.alternate;
      if (!a) {
        var p = Ct(s);
        if (p === null)
          throw new Error("Unable to find node on an unmounted component.");
        return p !== s ? null : s;
      }
      for (var v = s, S = a; ; ) {
        var R = v.return;
        if (R === null)
          break;
        var L = R.alternate;
        if (L === null) {
          var F = R.return;
          if (F !== null) {
            v = S = F;
            continue;
          }
          break;
        }
        if (R.child === L.child) {
          for (var H = R.child; H; ) {
            if (H === v)
              return Xt(R), s;
            if (H === S)
              return Xt(R), a;
            H = H.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (v.return !== S.return)
          v = R, S = L;
        else {
          for (var Z = !1, te = R.child; te; ) {
            if (te === v) {
              Z = !0, v = R, S = L;
              break;
            }
            if (te === S) {
              Z = !0, S = R, v = L;
              break;
            }
            te = te.sibling;
          }
          if (!Z) {
            for (te = L.child; te; ) {
              if (te === v) {
                Z = !0, v = L, S = R;
                break;
              }
              if (te === S) {
                Z = !0, S = L, v = R;
                break;
              }
              te = te.sibling;
            }
            if (!Z)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (v.alternate !== S)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (v.tag !== W)
        throw new Error("Unable to find node on an unmounted component.");
      return v.stateNode.current === v ? s : a;
    }
    function kn(s) {
      var a = Zt(s);
      return a !== null ? zi(a) : null;
    }
    function zi(s) {
      if (s.tag === O || s.tag === q)
        return s;
      for (var a = s.child; a !== null; ) {
        var p = zi(a);
        if (p !== null)
          return p;
        a = a.sibling;
      }
      return null;
    }
    function Gn(s) {
      var a = Zt(s);
      return a !== null ? bi(a) : null;
    }
    function bi(s) {
      if (s.tag === O || s.tag === q)
        return s;
      for (var a = s.child; a !== null; ) {
        if (a.tag !== U) {
          var p = bi(a);
          if (p !== null)
            return p;
        }
        a = a.sibling;
      }
      return null;
    }
    var jt = Array.isArray;
    function ht(s) {
      return jt(s);
    }
    var Ar = e.getPublicInstance, on = e.getRootHostContext, ti = e.getChildHostContext, Ws = e.prepareForCommit, ls = e.resetAfterCommit, Bi = e.createInstance, Kn = e.appendInitialChild, As = e.finalizeInitialChildren, Eo = e.prepareUpdate, Ti = e.shouldSetTextContent, bo = e.createTextInstance, Rr = e.scheduleTimeout, Zc = e.cancelTimeout, fh = e.noTimeout;
    e.now;
    var Kc = e.isPrimaryRenderer, Jc = e.warnsIfNotActing, Cr = e.supportsMutation, Xa = e.supportsPersistence, ar = e.supportsHydration, W0 = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var X0 = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var dh = e.getCurrentEventPriority, hh = e.detachDeletedInstance, wu = e.supportsMicrotasks, j0 = e.scheduleMicrotask, ja = e.supportsTestSelectors, An = e.findFiberRoot, Ym = e.getBoundingRect, ph = e.getTextContent, cl = e.isHiddenSubtree, Y0 = e.matchAccessibilityRole, q0 = e.setFocusIfFocusable, Vi = e.setupIntersectionObserver, mh = e.appendChild, Z0 = e.appendChildToContainer, vh = e.commitTextUpdate, K0 = e.commitMount, Qc = e.commitUpdate, Xs = e.insertBefore, J0 = e.insertInContainerBefore, Q0 = e.removeChild, js = e.removeChildFromContainer, Ys = e.resetTextContent, $c = e.hideInstance, gh = e.hideTextInstance, qm = e.unhideInstance, $0 = e.unhideTextInstance, qs = e.clearContainer, ex = e.cloneInstance, Au = e.createContainerChildSet, Zm = e.appendChildToContainerChildSet, Rs = e.finalizeContainerChildren, Ru = e.replaceContainerChildren;
    e.getOffscreenContainerType, e.getOffscreenContainerProps;
    var Cu = e.cloneHiddenInstance, To = e.cloneHiddenTextInstance, yh = e.canHydrateInstance, xh = e.canHydrateTextInstance, Km = e.canHydrateSuspenseInstance, ef = e.isSuspenseInstancePending, Pu = e.isSuspenseInstanceFallback, fl = e.registerSuspenseInstanceRetry, dr = e.getNextHydratableSibling, Zs = e.getFirstHydratableChild, Ya = e.getFirstHydratableChildWithinContainer, _h = e.getFirstHydratableChildWithinSuspenseInstance, Jm = e.hydrateInstance, ga = e.hydrateTextInstance, qa = e.hydrateSuspenseInstance, tf = e.getNextHydratableInstanceAfterSuspenseInstance, Sh = e.commitHydratedContainer, nf = e.commitHydratedSuspenseInstance, Qm = e.clearSuspenseBoundary, $m = e.clearSuspenseBoundaryFromContainer, Mh = e.shouldDeleteUnhydratedTailInstances, rf = e.didNotMatchHydratedContainerTextInstance, ev = e.didNotMatchHydratedTextInstance, tv = e.didNotHydrateInstanceWithinContainer, nv = e.didNotHydrateInstanceWithinSuspenseInstance, Eh = e.didNotHydrateInstance, dl = e.didNotFindHydratableInstanceWithinContainer, hl = e.didNotFindHydratableTextInstanceWithinContainer, sf = e.didNotFindHydratableSuspenseInstanceWithinContainer, af = e.didNotFindHydratableInstanceWithinSuspenseInstance, us = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, cs = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, wo = e.didNotFindHydratableInstance, ya = e.didNotFindHydratableTextInstance, xa = e.didNotFindHydratableSuspenseInstance, Ao = e.errorHydratingContainer, pl = 0, of, lf, Pr, Lr, Wn, ml, fs;
    function bh() {
    }
    bh.__reactDisabledLog = !0;
    function iv() {
      {
        if (pl === 0) {
          of = console.log, lf = console.info, Pr = console.warn, Lr = console.error, Wn = console.group, ml = console.groupCollapsed, fs = console.groupEnd;
          var s = {
            configurable: !0,
            enumerable: !0,
            value: bh,
            writable: !0
          };
          Object.defineProperties(console, {
            info: s,
            log: s,
            warn: s,
            error: s,
            group: s,
            groupCollapsed: s,
            groupEnd: s
          });
        }
        pl++;
      }
    }
    function Th() {
      {
        if (pl--, pl === 0) {
          var s = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: g({}, s, {
              value: of
            }),
            info: g({}, s, {
              value: lf
            }),
            warn: g({}, s, {
              value: Pr
            }),
            error: g({}, s, {
              value: Lr
            }),
            group: g({}, s, {
              value: Wn
            }),
            groupCollapsed: g({}, s, {
              value: ml
            }),
            groupEnd: g({}, s, {
              value: fs
            })
          });
        }
        pl < 0 && h("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Lu = o.ReactCurrentDispatcher, uf;
    function ds(s, a, p) {
      {
        if (uf === void 0)
          try {
            throw Error();
          } catch (S) {
            var v = S.stack.trim().match(/\n( *(at )?)/);
            uf = v && v[1] || "";
          }
        return `
` + uf + s;
      }
    }
    var Za = !1, vl;
    {
      var Du = typeof WeakMap == "function" ? WeakMap : Map;
      vl = new Du();
    }
    function gl(s, a) {
      if (!s || Za)
        return "";
      {
        var p = vl.get(s);
        if (p !== void 0)
          return p;
      }
      var v;
      Za = !0;
      var S = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var R;
      R = Lu.current, Lu.current = null, iv();
      try {
        if (a) {
          var L = function() {
            throw Error();
          };
          if (Object.defineProperty(L.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(L, []);
            } catch (We) {
              v = We;
            }
            Reflect.construct(s, [], L);
          } else {
            try {
              L.call();
            } catch (We) {
              v = We;
            }
            s.call(L.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (We) {
            v = We;
          }
          s();
        }
      } catch (We) {
        if (We && v && typeof We.stack == "string") {
          for (var F = We.stack.split(`
`), H = v.stack.split(`
`), Z = F.length - 1, te = H.length - 1; Z >= 1 && te >= 0 && F[Z] !== H[te]; )
            te--;
          for (; Z >= 1 && te >= 0; Z--, te--)
            if (F[Z] !== H[te]) {
              if (Z !== 1 || te !== 1)
                do
                  if (Z--, te--, te < 0 || F[Z] !== H[te]) {
                    var xe = `
` + F[Z].replace(" at new ", " at ");
                    return s.displayName && xe.includes("<anonymous>") && (xe = xe.replace("<anonymous>", s.displayName)), typeof s == "function" && vl.set(s, xe), xe;
                  }
                while (Z >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        Za = !1, Lu.current = R, Th(), Error.prepareStackTrace = S;
      }
      var we = s ? s.displayName || s.name : "", De = we ? ds(we) : "";
      return typeof s == "function" && vl.set(s, De), De;
    }
    function rv(s, a, p) {
      return gl(s, !0);
    }
    function cf(s, a, p) {
      return gl(s, !1);
    }
    function yl(s) {
      var a = s.prototype;
      return !!(a && a.isReactComponent);
    }
    function ff(s, a, p) {
      if (s == null)
        return "";
      if (typeof s == "function")
        return gl(s, yl(s));
      if (typeof s == "string")
        return ds(s);
      switch (s) {
        case rt:
          return ds("Suspense");
        case G:
          return ds("SuspenseList");
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case _t:
            return cf(s.render);
          case B:
            return ff(s.type, a, p);
          case ce: {
            var v = s, S = v._payload, R = v._init;
            try {
              return ff(R(S), a, p);
            } catch {
            }
          }
        }
      return "";
    }
    var xl = Object.prototype.hasOwnProperty, qr = {}, _l = o.ReactDebugCurrentFrame;
    function _a(s) {
      if (s) {
        var a = s._owner, p = ff(s.type, s._source, a ? a.type : null);
        _l.setExtraStackFrame(p);
      } else
        _l.setExtraStackFrame(null);
    }
    function pi(s, a, p, v, S) {
      {
        var R = Function.call.bind(xl);
        for (var L in s)
          if (R(s, L)) {
            var F = void 0;
            try {
              if (typeof s[L] != "function") {
                var H = Error((v || "React class") + ": " + p + " type `" + L + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[L] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw H.name = "Invariant Violation", H;
              }
              F = s[L](a, L, v, p, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Z) {
              F = Z;
            }
            F && !(F instanceof Error) && (_a(S), h("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", v || "React class", p, L, typeof F), _a(null)), F instanceof Error && !(F.message in qr) && (qr[F.message] = !0, _a(S), h("Failed %s type: %s", p, F.message), _a(null));
          }
      }
    }
    var Nu = [], Sa;
    Sa = [];
    var Ks = -1;
    function Js(s) {
      return {
        current: s
      };
    }
    function pn(s, a) {
      if (Ks < 0) {
        h("Unexpected pop.");
        return;
      }
      a !== Sa[Ks] && h("Unexpected Fiber popped."), s.current = Nu[Ks], Nu[Ks] = null, Sa[Ks] = null, Ks--;
    }
    function mi(s, a, p) {
      Ks++, Nu[Ks] = s.current, Sa[Ks] = p, s.current = a;
    }
    var Uu;
    Uu = {};
    var hr = {};
    Object.freeze(hr);
    var hs = Js(hr), ni = Js(!1), Ka = hr;
    function In(s, a, p) {
      return p && Dr(a) ? Ka : hs.current;
    }
    function Yi(s, a, p) {
      {
        var v = s.stateNode;
        v.__reactInternalMemoizedUnmaskedChildContext = a, v.__reactInternalMemoizedMaskedChildContext = p;
      }
    }
    function Jn(s, a) {
      {
        var p = s.type, v = p.contextTypes;
        if (!v)
          return hr;
        var S = s.stateNode;
        if (S && S.__reactInternalMemoizedUnmaskedChildContext === a)
          return S.__reactInternalMemoizedMaskedChildContext;
        var R = {};
        for (var L in v)
          R[L] = a[L];
        {
          var F = Y(s) || "Unknown";
          pi(v, R, "context", F);
        }
        return S && Yi(s, a, R), R;
      }
    }
    function Ro() {
      return ni.current;
    }
    function Dr(s) {
      {
        var a = s.childContextTypes;
        return a != null;
      }
    }
    function Ja(s) {
      pn(ni, s), pn(hs, s);
    }
    function wh(s) {
      pn(ni, s), pn(hs, s);
    }
    function qi(s, a, p) {
      {
        if (hs.current !== hr)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        mi(hs, a, s), mi(ni, p, s);
      }
    }
    function df(s, a, p) {
      {
        var v = s.stateNode, S = a.childContextTypes;
        if (typeof v.getChildContext != "function") {
          {
            var R = Y(s) || "Unknown";
            Uu[R] || (Uu[R] = !0, h("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          }
          return p;
        }
        var L = v.getChildContext();
        for (var F in L)
          if (!(F in S))
            throw new Error((Y(s) || "Unknown") + '.getChildContext(): key "' + F + '" is not defined in childContextTypes.');
        {
          var H = Y(s) || "Unknown";
          pi(S, L, "child context", H);
        }
        return g({}, p, L);
      }
    }
    function Sl(s) {
      {
        var a = s.stateNode, p = a && a.__reactInternalMemoizedMergedChildContext || hr;
        return Ka = hs.current, mi(hs, p, s), mi(ni, ni.current, s), !0;
      }
    }
    function hf(s, a, p) {
      {
        var v = s.stateNode;
        if (!v)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (p) {
          var S = df(s, a, Ka);
          v.__reactInternalMemoizedMergedChildContext = S, pn(ni, s), pn(hs, s), mi(hs, S, s), mi(ni, p, s);
        } else
          pn(ni, s), mi(ni, p, s);
      }
    }
    function Ma(s) {
      {
        if (!At(s) || s.tag !== I)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var a = s;
        do {
          switch (a.tag) {
            case W:
              return a.stateNode.context;
            case I: {
              var p = a.type;
              if (Dr(p))
                return a.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          a = a.return;
        } while (a !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var pr = 0, Qa = 1, Yt = (
      /*                         */
      0
    ), Rn = (
      /*                 */
      1
    ), Tn = (
      /*                    */
      2
    ), ii = (
      /*               */
      8
    ), Cs = (
      /*              */
      16
    ), Ah = Math.clz32 ? Math.clz32 : Rh, sv = Math.log, av = Math.LN2;
    function Rh(s) {
      var a = s >>> 0;
      return a === 0 ? 32 : 31 - (sv(a) / av | 0) | 0;
    }
    var Co = 31, Ge = (
      /*                        */
      0
    ), ri = (
      /*                          */
      0
    ), ln = (
      /*                        */
      1
    ), $a = (
      /*    */
      2
    ), ps = (
      /*            */
      4
    ), eo = (
      /*            */
      8
    ), Qs = (
      /*                    */
      16
    ), Ml = (
      /*                */
      32
    ), Po = (
      /*                       */
      4194240
    ), Lo = (
      /*                        */
      64
    ), pf = (
      /*                        */
      128
    ), mf = (
      /*                        */
      256
    ), Ch = (
      /*                        */
      512
    ), vf = (
      /*                        */
      1024
    ), Ph = (
      /*                        */
      2048
    ), Lh = (
      /*                        */
      4096
    ), gf = (
      /*                        */
      8192
    ), yf = (
      /*                        */
      16384
    ), xf = (
      /*                       */
      32768
    ), _f = (
      /*                       */
      65536
    ), El = (
      /*                       */
      131072
    ), Dh = (
      /*                       */
      262144
    ), Nh = (
      /*                       */
      524288
    ), Uh = (
      /*                       */
      1048576
    ), Ou = (
      /*                       */
      2097152
    ), bl = (
      /*                            */
      130023424
    ), Tl = (
      /*                             */
      4194304
    ), Sf = (
      /*                             */
      8388608
    ), Mf = (
      /*                             */
      16777216
    ), Ef = (
      /*                             */
      33554432
    ), bf = (
      /*                             */
      67108864
    ), Oh = Tl, Nr = (
      /*          */
      134217728
    ), Ih = (
      /*                                 */
      268435455
    ), Ea = (
      /*               */
      268435456
    ), Ps = (
      /*                       */
      536870912
    ), or = (
      /*                   */
      1073741824
    );
    function Tf(s) {
      {
        if (s & ln)
          return "Sync";
        if (s & $a)
          return "InputContinuousHydration";
        if (s & ps)
          return "InputContinuous";
        if (s & eo)
          return "DefaultHydration";
        if (s & Qs)
          return "Default";
        if (s & Ml)
          return "TransitionHydration";
        if (s & Po)
          return "Transition";
        if (s & bl)
          return "Retry";
        if (s & Nr)
          return "SelectiveHydration";
        if (s & Ea)
          return "IdleHydration";
        if (s & Ps)
          return "Idle";
        if (s & or)
          return "Offscreen";
      }
    }
    var Fn = -1, to = Lo, wi = Tl;
    function Iu(s) {
      switch (no(s)) {
        case ln:
          return ln;
        case $a:
          return $a;
        case ps:
          return ps;
        case eo:
          return eo;
        case Qs:
          return Qs;
        case Ml:
          return Ml;
        case Lo:
        case pf:
        case mf:
        case Ch:
        case vf:
        case Ph:
        case Lh:
        case gf:
        case yf:
        case xf:
        case _f:
        case El:
        case Dh:
        case Nh:
        case Uh:
        case Ou:
          return s & Po;
        case Tl:
        case Sf:
        case Mf:
        case Ef:
        case bf:
          return s & bl;
        case Nr:
          return Nr;
        case Ea:
          return Ea;
        case Ps:
          return Ps;
        case or:
          return or;
        default:
          return h("Should have found matching lanes. This is a bug in React."), s;
      }
    }
    function wf(s, a) {
      var p = s.pendingLanes;
      if (p === Ge)
        return Ge;
      var v = Ge, S = s.suspendedLanes, R = s.pingedLanes, L = p & Ih;
      if (L !== Ge) {
        var F = L & ~S;
        if (F !== Ge)
          v = Iu(F);
        else {
          var H = L & R;
          H !== Ge && (v = Iu(H));
        }
      } else {
        var Z = p & ~S;
        Z !== Ge ? v = Iu(Z) : R !== Ge && (v = Iu(R));
      }
      if (v === Ge)
        return Ge;
      if (a !== Ge && a !== v && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (a & S) === Ge) {
        var te = no(v), xe = no(a);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          te >= xe || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          te === Qs && (xe & Po) !== Ge
        )
          return a;
      }
      (v & ps) !== Ge && (v |= p & Qs);
      var we = s.entangledLanes;
      if (we !== Ge)
        for (var De = s.entanglements, We = v & we; We > 0; ) {
          var Je = io(We), Vt = 1 << Je;
          v |= De[Je], We &= ~Vt;
        }
      return v;
    }
    function Zr(s, a) {
      for (var p = s.eventTimes, v = Fn; a > 0; ) {
        var S = io(a), R = 1 << S, L = p[S];
        L > v && (v = L), a &= ~R;
      }
      return v;
    }
    function mr(s, a) {
      switch (s) {
        case ln:
        case $a:
        case ps:
          return a + 250;
        case eo:
        case Qs:
        case Ml:
        case Lo:
        case pf:
        case mf:
        case Ch:
        case vf:
        case Ph:
        case Lh:
        case gf:
        case yf:
        case xf:
        case _f:
        case El:
        case Dh:
        case Nh:
        case Uh:
        case Ou:
          return a + 5e3;
        case Tl:
        case Sf:
        case Mf:
        case Ef:
        case bf:
          return Fn;
        case Nr:
        case Ea:
        case Ps:
        case or:
          return Fn;
        default:
          return h("Should have found matching lanes. This is a bug in React."), Fn;
      }
    }
    function ov(s, a) {
      for (var p = s.pendingLanes, v = s.suspendedLanes, S = s.pingedLanes, R = s.expirationTimes, L = p; L > 0; ) {
        var F = io(L), H = 1 << F, Z = R[F];
        Z === Fn ? ((H & v) === Ge || (H & S) !== Ge) && (R[F] = mr(H, a)) : Z <= a && (s.expiredLanes |= H), L &= ~H;
      }
    }
    function lv(s) {
      return Iu(s.pendingLanes);
    }
    function Af(s) {
      var a = s.pendingLanes & ~or;
      return a !== Ge ? a : a & or ? or : Ge;
    }
    function uv(s) {
      return (s & ln) !== Ge;
    }
    function Rf(s) {
      return (s & Ih) !== Ge;
    }
    function Cf(s) {
      return (s & bl) === s;
    }
    function cv(s) {
      return (s & Po) === s;
    }
    function wl(s, a) {
      var p = $a | ps | eo | Qs;
      return (a & p) !== Ge;
    }
    function fv(s, a) {
      return (a & s.expiredLanes) !== Ge;
    }
    function Fh(s) {
      return (s & Po) !== 0;
    }
    function Pf() {
      var s = to;
      return to <<= 1, to & Po || (to = Lo), s;
    }
    function Lf() {
      var s = wi;
      return wi <<= 1, wi & bl || (wi = Tl), s;
    }
    function no(s) {
      return s & -s;
    }
    function Do(s) {
      return no(s);
    }
    function io(s) {
      return 31 - Ah(s);
    }
    function Df(s) {
      return io(s);
    }
    function lr(s, a) {
      return (s & a) !== Ge;
    }
    function No(s, a) {
      return (s & a) === a;
    }
    function nn(s, a) {
      return s | a;
    }
    function Fu(s, a) {
      return s & ~a;
    }
    function $s(s, a) {
      return s & a;
    }
    function Vb(s) {
      return s;
    }
    function tx(s, a) {
      return s !== ri && s < a ? s : a;
    }
    function Al(s) {
      for (var a = [], p = 0; p < Co; p++)
        a.push(s);
      return a;
    }
    function Ls(s, a, p) {
      s.pendingLanes |= a, a !== Ps && (s.suspendedLanes = Ge, s.pingedLanes = Ge);
      var v = s.eventTimes, S = Df(a);
      v[S] = p;
    }
    function nx(s, a) {
      s.suspendedLanes |= a, s.pingedLanes &= ~a;
      for (var p = s.expirationTimes, v = a; v > 0; ) {
        var S = io(v), R = 1 << S;
        p[S] = Fn, v &= ~R;
      }
    }
    function gt(s, a, p) {
      s.pingedLanes |= s.suspendedLanes & a;
    }
    function Nf(s, a) {
      var p = s.pendingLanes & ~a;
      s.pendingLanes = a, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= a, s.mutableReadLanes &= a, s.entangledLanes &= a;
      for (var v = s.entanglements, S = s.eventTimes, R = s.expirationTimes, L = p; L > 0; ) {
        var F = io(L), H = 1 << F;
        v[F] = Ge, S[F] = Fn, R[F] = Fn, L &= ~H;
      }
    }
    function zu(s, a) {
      for (var p = s.entangledLanes |= a, v = s.entanglements, S = p; S; ) {
        var R = io(S), L = 1 << R;
        // Is this one of the newly entangled lanes?
        L & a | // Is this lane transitively entangled with the newly entangled lanes?
        v[R] & a && (v[R] |= a), S &= ~L;
      }
    }
    function dv(s, a) {
      var p = no(a), v;
      switch (p) {
        case ps:
          v = $a;
          break;
        case Qs:
          v = eo;
          break;
        case Lo:
        case pf:
        case mf:
        case Ch:
        case vf:
        case Ph:
        case Lh:
        case gf:
        case yf:
        case xf:
        case _f:
        case El:
        case Dh:
        case Nh:
        case Uh:
        case Ou:
        case Tl:
        case Sf:
        case Mf:
        case Ef:
        case bf:
          v = Ml;
          break;
        case Ps:
          v = Ea;
          break;
        default:
          v = ri;
          break;
      }
      return (v & (s.suspendedLanes | a)) !== ri ? ri : v;
    }
    function hv(s, a, p) {
      if (Kr)
        for (var v = s.pendingUpdatersLaneMap; p > 0; ) {
          var S = Df(p), R = 1 << S, L = v[S];
          L.add(a), p &= ~R;
        }
    }
    function ro(s, a) {
      if (Kr)
        for (var p = s.pendingUpdatersLaneMap, v = s.memoizedUpdaters; a > 0; ) {
          var S = Df(a), R = 1 << S, L = p[S];
          L.size > 0 && (L.forEach(function(F) {
            var H = F.alternate;
            (H === null || !v.has(H)) && v.add(F);
          }), L.clear()), a &= ~R;
        }
    }
    var Ur = ln, Uo = ps, Rl = Qs, Uf = Ps, Cl = ri;
    function ms() {
      return Cl;
    }
    function Ai(s) {
      Cl = s;
    }
    function pv(s, a) {
      var p = Cl;
      try {
        return Cl = s, a();
      } finally {
        Cl = p;
      }
    }
    function zh(s, a) {
      return s !== 0 && s < a ? s : a;
    }
    function Bh(s, a) {
      return s > a ? s : a;
    }
    function Vh(s, a) {
      return s !== 0 && s < a;
    }
    function Of(s) {
      var a = no(s);
      return Vh(Ur, a) ? Vh(Uo, a) ? Rf(a) ? Rl : Uf : Uo : Ur;
    }
    var Bu = r.unstable_scheduleCallback, ix = r.unstable_cancelCallback, rx = r.unstable_shouldYield, mv = r.unstable_requestPaint, Ri = r.unstable_now, Vu = r.unstable_ImmediatePriority, Hh = r.unstable_UserBlockingPriority, ba = r.unstable_NormalPriority, Hu = r.unstable_IdlePriority, If = r.unstable_yieldValue, Ff = r.unstable_setDisableYieldValue, Ta = null, vi = null, yt = null, vs = !1, Kr = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function vv(s) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var a = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (a.isDisabled)
        return !0;
      if (!a.supportsFiber)
        return h("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        C && (s = g({}, s, {
          getLaneLabelMap: gi,
          injectProfilingHooks: un
        })), Ta = a.inject(s), vi = a;
      } catch (p) {
        h("React instrumentation encountered an error: %s.", p);
      }
      return !!a.checkDCE;
    }
    function kh(s, a) {
      if (vi && typeof vi.onScheduleFiberRoot == "function")
        try {
          vi.onScheduleFiberRoot(Ta, s, a);
        } catch (p) {
          vs || (vs = !0, h("React instrumentation encountered an error: %s", p));
        }
    }
    function sx(s, a) {
      if (vi && typeof vi.onCommitFiberRoot == "function")
        try {
          var p = (s.current.flags & Ye) === Ye;
          if (A) {
            var v;
            switch (a) {
              case Ur:
                v = Vu;
                break;
              case Uo:
                v = Hh;
                break;
              case Rl:
                v = ba;
                break;
              case Uf:
                v = Hu;
                break;
              default:
                v = ba;
                break;
            }
            vi.onCommitFiberRoot(Ta, s, v, p);
          }
        } catch (S) {
          vs || (vs = !0, h("React instrumentation encountered an error: %s", S));
        }
    }
    function zf(s) {
      if (vi && typeof vi.onPostCommitFiberRoot == "function")
        try {
          vi.onPostCommitFiberRoot(Ta, s);
        } catch (a) {
          vs || (vs = !0, h("React instrumentation encountered an error: %s", a));
        }
    }
    function Gh(s) {
      if (vi && typeof vi.onCommitFiberUnmount == "function")
        try {
          vi.onCommitFiberUnmount(Ta, s);
        } catch (a) {
          vs || (vs = !0, h("React instrumentation encountered an error: %s", a));
        }
    }
    function mn(s) {
      if (typeof If == "function" && (Ff(s), u(s)), vi && typeof vi.setStrictMode == "function")
        try {
          vi.setStrictMode(Ta, s);
        } catch (a) {
          vs || (vs = !0, h("React instrumentation encountered an error: %s", a));
        }
    }
    function un(s) {
      yt = s;
    }
    function gi() {
      {
        for (var s = /* @__PURE__ */ new Map(), a = 1, p = 0; p < Co; p++) {
          var v = Tf(a);
          s.set(a, v), a *= 2;
        }
        return s;
      }
    }
    function yi(s) {
      yt !== null && typeof yt.markCommitStarted == "function" && yt.markCommitStarted(s);
    }
    function Hi() {
      yt !== null && typeof yt.markCommitStopped == "function" && yt.markCommitStopped();
    }
    function Zi(s) {
      yt !== null && typeof yt.markComponentRenderStarted == "function" && yt.markComponentRenderStarted(s);
    }
    function Ds() {
      yt !== null && typeof yt.markComponentRenderStopped == "function" && yt.markComponentRenderStopped();
    }
    function Ci(s) {
      yt !== null && typeof yt.markComponentPassiveEffectMountStarted == "function" && yt.markComponentPassiveEffectMountStarted(s);
    }
    function ku() {
      yt !== null && typeof yt.markComponentPassiveEffectMountStopped == "function" && yt.markComponentPassiveEffectMountStopped();
    }
    function Pl(s) {
      yt !== null && typeof yt.markComponentPassiveEffectUnmountStarted == "function" && yt.markComponentPassiveEffectUnmountStarted(s);
    }
    function Bf() {
      yt !== null && typeof yt.markComponentPassiveEffectUnmountStopped == "function" && yt.markComponentPassiveEffectUnmountStopped();
    }
    function Wh(s) {
      yt !== null && typeof yt.markComponentLayoutEffectMountStarted == "function" && yt.markComponentLayoutEffectMountStarted(s);
    }
    function Gu() {
      yt !== null && typeof yt.markComponentLayoutEffectMountStopped == "function" && yt.markComponentLayoutEffectMountStopped();
    }
    function vr(s) {
      yt !== null && typeof yt.markComponentLayoutEffectUnmountStarted == "function" && yt.markComponentLayoutEffectUnmountStarted(s);
    }
    function Vf() {
      yt !== null && typeof yt.markComponentLayoutEffectUnmountStopped == "function" && yt.markComponentLayoutEffectUnmountStopped();
    }
    function Xh(s, a, p) {
      yt !== null && typeof yt.markComponentErrored == "function" && yt.markComponentErrored(s, a, p);
    }
    function Ll(s, a, p) {
      yt !== null && typeof yt.markComponentSuspended == "function" && yt.markComponentSuspended(s, a, p);
    }
    function Hf(s) {
      yt !== null && typeof yt.markLayoutEffectsStarted == "function" && yt.markLayoutEffectsStarted(s);
    }
    function jh() {
      yt !== null && typeof yt.markLayoutEffectsStopped == "function" && yt.markLayoutEffectsStopped();
    }
    function so(s) {
      yt !== null && typeof yt.markPassiveEffectsStarted == "function" && yt.markPassiveEffectsStarted(s);
    }
    function kf() {
      yt !== null && typeof yt.markPassiveEffectsStopped == "function" && yt.markPassiveEffectsStopped();
    }
    function wa(s) {
      yt !== null && typeof yt.markRenderStarted == "function" && yt.markRenderStarted(s);
    }
    function Gf() {
      yt !== null && typeof yt.markRenderYielded == "function" && yt.markRenderYielded();
    }
    function Dl() {
      yt !== null && typeof yt.markRenderStopped == "function" && yt.markRenderStopped();
    }
    function Yh(s) {
      yt !== null && typeof yt.markRenderScheduled == "function" && yt.markRenderScheduled(s);
    }
    function Wf(s, a) {
      yt !== null && typeof yt.markForceUpdateScheduled == "function" && yt.markForceUpdateScheduled(s, a);
    }
    function Nl(s, a) {
      yt !== null && typeof yt.markStateUpdateScheduled == "function" && yt.markStateUpdateScheduled(s, a);
    }
    function gr(s, a) {
      return s === a && (s !== 0 || 1 / s === 1 / a) || s !== s && a !== a;
    }
    var Pi = typeof Object.is == "function" ? Object.is : gr, xi = null, Ul = !1, ur = !1;
    function qh(s) {
      xi === null ? xi = [s] : xi.push(s);
    }
    function Zh(s) {
      Ul = !0, qh(s);
    }
    function Xf() {
      Ul && ea();
    }
    function ea() {
      if (!ur && xi !== null) {
        ur = !0;
        var s = 0, a = ms();
        try {
          var p = !0, v = xi;
          for (Ai(Ur); s < v.length; s++) {
            var S = v[s];
            do
              S = S(p);
            while (S !== null);
          }
          xi = null, Ul = !1;
        } catch (R) {
          throw xi !== null && (xi = xi.slice(s + 1)), Bu(Vu, ea), R;
        } finally {
          Ai(a), ur = !1;
        }
      }
      return null;
    }
    function Aa(s) {
      var a = s.current.memoizedState;
      return a.isDehydrated;
    }
    var gv = o.ReactCurrentBatchConfig, yv = null;
    function Kh() {
      return gv.transition;
    }
    function ta(s, a) {
      if (Pi(s, a))
        return !0;
      if (typeof s != "object" || s === null || typeof a != "object" || a === null)
        return !1;
      var p = Object.keys(s), v = Object.keys(a);
      if (p.length !== v.length)
        return !1;
      for (var S = 0; S < p.length; S++) {
        var R = p[S];
        if (!xl.call(a, R) || !Pi(s[R], a[R]))
          return !1;
      }
      return !0;
    }
    function xv(s) {
      switch (s._debugOwner && s._debugOwner.type, s._debugSource, s.tag) {
        case O:
          return ds(s.type);
        case ue:
          return ds("Lazy");
        case Q:
          return ds("Suspense");
        case Ae:
          return ds("SuspenseList");
        case z:
        case V:
        case re:
          return cf(s.type);
        case ie:
          return cf(s.type.render);
        case I:
          return rv(s.type);
        default:
          return "";
      }
    }
    function Jh(s) {
      try {
        var a = "", p = s;
        do
          a += xv(p), p = p.return;
        while (p);
        return a;
      } catch (v) {
        return `
Error generating stack: ` + v.message + `
` + v.stack;
      }
    }
    var jf = o.ReactDebugCurrentFrame, yr = null, Wu = !1;
    function ax() {
      {
        if (yr === null)
          return null;
        var s = yr._debugOwner;
        if (s !== null && typeof s < "u")
          return Y(s);
      }
      return null;
    }
    function _v() {
      return yr === null ? "" : Jh(yr);
    }
    function Ki() {
      jf.getCurrentStack = null, yr = null, Wu = !1;
    }
    function jn(s) {
      jf.getCurrentStack = _v, yr = s, Wu = !1;
    }
    function na(s) {
      Wu = s;
    }
    var Ji = {
      recordUnsafeLifecycleWarnings: function(s, a) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(s, a) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Sv = function(s) {
        for (var a = null, p = s; p !== null; )
          p.mode & ii && (a = p), p = p.return;
        return a;
      }, _i = function(s) {
        var a = [];
        return s.forEach(function(p) {
          a.push(p);
        }), a.sort().join(", ");
      }, Xu = [], Ol = [], ju = [], Yu = [], Il = [], Fl = [], Oo = /* @__PURE__ */ new Set();
      Ji.recordUnsafeLifecycleWarnings = function(s, a) {
        Oo.has(s.type) || (typeof a.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        a.componentWillMount.__suppressDeprecationWarning !== !0 && Xu.push(s), s.mode & ii && typeof a.UNSAFE_componentWillMount == "function" && Ol.push(s), typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && ju.push(s), s.mode & ii && typeof a.UNSAFE_componentWillReceiveProps == "function" && Yu.push(s), typeof a.componentWillUpdate == "function" && a.componentWillUpdate.__suppressDeprecationWarning !== !0 && Il.push(s), s.mode & ii && typeof a.UNSAFE_componentWillUpdate == "function" && Fl.push(s));
      }, Ji.flushPendingUnsafeLifecycleWarnings = function() {
        var s = /* @__PURE__ */ new Set();
        Xu.length > 0 && (Xu.forEach(function(we) {
          s.add(Y(we) || "Component"), Oo.add(we.type);
        }), Xu = []);
        var a = /* @__PURE__ */ new Set();
        Ol.length > 0 && (Ol.forEach(function(we) {
          a.add(Y(we) || "Component"), Oo.add(we.type);
        }), Ol = []);
        var p = /* @__PURE__ */ new Set();
        ju.length > 0 && (ju.forEach(function(we) {
          p.add(Y(we) || "Component"), Oo.add(we.type);
        }), ju = []);
        var v = /* @__PURE__ */ new Set();
        Yu.length > 0 && (Yu.forEach(function(we) {
          v.add(Y(we) || "Component"), Oo.add(we.type);
        }), Yu = []);
        var S = /* @__PURE__ */ new Set();
        Il.length > 0 && (Il.forEach(function(we) {
          S.add(Y(we) || "Component"), Oo.add(we.type);
        }), Il = []);
        var R = /* @__PURE__ */ new Set();
        if (Fl.length > 0 && (Fl.forEach(function(we) {
          R.add(Y(we) || "Component"), Oo.add(we.type);
        }), Fl = []), a.size > 0) {
          var L = _i(a);
          h(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, L);
        }
        if (v.size > 0) {
          var F = _i(v);
          h(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, F);
        }
        if (R.size > 0) {
          var H = _i(R);
          h(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, H);
        }
        if (s.size > 0) {
          var Z = _i(s);
          d(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Z);
        }
        if (p.size > 0) {
          var te = _i(p);
          d(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, te);
        }
        if (S.size > 0) {
          var xe = _i(S);
          d(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, xe);
        }
      };
      var xr = /* @__PURE__ */ new Map(), Yf = /* @__PURE__ */ new Set();
      Ji.recordLegacyContextWarning = function(s, a) {
        var p = Sv(s);
        if (p === null) {
          h("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Yf.has(s.type)) {
          var v = xr.get(p);
          (s.type.contextTypes != null || s.type.childContextTypes != null || a !== null && typeof a.getChildContext == "function") && (v === void 0 && (v = [], xr.set(p, v)), v.push(s));
        }
      }, Ji.flushLegacyContextWarning = function() {
        xr.forEach(function(s, a) {
          if (s.length !== 0) {
            var p = s[0], v = /* @__PURE__ */ new Set();
            s.forEach(function(R) {
              v.add(Y(R) || "Component"), Yf.add(R.type);
            });
            var S = _i(v);
            try {
              jn(p), h(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, S);
            } finally {
              Ki();
            }
          }
        });
      }, Ji.discardPendingWarnings = function() {
        Xu = [], Ol = [], ju = [], Yu = [], Il = [], Fl = [], xr = /* @__PURE__ */ new Map();
      };
    }
    function Mv(s) {
      {
        var a = typeof Symbol == "function" && Symbol.toStringTag, p = a && s[Symbol.toStringTag] || s.constructor.name || "Object";
        return p;
      }
    }
    function Ra(s) {
      try {
        return zl(s), !1;
      } catch {
        return !0;
      }
    }
    function zl(s) {
      return "" + s;
    }
    function Io(s) {
      if (Ra(s))
        return h("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Mv(s)), zl(s);
    }
    function qf(s, a) {
      if (Ra(s))
        return h("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", a, Mv(s)), zl(s);
    }
    function Jr(s, a) {
      if (s && s.defaultProps) {
        var p = g({}, a), v = s.defaultProps;
        for (var S in v)
          p[S] === void 0 && (p[S] = v[S]);
        return p;
      }
      return a;
    }
    var Bl = Js(null), qu;
    qu = {};
    var Zu = null, Fo = null, Zf = null, Ku = !1;
    function Vl() {
      Zu = null, Fo = null, Zf = null, Ku = !1;
    }
    function Ev() {
      Ku = !0;
    }
    function bv() {
      Ku = !1;
    }
    function c(s, a, p) {
      Kc ? (mi(Bl, a._currentValue, s), a._currentValue = p, a._currentRenderer !== void 0 && a._currentRenderer !== null && a._currentRenderer !== qu && h("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer = qu) : (mi(Bl, a._currentValue2, s), a._currentValue2 = p, a._currentRenderer2 !== void 0 && a._currentRenderer2 !== null && a._currentRenderer2 !== qu && h("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer2 = qu);
    }
    function f(s, a) {
      var p = Bl.current;
      pn(Bl, a), Kc ? s._currentValue = p : s._currentValue2 = p;
    }
    function x(s, a, p) {
      for (var v = s; v !== null; ) {
        var S = v.alternate;
        if (No(v.childLanes, a) ? S !== null && !No(S.childLanes, a) && (S.childLanes = nn(S.childLanes, a)) : (v.childLanes = nn(v.childLanes, a), S !== null && (S.childLanes = nn(S.childLanes, a))), v === p)
          break;
        v = v.return;
      }
      v !== p && h("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function b(s, a, p) {
      P(s, a, p);
    }
    function P(s, a, p) {
      var v = s.child;
      for (v !== null && (v.return = s); v !== null; ) {
        var S = void 0, R = v.dependencies;
        if (R !== null) {
          S = v.child;
          for (var L = R.firstContext; L !== null; ) {
            if (L.context === a) {
              if (v.tag === I) {
                var F = Do(p), H = be(Fn, F);
                H.tag = Bt;
                var Z = v.updateQueue;
                if (Z !== null) {
                  var te = Z.shared, xe = te.pending;
                  xe === null ? H.next = H : (H.next = xe.next, xe.next = H), te.pending = H;
                }
              }
              v.lanes = nn(v.lanes, p);
              var we = v.alternate;
              we !== null && (we.lanes = nn(we.lanes, p)), x(v.return, p, s), R.lanes = nn(R.lanes, p);
              break;
            }
            L = L.next;
          }
        } else if (v.tag === oe)
          S = v.type === s.type ? null : v.child;
        else if (v.tag === pe) {
          var De = v.return;
          if (De === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          De.lanes = nn(De.lanes, p);
          var We = De.alternate;
          We !== null && (We.lanes = nn(We.lanes, p)), x(De, p, s), S = v.sibling;
        } else
          S = v.child;
        if (S !== null)
          S.return = v;
        else
          for (S = v; S !== null; ) {
            if (S === s) {
              S = null;
              break;
            }
            var Je = S.sibling;
            if (Je !== null) {
              Je.return = S.return, S = Je;
              break;
            }
            S = S.return;
          }
        v = S;
      }
    }
    function D(s, a) {
      Zu = s, Fo = null, Zf = null;
      var p = s.dependencies;
      if (p !== null) {
        var v = p.firstContext;
        v !== null && (lr(p.lanes, a) && og(), p.firstContext = null);
      }
    }
    function X(s) {
      Ku && h("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var a = Kc ? s._currentValue : s._currentValue2;
      if (Zf !== s) {
        var p = {
          context: s,
          memoizedValue: a,
          next: null
        };
        if (Fo === null) {
          if (Zu === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Fo = p, Zu.dependencies = {
            lanes: Ge,
            firstContext: p
          };
        } else
          Fo = Fo.next = p;
      }
      return a;
    }
    var ae = null;
    function Ce(s) {
      ae === null ? ae = [s] : ae.push(s);
    }
    function et() {
      if (ae !== null) {
        for (var s = 0; s < ae.length; s++) {
          var a = ae[s], p = a.interleaved;
          if (p !== null) {
            a.interleaved = null;
            var v = p.next, S = a.pending;
            if (S !== null) {
              var R = S.next;
              S.next = v, p.next = R;
            }
            a.pending = p;
          }
        }
        ae = null;
      }
    }
    var bt = 0, en = 1, Bt = 2, Nn = 3, Nt = !1, ki, _r;
    ki = !1, _r = null;
    function Se(s) {
      var a = {
        baseState: s.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ge
        },
        effects: null
      };
      s.updateQueue = a;
    }
    function fe(s, a) {
      var p = a.updateQueue, v = s.updateQueue;
      if (p === v) {
        var S = {
          baseState: v.baseState,
          firstBaseUpdate: v.firstBaseUpdate,
          lastBaseUpdate: v.lastBaseUpdate,
          shared: v.shared,
          effects: v.effects
        };
        a.updateQueue = S;
      }
    }
    function be(s, a) {
      var p = {
        eventTime: s,
        lane: a,
        tag: bt,
        payload: null,
        callback: null,
        next: null
      };
      return p;
    }
    function ut(s, a, p) {
      var v = s.updateQueue;
      if (v !== null) {
        var S = v.shared;
        if (B1(s)) {
          var R = S.interleaved;
          R === null ? (a.next = a, Ce(S)) : (a.next = R.next, R.next = a), S.interleaved = a;
        } else {
          var L = S.pending;
          L === null ? a.next = a : (a.next = L.next, L.next = a), S.pending = a;
        }
        _r === S && !ki && (h("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), ki = !0);
      }
    }
    function Pt(s, a, p) {
      var v = a.updateQueue;
      if (v !== null) {
        var S = v.shared;
        if (Fh(p)) {
          var R = S.lanes;
          R = $s(R, s.pendingLanes);
          var L = nn(R, p);
          S.lanes = L, zu(s, L);
        }
      }
    }
    function sn(s, a) {
      var p = s.updateQueue, v = s.alternate;
      if (v !== null) {
        var S = v.updateQueue;
        if (p === S) {
          var R = null, L = null, F = p.firstBaseUpdate;
          if (F !== null) {
            var H = F;
            do {
              var Z = {
                eventTime: H.eventTime,
                lane: H.lane,
                tag: H.tag,
                payload: H.payload,
                callback: H.callback,
                next: null
              };
              L === null ? R = L = Z : (L.next = Z, L = Z), H = H.next;
            } while (H !== null);
            L === null ? R = L = a : (L.next = a, L = a);
          } else
            R = L = a;
          p = {
            baseState: S.baseState,
            firstBaseUpdate: R,
            lastBaseUpdate: L,
            shared: S.shared,
            effects: S.effects
          }, s.updateQueue = p;
          return;
        }
      }
      var te = p.lastBaseUpdate;
      te === null ? p.firstBaseUpdate = a : te.next = a, p.lastBaseUpdate = a;
    }
    function rn(s, a, p, v, S, R) {
      switch (p.tag) {
        case en: {
          var L = p.payload;
          if (typeof L == "function") {
            Ev();
            var F = L.call(R, v, S);
            {
              if (s.mode & ii) {
                mn(!0);
                try {
                  L.call(R, v, S);
                } finally {
                  mn(!1);
                }
              }
              bv();
            }
            return F;
          }
          return L;
        }
        case Nn:
          s.flags = s.flags & ~Zn | Ye;
        case bt: {
          var H = p.payload, Z;
          if (typeof H == "function") {
            Ev(), Z = H.call(R, v, S);
            {
              if (s.mode & ii) {
                mn(!0);
                try {
                  H.call(R, v, S);
                } finally {
                  mn(!1);
                }
              }
              bv();
            }
          } else
            Z = H;
          return Z == null ? v : g({}, v, Z);
        }
        case Bt:
          return Nt = !0, v;
      }
      return v;
    }
    function Mn(s, a, p, v) {
      var S = s.updateQueue;
      Nt = !1, _r = S.shared;
      var R = S.firstBaseUpdate, L = S.lastBaseUpdate, F = S.shared.pending;
      if (F !== null) {
        S.shared.pending = null;
        var H = F, Z = H.next;
        H.next = null, L === null ? R = Z : L.next = Z, L = H;
        var te = s.alternate;
        if (te !== null) {
          var xe = te.updateQueue, we = xe.lastBaseUpdate;
          we !== L && (we === null ? xe.firstBaseUpdate = Z : we.next = Z, xe.lastBaseUpdate = H);
        }
      }
      if (R !== null) {
        var De = S.baseState, We = Ge, Je = null, Vt = null, an = null, kt = R;
        do {
          var Qn = kt.lane, $n = kt.eventTime;
          if (No(v, Qn)) {
            if (an !== null) {
              var Ne = {
                eventTime: $n,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ri,
                tag: kt.tag,
                payload: kt.payload,
                callback: kt.callback,
                next: null
              };
              an = an.next = Ne;
            }
            De = rn(s, S, kt, De, a, p);
            var _e = kt.callback;
            if (_e !== null && // If the update was already committed, we should not queue its
            // callback again.
            kt.lane !== ri) {
              s.flags |= zt;
              var tt = S.effects;
              tt === null ? S.effects = [kt] : tt.push(kt);
            }
          } else {
            var Me = {
              eventTime: $n,
              lane: Qn,
              tag: kt.tag,
              payload: kt.payload,
              callback: kt.callback,
              next: null
            };
            an === null ? (Vt = an = Me, Je = De) : an = an.next = Me, We = nn(We, Qn);
          }
          if (kt = kt.next, kt === null) {
            if (F = S.shared.pending, F === null)
              break;
            var It = F, Et = It.next;
            It.next = null, kt = Et, S.lastBaseUpdate = It, S.shared.pending = null;
          }
        } while (!0);
        an === null && (Je = De), S.baseState = Je, S.firstBaseUpdate = Vt, S.lastBaseUpdate = an;
        var En = S.shared.interleaved;
        if (En !== null) {
          var Un = En;
          do
            We = nn(We, Un.lane), Un = Un.next;
          while (Un !== En);
        } else R === null && (S.shared.lanes = Ge);
        Pg(We), s.lanes = We, s.memoizedState = De;
      }
      _r = null;
    }
    function Gi(s, a) {
      if (typeof s != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + s));
      s.call(a);
    }
    function wn() {
      Nt = !1;
    }
    function Ns() {
      return Nt;
    }
    function Tv(s, a, p) {
      var v = a.effects;
      if (a.effects = null, v !== null)
        for (var S = 0; S < v.length; S++) {
          var R = v[S], L = R.callback;
          L !== null && (R.callback = null, Gi(L, p));
        }
    }
    var ox = {}, Hb = new n.Component().refs, lx, ux, cx, fx, dx, kb, wv, hx, px, mx;
    {
      lx = /* @__PURE__ */ new Set(), ux = /* @__PURE__ */ new Set(), cx = /* @__PURE__ */ new Set(), fx = /* @__PURE__ */ new Set(), hx = /* @__PURE__ */ new Set(), dx = /* @__PURE__ */ new Set(), px = /* @__PURE__ */ new Set(), mx = /* @__PURE__ */ new Set();
      var Gb = /* @__PURE__ */ new Set();
      wv = function(s, a) {
        if (!(s === null || typeof s == "function")) {
          var p = a + "_" + s;
          Gb.has(p) || (Gb.add(p), h("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, s));
        }
      }, kb = function(s, a) {
        if (a === void 0) {
          var p = Xe(s) || "Component";
          dx.has(p) || (dx.add(p), h("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", p));
        }
      }, Object.defineProperty(ox, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(ox);
    }
    function vx(s, a, p, v) {
      var S = s.memoizedState, R = p(v, S);
      {
        if (s.mode & ii) {
          mn(!0);
          try {
            R = p(v, S);
          } finally {
            mn(!1);
          }
        }
        kb(a, R);
      }
      var L = R == null ? S : g({}, S, R);
      if (s.memoizedState = L, s.lanes === Ge) {
        var F = s.updateQueue;
        F.baseState = L;
      }
    }
    var gx = {
      isMounted: Wt,
      enqueueSetState: function(s, a, p) {
        var v = y(s), S = $r(), R = ql(v), L = be(S, R);
        L.payload = a, p != null && (wv(p, "setState"), L.callback = p), ut(v, L);
        var F = tr(v, R, S);
        F !== null && Pt(F, v, R), Nl(v, R);
      },
      enqueueReplaceState: function(s, a, p) {
        var v = y(s), S = $r(), R = ql(v), L = be(S, R);
        L.tag = en, L.payload = a, p != null && (wv(p, "replaceState"), L.callback = p), ut(v, L);
        var F = tr(v, R, S);
        F !== null && Pt(F, v, R), Nl(v, R);
      },
      enqueueForceUpdate: function(s, a) {
        var p = y(s), v = $r(), S = ql(p), R = be(v, S);
        R.tag = Bt, a != null && (wv(a, "forceUpdate"), R.callback = a), ut(p, R);
        var L = tr(p, S, v);
        L !== null && Pt(L, p, S), Wf(p, S);
      }
    };
    function Wb(s, a, p, v, S, R, L) {
      var F = s.stateNode;
      if (typeof F.shouldComponentUpdate == "function") {
        var H = F.shouldComponentUpdate(v, R, L);
        {
          if (s.mode & ii) {
            mn(!0);
            try {
              H = F.shouldComponentUpdate(v, R, L);
            } finally {
              mn(!1);
            }
          }
          H === void 0 && h("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Xe(a) || "Component");
        }
        return H;
      }
      return a.prototype && a.prototype.isPureReactComponent ? !ta(p, v) || !ta(S, R) : !0;
    }
    function U2(s, a, p) {
      var v = s.stateNode;
      {
        var S = Xe(a) || "Component", R = v.render;
        R || (a.prototype && typeof a.prototype.render == "function" ? h("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", S) : h("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", S)), v.getInitialState && !v.getInitialState.isReactClassApproved && !v.state && h("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", S), v.getDefaultProps && !v.getDefaultProps.isReactClassApproved && h("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", S), v.propTypes && h("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", S), v.contextType && h("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", S), v.contextTypes && h("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", S), a.contextType && a.contextTypes && !px.has(a) && (px.add(a), h("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", S)), typeof v.componentShouldUpdate == "function" && h("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", S), a.prototype && a.prototype.isPureReactComponent && typeof v.shouldComponentUpdate < "u" && h("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Xe(a) || "A pure component"), typeof v.componentDidUnmount == "function" && h("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", S), typeof v.componentDidReceiveProps == "function" && h("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", S), typeof v.componentWillRecieveProps == "function" && h("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", S), typeof v.UNSAFE_componentWillRecieveProps == "function" && h("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", S);
        var L = v.props !== p;
        v.props !== void 0 && L && h("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", S, S), v.defaultProps && h("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", S, S), typeof v.getSnapshotBeforeUpdate == "function" && typeof v.componentDidUpdate != "function" && !cx.has(a) && (cx.add(a), h("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Xe(a))), typeof v.getDerivedStateFromProps == "function" && h("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", S), typeof v.getDerivedStateFromError == "function" && h("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", S), typeof a.getSnapshotBeforeUpdate == "function" && h("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", S);
        var F = v.state;
        F && (typeof F != "object" || ht(F)) && h("%s.state: must be set to an object or null", S), typeof v.getChildContext == "function" && typeof a.childContextTypes != "object" && h("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", S);
      }
    }
    function Xb(s, a) {
      a.updater = gx, s.stateNode = a, _(a, s), a._reactInternalInstance = ox;
    }
    function jb(s, a, p) {
      var v = !1, S = hr, R = hr, L = a.contextType;
      if ("contextType" in a) {
        var F = (
          // Allow null for conditional declaration
          L === null || L !== void 0 && L.$$typeof === Re && L._context === void 0
        );
        if (!F && !mx.has(a)) {
          mx.add(a);
          var H = "";
          L === void 0 ? H = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof L != "object" ? H = " However, it is set to a " + typeof L + "." : L.$$typeof === He ? H = " Did you accidentally pass the Context.Provider instead?" : L._context !== void 0 ? H = " Did you accidentally pass the Context.Consumer instead?" : H = " However, it is set to an object with keys {" + Object.keys(L).join(", ") + "}.", h("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Xe(a) || "Component", H);
        }
      }
      if (typeof L == "object" && L !== null)
        R = X(L);
      else {
        S = In(s, a, !0);
        var Z = a.contextTypes;
        v = Z != null, R = v ? Jn(s, S) : hr;
      }
      var te = new a(p, R);
      if (s.mode & ii) {
        mn(!0);
        try {
          te = new a(p, R);
        } finally {
          mn(!1);
        }
      }
      var xe = s.memoizedState = te.state !== null && te.state !== void 0 ? te.state : null;
      Xb(s, te);
      {
        if (typeof a.getDerivedStateFromProps == "function" && xe === null) {
          var we = Xe(a) || "Component";
          ux.has(we) || (ux.add(we), h("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", we, te.state === null ? "null" : "undefined", we));
        }
        if (typeof a.getDerivedStateFromProps == "function" || typeof te.getSnapshotBeforeUpdate == "function") {
          var De = null, We = null, Je = null;
          if (typeof te.componentWillMount == "function" && te.componentWillMount.__suppressDeprecationWarning !== !0 ? De = "componentWillMount" : typeof te.UNSAFE_componentWillMount == "function" && (De = "UNSAFE_componentWillMount"), typeof te.componentWillReceiveProps == "function" && te.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? We = "componentWillReceiveProps" : typeof te.UNSAFE_componentWillReceiveProps == "function" && (We = "UNSAFE_componentWillReceiveProps"), typeof te.componentWillUpdate == "function" && te.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Je = "componentWillUpdate" : typeof te.UNSAFE_componentWillUpdate == "function" && (Je = "UNSAFE_componentWillUpdate"), De !== null || We !== null || Je !== null) {
            var Vt = Xe(a) || "Component", an = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            fx.has(Vt) || (fx.add(Vt), h(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Vt, an, De !== null ? `
  ` + De : "", We !== null ? `
  ` + We : "", Je !== null ? `
  ` + Je : ""));
          }
        }
      }
      return v && Yi(s, S, R), te;
    }
    function O2(s, a) {
      var p = a.state;
      typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), p !== a.state && (h("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Y(s) || "Component"), gx.enqueueReplaceState(a, a.state, null));
    }
    function Yb(s, a, p, v) {
      var S = a.state;
      if (typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(p, v), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(p, v), a.state !== S) {
        {
          var R = Y(s) || "Component";
          lx.has(R) || (lx.add(R), h("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", R));
        }
        gx.enqueueReplaceState(a, a.state, null);
      }
    }
    function yx(s, a, p, v) {
      U2(s, a, p);
      var S = s.stateNode;
      S.props = p, S.state = s.memoizedState, S.refs = Hb, Se(s);
      var R = a.contextType;
      if (typeof R == "object" && R !== null)
        S.context = X(R);
      else {
        var L = In(s, a, !0);
        S.context = Jn(s, L);
      }
      {
        if (S.state === p) {
          var F = Xe(a) || "Component";
          hx.has(F) || (hx.add(F), h("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", F));
        }
        s.mode & ii && Ji.recordLegacyContextWarning(s, S), Ji.recordUnsafeLifecycleWarnings(s, S);
      }
      S.state = s.memoizedState;
      var H = a.getDerivedStateFromProps;
      if (typeof H == "function" && (vx(s, a, H, p), S.state = s.memoizedState), typeof a.getDerivedStateFromProps != "function" && typeof S.getSnapshotBeforeUpdate != "function" && (typeof S.UNSAFE_componentWillMount == "function" || typeof S.componentWillMount == "function") && (O2(s, S), Mn(s, p, S, v), S.state = s.memoizedState), typeof S.componentDidMount == "function") {
        var Z = Te;
        Z |= Ft, (s.mode & Cs) !== Yt && (Z |= hn), s.flags |= Z;
      }
    }
    function I2(s, a, p, v) {
      var S = s.stateNode, R = s.memoizedProps;
      S.props = R;
      var L = S.context, F = a.contextType, H = hr;
      if (typeof F == "object" && F !== null)
        H = X(F);
      else {
        var Z = In(s, a, !0);
        H = Jn(s, Z);
      }
      var te = a.getDerivedStateFromProps, xe = typeof te == "function" || typeof S.getSnapshotBeforeUpdate == "function";
      !xe && (typeof S.UNSAFE_componentWillReceiveProps == "function" || typeof S.componentWillReceiveProps == "function") && (R !== p || L !== H) && Yb(s, S, p, H), wn();
      var we = s.memoizedState, De = S.state = we;
      if (Mn(s, p, S, v), De = s.memoizedState, R === p && we === De && !Ro() && !Ns()) {
        if (typeof S.componentDidMount == "function") {
          var We = Te;
          We |= Ft, (s.mode & Cs) !== Yt && (We |= hn), s.flags |= We;
        }
        return !1;
      }
      typeof te == "function" && (vx(s, a, te, p), De = s.memoizedState);
      var Je = Ns() || Wb(s, a, R, p, we, De, H);
      if (Je) {
        if (!xe && (typeof S.UNSAFE_componentWillMount == "function" || typeof S.componentWillMount == "function") && (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function") {
          var Vt = Te;
          Vt |= Ft, (s.mode & Cs) !== Yt && (Vt |= hn), s.flags |= Vt;
        }
      } else {
        if (typeof S.componentDidMount == "function") {
          var an = Te;
          an |= Ft, (s.mode & Cs) !== Yt && (an |= hn), s.flags |= an;
        }
        s.memoizedProps = p, s.memoizedState = De;
      }
      return S.props = p, S.state = De, S.context = H, Je;
    }
    function F2(s, a, p, v, S) {
      var R = a.stateNode;
      fe(s, a);
      var L = a.memoizedProps, F = a.type === a.elementType ? L : Jr(a.type, L);
      R.props = F;
      var H = a.pendingProps, Z = R.context, te = p.contextType, xe = hr;
      if (typeof te == "object" && te !== null)
        xe = X(te);
      else {
        var we = In(a, p, !0);
        xe = Jn(a, we);
      }
      var De = p.getDerivedStateFromProps, We = typeof De == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !We && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (L !== H || Z !== xe) && Yb(a, R, v, xe), wn();
      var Je = a.memoizedState, Vt = R.state = Je;
      if (Mn(a, v, R, S), Vt = a.memoizedState, L === H && Je === Vt && !Ro() && !Ns() && !w)
        return typeof R.componentDidUpdate == "function" && (L !== s.memoizedProps || Je !== s.memoizedState) && (a.flags |= Te), typeof R.getSnapshotBeforeUpdate == "function" && (L !== s.memoizedProps || Je !== s.memoizedState) && (a.flags |= Sn), !1;
      typeof De == "function" && (vx(a, p, De, v), Vt = a.memoizedState);
      var an = Ns() || Wb(a, p, F, v, Je, Vt, xe) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      w;
      return an ? (!We && (typeof R.UNSAFE_componentWillUpdate == "function" || typeof R.componentWillUpdate == "function") && (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(v, Vt, xe), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(v, Vt, xe)), typeof R.componentDidUpdate == "function" && (a.flags |= Te), typeof R.getSnapshotBeforeUpdate == "function" && (a.flags |= Sn)) : (typeof R.componentDidUpdate == "function" && (L !== s.memoizedProps || Je !== s.memoizedState) && (a.flags |= Te), typeof R.getSnapshotBeforeUpdate == "function" && (L !== s.memoizedProps || Je !== s.memoizedState) && (a.flags |= Sn), a.memoizedProps = v, a.memoizedState = Vt), R.props = v, R.state = Vt, R.context = xe, an;
    }
    var Kf = [], Jf = 0, Av = null, Rv = 0, ia = [], ra = 0, Ju = null, zo = 1, Bo = "";
    function z2(s) {
      return $u(), (s.flags & ke) !== he;
    }
    function B2(s) {
      return $u(), Rv;
    }
    function V2() {
      var s = Bo, a = zo, p = a & ~H2(a);
      return p.toString(32) + s;
    }
    function Qu(s, a) {
      $u(), Kf[Jf++] = Rv, Kf[Jf++] = Av, Av = s, Rv = a;
    }
    function qb(s, a, p) {
      $u(), ia[ra++] = zo, ia[ra++] = Bo, ia[ra++] = Ju, Ju = s;
      var v = zo, S = Bo, R = Cv(v) - 1, L = v & ~(1 << R), F = p + 1, H = Cv(a) + R;
      if (H > 30) {
        var Z = R - R % 5, te = (1 << Z) - 1, xe = (L & te).toString(32), we = L >> Z, De = R - Z, We = Cv(a) + De, Je = F << De, Vt = Je | we, an = xe + S;
        zo = 1 << We | Vt, Bo = an;
      } else {
        var kt = F << R, Qn = kt | L, $n = S;
        zo = 1 << H | Qn, Bo = $n;
      }
    }
    function xx(s) {
      $u();
      var a = s.return;
      if (a !== null) {
        var p = 1, v = 0;
        Qu(s, p), qb(s, p, v);
      }
    }
    function Cv(s) {
      return 32 - Ah(s);
    }
    function H2(s) {
      return 1 << Cv(s) - 1;
    }
    function _x(s) {
      for (; s === Av; )
        Av = Kf[--Jf], Kf[Jf] = null, Rv = Kf[--Jf], Kf[Jf] = null;
      for (; s === Ju; )
        Ju = ia[--ra], ia[ra] = null, Bo = ia[--ra], ia[ra] = null, zo = ia[--ra], ia[ra] = null;
    }
    function k2() {
      return $u(), Ju !== null ? {
        id: zo,
        overflow: Bo
      } : null;
    }
    function G2(s, a) {
      $u(), ia[ra++] = zo, ia[ra++] = Bo, ia[ra++] = Ju, zo = a.id, Bo = a.overflow, Ju = s;
    }
    function $u() {
      Or() || h("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Sr = null, sa = null, Ca = !1, ec = !1, Hl = null;
    function W2() {
      Ca && h("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function X2() {
      ec = !0;
    }
    function j2(s) {
      if (!ar)
        return !1;
      var a = s.stateNode.containerInfo;
      return sa = Ya(a), Sr = s, Ca = !0, Hl = null, ec = !1, !0;
    }
    function Y2(s, a, p) {
      return ar ? (sa = _h(a), Sr = s, Ca = !0, Hl = null, ec = !1, p !== null && G2(s, p), !0) : !1;
    }
    function Zb(s, a) {
      switch (s.tag) {
        case W:
          tv(s.stateNode.containerInfo, a);
          break;
        case O:
          Eh(s.type, s.memoizedProps, s.stateNode, a);
          break;
        case Q:
          var p = s.memoizedState;
          p.dehydrated !== null && nv(p.dehydrated, a);
          break;
      }
    }
    function Kb(s, a) {
      Zb(s, a);
      var p = q3();
      p.stateNode = a, p.return = s;
      var v = s.deletions;
      v === null ? (s.deletions = [p], s.flags |= Ke) : v.push(p);
    }
    function Sx(s, a) {
      {
        if (ec)
          return;
        switch (s.tag) {
          case W: {
            var p = s.stateNode.containerInfo;
            switch (a.tag) {
              case O:
                var v = a.type, S = a.pendingProps;
                dl(p, v, S);
                break;
              case q:
                var R = a.pendingProps;
                hl(p, R);
                break;
              case Q:
                sf(p);
                break;
            }
            break;
          }
          case O: {
            var L = s.type, F = s.memoizedProps, H = s.stateNode;
            switch (a.tag) {
              case O:
                var Z = a.type, te = a.pendingProps;
                wo(L, F, H, Z, te);
                break;
              case q:
                var xe = a.pendingProps;
                ya(L, F, H, xe);
                break;
              case Q:
                xa(L, F, H);
                break;
            }
            break;
          }
          case Q: {
            var we = s.memoizedState, De = we.dehydrated;
            if (De !== null) switch (a.tag) {
              case O:
                var We = a.type, Je = a.pendingProps;
                af(De, We, Je);
                break;
              case q:
                var Vt = a.pendingProps;
                us(De, Vt);
                break;
              case Q:
                cs(De);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function Jb(s, a) {
      a.flags = a.flags & ~Jt | Ve, Sx(s, a);
    }
    function Qb(s, a) {
      switch (s.tag) {
        case O: {
          var p = s.type, v = s.pendingProps, S = yh(a, p, v);
          return S !== null ? (s.stateNode = S, Sr = s, sa = Zs(S), !0) : !1;
        }
        case q: {
          var R = s.pendingProps, L = xh(a, R);
          return L !== null ? (s.stateNode = L, Sr = s, sa = null, !0) : !1;
        }
        case Q: {
          {
            var F = Km(a);
            if (F !== null) {
              var H = {
                dehydrated: F,
                treeContext: k2(),
                retryLane: or
              };
              s.memoizedState = H;
              var Z = Z3(F);
              return Z.return = s, s.child = Z, Sr = s, sa = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Mx(s) {
      return (s.mode & Rn) !== Yt && (s.flags & Ye) === he;
    }
    function Ex(s) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function bx(s) {
      if (Ca) {
        var a = sa;
        if (!a) {
          Mx(s) && (Sx(Sr, s), Ex()), Jb(Sr, s), Ca = !1, Sr = s;
          return;
        }
        var p = a;
        if (!Qb(s, a)) {
          Mx(s) && (Sx(Sr, s), Ex()), a = dr(p);
          var v = Sr;
          if (!a || !Qb(s, a)) {
            Jb(Sr, s), Ca = !1, Sr = s;
            return;
          }
          Kb(v, p);
        }
      }
    }
    function q2(s, a, p) {
      if (!ar)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var v = s.stateNode, S = !ec, R = Jm(v, s.type, s.memoizedProps, a, p, s, S);
      return s.updateQueue = R, R !== null;
    }
    function Z2(s) {
      if (!ar)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = s.stateNode, p = s.memoizedProps, v = !ec, S = ga(a, p, s, v);
      if (S) {
        var R = Sr;
        if (R !== null) {
          var L = (R.mode & Rn) !== Yt;
          switch (R.tag) {
            case W: {
              var F = R.stateNode.containerInfo;
              rf(
                F,
                a,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                L
              );
              break;
            }
            case O: {
              var H = R.type, Z = R.memoizedProps, te = R.stateNode;
              ev(
                H,
                Z,
                te,
                a,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                L
              );
              break;
            }
          }
        }
      }
      return S;
    }
    function K2(s) {
      if (!ar)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = s.memoizedState, p = a !== null ? a.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      qa(p, s);
    }
    function J2(s) {
      if (!ar)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = s.memoizedState, p = a !== null ? a.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return tf(p);
    }
    function $b(s) {
      for (var a = s.return; a !== null && a.tag !== O && a.tag !== W && a.tag !== Q; )
        a = a.return;
      Sr = a;
    }
    function Qh(s) {
      if (!ar || s !== Sr)
        return !1;
      if (!Ca)
        return $b(s), Ca = !0, !1;
      if (s.tag !== W && (s.tag !== O || Mh(s.type) && !Ti(s.type, s.memoizedProps))) {
        var a = sa;
        if (a)
          if (Mx(s))
            eT(s), Ex();
          else
            for (; a; )
              Kb(s, a), a = dr(a);
      }
      return $b(s), s.tag === Q ? sa = J2(s) : sa = Sr ? dr(s.stateNode) : null, !0;
    }
    function Q2() {
      return Ca && sa !== null;
    }
    function eT(s) {
      for (var a = sa; a; )
        Zb(s, a), a = dr(a);
    }
    function Qf() {
      ar && (Sr = null, sa = null, Ca = !1, ec = !1);
    }
    function tT() {
      Hl !== null && (H1(Hl), Hl = null);
    }
    function Or() {
      return Ca;
    }
    function Tx(s) {
      Hl === null ? Hl = [s] : Hl.push(s);
    }
    var wx, Ax, Rx, Cx, Px, nT = function(s, a) {
    };
    wx = !1, Ax = !1, Rx = {}, Cx = {}, Px = {}, nT = function(s, a) {
      if (!(s === null || typeof s != "object") && !(!s._store || s._store.validated || s.key != null)) {
        if (typeof s._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        s._store.validated = !0;
        var p = Y(a) || "Component";
        Cx[p] || (Cx[p] = !0, h('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function $h(s, a, p) {
      var v = p.ref;
      if (v !== null && typeof v != "function" && typeof v != "object") {
        if ((s.mode & ii || M) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(p._owner && p._self && p._owner.stateNode !== p._self)) {
          var S = Y(s) || "Component";
          Rx[S] || (h('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', v), Rx[S] = !0);
        }
        if (p._owner) {
          var R = p._owner, L;
          if (R) {
            var F = R;
            if (F.tag !== I)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            L = F.stateNode;
          }
          if (!L)
            throw new Error("Missing owner for string ref " + v + ". This error is likely caused by a bug in React. Please file an issue.");
          var H = L;
          qf(v, "ref");
          var Z = "" + v;
          if (a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === Z)
            return a.ref;
          var te = function(xe) {
            var we = H.refs;
            we === Hb && (we = H.refs = {}), xe === null ? delete we[Z] : we[Z] = xe;
          };
          return te._stringRef = Z, te;
        } else {
          if (typeof v != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!p._owner)
            throw new Error("Element ref was specified as a string (" + v + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return v;
    }
    function Pv(s, a) {
      var p = Object.prototype.toString.call(a);
      throw new Error("Objects are not valid as a React child (found: " + (p === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : p) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Lv(s) {
      {
        var a = Y(s) || "Component";
        if (Px[a])
          return;
        Px[a] = !0, h("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function iT(s) {
      var a = s._payload, p = s._init;
      return p(a);
    }
    function rT(s) {
      function a(Me, Ne) {
        if (s) {
          var _e = Me.deletions;
          _e === null ? (Me.deletions = [Ne], Me.flags |= Ke) : _e.push(Ne);
        }
      }
      function p(Me, Ne) {
        if (!s)
          return null;
        for (var _e = Ne; _e !== null; )
          a(Me, _e), _e = _e.sibling;
        return null;
      }
      function v(Me, Ne) {
        for (var _e = /* @__PURE__ */ new Map(), tt = Ne; tt !== null; )
          tt.key !== null ? _e.set(tt.key, tt) : _e.set(tt.index, tt), tt = tt.sibling;
        return _e;
      }
      function S(Me, Ne) {
        var _e = oc(Me, Ne);
        return _e.index = 0, _e.sibling = null, _e;
      }
      function R(Me, Ne, _e) {
        if (Me.index = _e, !s)
          return Me.flags |= ke, Ne;
        var tt = Me.alternate;
        if (tt !== null) {
          var It = tt.index;
          return It < Ne ? (Me.flags |= Ve, Ne) : It;
        } else
          return Me.flags |= Ve, Ne;
      }
      function L(Me) {
        return s && Me.alternate === null && (Me.flags |= Ve), Me;
      }
      function F(Me, Ne, _e, tt) {
        if (Ne === null || Ne.tag !== q) {
          var It = $_(_e, Me.mode, tt);
          return It.return = Me, It;
        } else {
          var Et = S(Ne, _e);
          return Et.return = Me, Et;
        }
      }
      function H(Me, Ne, _e, tt) {
        var It = _e.type;
        if (It === J)
          return te(Me, Ne, _e.props.children, tt, _e.key);
        if (Ne !== null && (Ne.elementType === It || // Keep this check inline so it only runs on the false path:
        nw(Ne, _e) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof It == "object" && It !== null && It.$$typeof === ce && iT(It) === Ne.type)) {
          var Et = S(Ne, _e.props);
          return Et.ref = $h(Me, Ne, _e), Et.return = Me, Et._debugSource = _e._source, Et._debugOwner = _e._owner, Et;
        }
        var En = Q_(_e, Me.mode, tt);
        return En.ref = $h(Me, Ne, _e), En.return = Me, En;
      }
      function Z(Me, Ne, _e, tt) {
        if (Ne === null || Ne.tag !== U || Ne.stateNode.containerInfo !== _e.containerInfo || Ne.stateNode.implementation !== _e.implementation) {
          var It = eS(_e, Me.mode, tt);
          return It.return = Me, It;
        } else {
          var Et = S(Ne, _e.children || []);
          return Et.return = Me, Et;
        }
      }
      function te(Me, Ne, _e, tt, It) {
        if (Ne === null || Ne.tag !== le) {
          var Et = Kl(_e, Me.mode, tt, It);
          return Et.return = Me, Et;
        } else {
          var En = S(Ne, _e);
          return En.return = Me, En;
        }
      }
      function xe(Me, Ne, _e) {
        if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number") {
          var tt = $_("" + Ne, Me.mode, _e);
          return tt.return = Me, tt;
        }
        if (typeof Ne == "object" && Ne !== null) {
          switch (Ne.$$typeof) {
            case ot: {
              var It = Q_(Ne, Me.mode, _e);
              return It.ref = $h(Me, null, Ne), It.return = Me, It;
            }
            case pt: {
              var Et = eS(Ne, Me.mode, _e);
              return Et.return = Me, Et;
            }
            case ce: {
              var En = Ne._payload, Un = Ne._init;
              return xe(Me, Un(En), _e);
            }
          }
          if (ht(Ne) || de(Ne)) {
            var Xn = Kl(Ne, Me.mode, _e, null);
            return Xn.return = Me, Xn;
          }
          Pv(Me, Ne);
        }
        return typeof Ne == "function" && Lv(Me), null;
      }
      function we(Me, Ne, _e, tt) {
        var It = Ne !== null ? Ne.key : null;
        if (typeof _e == "string" && _e !== "" || typeof _e == "number")
          return It !== null ? null : F(Me, Ne, "" + _e, tt);
        if (typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case ot:
              return _e.key === It ? H(Me, Ne, _e, tt) : null;
            case pt:
              return _e.key === It ? Z(Me, Ne, _e, tt) : null;
            case ce: {
              var Et = _e._payload, En = _e._init;
              return we(Me, Ne, En(Et), tt);
            }
          }
          if (ht(_e) || de(_e))
            return It !== null ? null : te(Me, Ne, _e, tt, null);
          Pv(Me, _e);
        }
        return typeof _e == "function" && Lv(Me), null;
      }
      function De(Me, Ne, _e, tt, It) {
        if (typeof tt == "string" && tt !== "" || typeof tt == "number") {
          var Et = Me.get(_e) || null;
          return F(Ne, Et, "" + tt, It);
        }
        if (typeof tt == "object" && tt !== null) {
          switch (tt.$$typeof) {
            case ot: {
              var En = Me.get(tt.key === null ? _e : tt.key) || null;
              return H(Ne, En, tt, It);
            }
            case pt: {
              var Un = Me.get(tt.key === null ? _e : tt.key) || null;
              return Z(Ne, Un, tt, It);
            }
            case ce: {
              var Xn = tt._payload, On = tt._init;
              return De(Me, Ne, _e, On(Xn), It);
            }
          }
          if (ht(tt) || de(tt)) {
            var li = Me.get(_e) || null;
            return te(Ne, li, tt, It, null);
          }
          Pv(Ne, tt);
        }
        return typeof tt == "function" && Lv(Ne), null;
      }
      function We(Me, Ne, _e) {
        {
          if (typeof Me != "object" || Me === null)
            return Ne;
          switch (Me.$$typeof) {
            case ot:
            case pt:
              nT(Me, _e);
              var tt = Me.key;
              if (typeof tt != "string")
                break;
              if (Ne === null) {
                Ne = /* @__PURE__ */ new Set(), Ne.add(tt);
                break;
              }
              if (!Ne.has(tt)) {
                Ne.add(tt);
                break;
              }
              h("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", tt);
              break;
            case ce: {
              var It = Me._payload, Et = Me._init;
              We(Et(It), Ne, _e);
              break;
            }
          }
        }
        return Ne;
      }
      function Je(Me, Ne, _e, tt) {
        for (var It = null, Et = 0; Et < _e.length; Et++) {
          var En = _e[Et];
          It = We(En, It, Me);
        }
        for (var Un = null, Xn = null, On = Ne, li = 0, Cn = 0, yn = null; On !== null && Cn < _e.length; Cn++) {
          On.index > Cn ? (yn = On, On = null) : yn = On.sibling;
          var Di = we(Me, On, _e[Cn], tt);
          if (Di === null) {
            On === null && (On = yn);
            break;
          }
          s && On && Di.alternate === null && a(Me, On), li = R(Di, li, Cn), Xn === null ? Un = Di : Xn.sibling = Di, Xn = Di, On = yn;
        }
        if (Cn === _e.length) {
          if (p(Me, On), Or()) {
            var ui = Cn;
            Qu(Me, ui);
          }
          return Un;
        }
        if (On === null) {
          for (; Cn < _e.length; Cn++) {
            var fa = xe(Me, _e[Cn], tt);
            fa !== null && (li = R(fa, li, Cn), Xn === null ? Un = fa : Xn.sibling = fa, Xn = fa);
          }
          if (Or()) {
            var wr = Cn;
            Qu(Me, wr);
          }
          return Un;
        }
        for (var Os = v(Me, On); Cn < _e.length; Cn++) {
          var Is = De(Os, Me, Cn, _e[Cn], tt);
          Is !== null && (s && Is.alternate !== null && Os.delete(Is.key === null ? Cn : Is.key), li = R(Is, li, Cn), Xn === null ? Un = Is : Xn.sibling = Is, Xn = Is);
        }
        if (s && Os.forEach(function(pd) {
          return a(Me, pd);
        }), Or()) {
          var ho = Cn;
          Qu(Me, ho);
        }
        return Un;
      }
      function Vt(Me, Ne, _e, tt) {
        var It = de(_e);
        if (typeof It != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          _e[Symbol.toStringTag] === "Generator" && (Ax || h("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ax = !0), _e.entries === It && (wx || h("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), wx = !0);
          var Et = It.call(_e);
          if (Et)
            for (var En = null, Un = Et.next(); !Un.done; Un = Et.next()) {
              var Xn = Un.value;
              En = We(Xn, En, Me);
            }
        }
        var On = It.call(_e);
        if (On == null)
          throw new Error("An iterable object provided no iterator.");
        for (var li = null, Cn = null, yn = Ne, Di = 0, ui = 0, fa = null, wr = On.next(); yn !== null && !wr.done; ui++, wr = On.next()) {
          yn.index > ui ? (fa = yn, yn = null) : fa = yn.sibling;
          var Os = we(Me, yn, wr.value, tt);
          if (Os === null) {
            yn === null && (yn = fa);
            break;
          }
          s && yn && Os.alternate === null && a(Me, yn), Di = R(Os, Di, ui), Cn === null ? li = Os : Cn.sibling = Os, Cn = Os, yn = fa;
        }
        if (wr.done) {
          if (p(Me, yn), Or()) {
            var Is = ui;
            Qu(Me, Is);
          }
          return li;
        }
        if (yn === null) {
          for (; !wr.done; ui++, wr = On.next()) {
            var ho = xe(Me, wr.value, tt);
            ho !== null && (Di = R(ho, Di, ui), Cn === null ? li = ho : Cn.sibling = ho, Cn = ho);
          }
          if (Or()) {
            var pd = ui;
            Qu(Me, pd);
          }
          return li;
        }
        for (var md = v(Me, yn); !wr.done; ui++, wr = On.next()) {
          var Fs = De(md, Me, ui, wr.value, tt);
          Fs !== null && (s && Fs.alternate !== null && md.delete(Fs.key === null ? ui : Fs.key), Di = R(Fs, Di, ui), Cn === null ? li = Fs : Cn.sibling = Fs, Cn = Fs);
        }
        if (s && md.forEach(function(sS) {
          return a(Me, sS);
        }), Or()) {
          var lc = ui;
          Qu(Me, lc);
        }
        return li;
      }
      function an(Me, Ne, _e, tt) {
        if (Ne !== null && Ne.tag === q) {
          p(Me, Ne.sibling);
          var It = S(Ne, _e);
          return It.return = Me, It;
        }
        p(Me, Ne);
        var Et = $_(_e, Me.mode, tt);
        return Et.return = Me, Et;
      }
      function kt(Me, Ne, _e, tt) {
        for (var It = _e.key, Et = Ne; Et !== null; ) {
          if (Et.key === It) {
            var En = _e.type;
            if (En === J) {
              if (Et.tag === le) {
                p(Me, Et.sibling);
                var Un = S(Et, _e.props.children);
                return Un.return = Me, Un._debugSource = _e._source, Un._debugOwner = _e._owner, Un;
              }
            } else if (Et.elementType === En || // Keep this check inline so it only runs on the false path:
            nw(Et, _e) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof En == "object" && En !== null && En.$$typeof === ce && iT(En) === Et.type) {
              p(Me, Et.sibling);
              var Xn = S(Et, _e.props);
              return Xn.ref = $h(Me, Et, _e), Xn.return = Me, Xn._debugSource = _e._source, Xn._debugOwner = _e._owner, Xn;
            }
            p(Me, Et);
            break;
          } else
            a(Me, Et);
          Et = Et.sibling;
        }
        if (_e.type === J) {
          var On = Kl(_e.props.children, Me.mode, tt, _e.key);
          return On.return = Me, On;
        } else {
          var li = Q_(_e, Me.mode, tt);
          return li.ref = $h(Me, Ne, _e), li.return = Me, li;
        }
      }
      function Qn(Me, Ne, _e, tt) {
        for (var It = _e.key, Et = Ne; Et !== null; ) {
          if (Et.key === It)
            if (Et.tag === U && Et.stateNode.containerInfo === _e.containerInfo && Et.stateNode.implementation === _e.implementation) {
              p(Me, Et.sibling);
              var En = S(Et, _e.children || []);
              return En.return = Me, En;
            } else {
              p(Me, Et);
              break;
            }
          else
            a(Me, Et);
          Et = Et.sibling;
        }
        var Un = eS(_e, Me.mode, tt);
        return Un.return = Me, Un;
      }
      function $n(Me, Ne, _e, tt) {
        var It = typeof _e == "object" && _e !== null && _e.type === J && _e.key === null;
        if (It && (_e = _e.props.children), typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case ot:
              return L(kt(Me, Ne, _e, tt));
            case pt:
              return L(Qn(Me, Ne, _e, tt));
            case ce: {
              var Et = _e._payload, En = _e._init;
              return $n(Me, Ne, En(Et), tt);
            }
          }
          if (ht(_e))
            return Je(Me, Ne, _e, tt);
          if (de(_e))
            return Vt(Me, Ne, _e, tt);
          Pv(Me, _e);
        }
        return typeof _e == "string" && _e !== "" || typeof _e == "number" ? L(an(Me, Ne, "" + _e, tt)) : (typeof _e == "function" && Lv(Me), p(Me, Ne));
      }
      return $n;
    }
    var $f = rT(!0), sT = rT(!1);
    function $2(s, a) {
      if (s !== null && a.child !== s.child)
        throw new Error("Resuming work not yet implemented.");
      if (a.child !== null) {
        var p = a.child, v = oc(p, p.pendingProps);
        for (a.child = v, v.return = a; p.sibling !== null; )
          p = p.sibling, v = v.sibling = oc(p, p.pendingProps), v.return = a;
        v.sibling = null;
      }
    }
    function eN(s, a) {
      for (var p = s.child; p !== null; )
        G3(p, a), p = p.sibling;
    }
    var ep = {}, kl = Js(ep), tp = Js(ep), Dv = Js(ep);
    function Nv(s) {
      if (s === ep)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return s;
    }
    function Lx() {
      var s = Nv(Dv.current);
      return s;
    }
    function Dx(s, a) {
      mi(Dv, a, s), mi(tp, s, s), mi(kl, ep, s);
      var p = on(a);
      pn(kl, s), mi(kl, p, s);
    }
    function ed(s) {
      pn(kl, s), pn(tp, s), pn(Dv, s);
    }
    function np() {
      var s = Nv(kl.current);
      return s;
    }
    function aT(s) {
      var a = Nv(Dv.current), p = Nv(kl.current), v = ti(p, s.type, a);
      p !== v && (mi(tp, s, s), mi(kl, v, s));
    }
    function Nx(s) {
      tp.current === s && (pn(kl, s), pn(tp, s));
    }
    var tN = 0, oT = 1, lT = 1, ip = 2, Pa = Js(tN);
    function Ux(s, a) {
      return (s & a) !== 0;
    }
    function td(s) {
      return s & oT;
    }
    function Ox(s, a) {
      return s & oT | a;
    }
    function nN(s, a) {
      return s | a;
    }
    function Gl(s, a) {
      mi(Pa, a, s);
    }
    function nd(s) {
      pn(Pa, s);
    }
    function iN(s, a) {
      var p = s.memoizedState;
      return p !== null ? p.dehydrated !== null : (s.memoizedProps, !0);
    }
    function Uv(s) {
      for (var a = s; a !== null; ) {
        if (a.tag === Q) {
          var p = a.memoizedState;
          if (p !== null) {
            var v = p.dehydrated;
            if (v === null || ef(v) || Pu(v))
              return a;
          }
        } else if (a.tag === Ae && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        a.memoizedProps.revealOrder !== void 0) {
          var S = (a.flags & Ye) !== he;
          if (S)
            return a;
        } else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === s)
          return null;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === s)
            return null;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return null;
    }
    var ao = (
      /*   */
      0
    ), si = (
      /* */
      1
    ), Wl = (
      /*  */
      2
    ), Li = (
      /*    */
      4
    ), Mr = (
      /*   */
      8
    ), Ix = [];
    function Fx() {
      for (var s = 0; s < Ix.length; s++) {
        var a = Ix[s];
        Kc ? a._workInProgressVersionPrimary = null : a._workInProgressVersionSecondary = null;
      }
      Ix.length = 0;
    }
    function rN(s, a) {
      var p = a._getVersion, v = p(a._source);
      s.mutableSourceEagerHydrationData == null ? s.mutableSourceEagerHydrationData = [a, v] : s.mutableSourceEagerHydrationData.push(a, v);
    }
    var St = o.ReactCurrentDispatcher, gs = o.ReactCurrentBatchConfig, zx, id;
    zx = /* @__PURE__ */ new Set();
    var rd = Ge, Hn = null, Ir = null, Qi = null, Ov = !1, rp = !1, sp = 0, sN = 0, aN = 25, Ue = null, aa = null, Xl = -1, Bx = !1;
    function Ln() {
      {
        var s = Ue;
        aa === null ? aa = [s] : aa.push(s);
      }
    }
    function ct() {
      {
        var s = Ue;
        aa !== null && (Xl++, aa[Xl] !== s && oN(s));
      }
    }
    function sd(s) {
      s != null && !ht(s) && h("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Ue, typeof s);
    }
    function oN(s) {
      {
        var a = Y(Hn);
        if (!zx.has(a) && (zx.add(a), aa !== null)) {
          for (var p = "", v = 30, S = 0; S <= Xl; S++) {
            for (var R = aa[S], L = S === Xl ? s : R, F = S + 1 + ". " + R; F.length < v; )
              F += " ";
            F += L + `
`, p += F;
          }
          h(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, a, p);
        }
      }
    }
    function Fr() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function Vx(s, a) {
      if (Bx)
        return !1;
      if (a === null)
        return h("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Ue), !1;
      s.length !== a.length && h(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Ue, "[" + a.join(", ") + "]", "[" + s.join(", ") + "]");
      for (var p = 0; p < a.length && p < s.length; p++)
        if (!Pi(s[p], a[p]))
          return !1;
      return !0;
    }
    function ad(s, a, p, v, S, R) {
      rd = R, Hn = a, aa = s !== null ? s._debugHookTypes : null, Xl = -1, Bx = s !== null && s.type !== a.type, a.memoizedState = null, a.updateQueue = null, a.lanes = Ge, s !== null && s.memoizedState !== null ? St.current = PT : aa !== null ? St.current = CT : St.current = RT;
      var L = p(v, S);
      if (rp) {
        var F = 0;
        do {
          if (rp = !1, sp = 0, F >= aN)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          F += 1, Bx = !1, Ir = null, Qi = null, a.updateQueue = null, Xl = -1, St.current = LT, L = p(v, S);
        } while (rp);
      }
      St.current = qv, a._debugHookTypes = aa;
      var H = Ir !== null && Ir.next !== null;
      if (rd = Ge, Hn = null, Ir = null, Qi = null, Ue = null, aa = null, Xl = -1, s !== null && (s.flags & Qe) !== (a.flags & Qe) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (s.mode & Rn) !== Yt && h("Internal React error: Expected static flag was missing. Please notify the React team."), Ov = !1, H)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return L;
    }
    function od() {
      var s = sp !== 0;
      return sp = 0, s;
    }
    function uT(s, a, p) {
      a.updateQueue = s.updateQueue, (a.mode & Cs) !== Yt ? a.flags &= -50333701 : a.flags &= -2053, s.lanes = Fu(s.lanes, p);
    }
    function cT() {
      if (St.current = qv, Ov) {
        for (var s = Hn.memoizedState; s !== null; ) {
          var a = s.queue;
          a !== null && (a.pending = null), s = s.next;
        }
        Ov = !1;
      }
      rd = Ge, Hn = null, Ir = null, Qi = null, aa = null, Xl = -1, Ue = null, MT = !1, rp = !1, sp = 0;
    }
    function Vo() {
      var s = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Qi === null ? Hn.memoizedState = Qi = s : Qi = Qi.next = s, Qi;
    }
    function oo() {
      var s;
      if (Ir === null) {
        var a = Hn.alternate;
        a !== null ? s = a.memoizedState : s = null;
      } else
        s = Ir.next;
      var p;
      if (Qi === null ? p = Hn.memoizedState : p = Qi.next, p !== null)
        Qi = p, p = Qi.next, Ir = s;
      else {
        if (s === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ir = s;
        var v = {
          memoizedState: Ir.memoizedState,
          baseState: Ir.baseState,
          baseQueue: Ir.baseQueue,
          queue: Ir.queue,
          next: null
        };
        Qi === null ? Hn.memoizedState = Qi = v : Qi = Qi.next = v;
      }
      return Qi;
    }
    function fT() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Hx(s, a) {
      return typeof a == "function" ? a(s) : a;
    }
    function kx(s, a, p) {
      var v = Vo(), S;
      p !== void 0 ? S = p(a) : S = a, v.memoizedState = v.baseState = S;
      var R = {
        pending: null,
        interleaved: null,
        lanes: Ge,
        dispatch: null,
        lastRenderedReducer: s,
        lastRenderedState: S
      };
      v.queue = R;
      var L = R.dispatch = fN.bind(null, Hn, R);
      return [v.memoizedState, L];
    }
    function Gx(s, a, p) {
      var v = oo(), S = v.queue;
      if (S === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      S.lastRenderedReducer = s;
      var R = Ir, L = R.baseQueue, F = S.pending;
      if (F !== null) {
        if (L !== null) {
          var H = L.next, Z = F.next;
          L.next = Z, F.next = H;
        }
        R.baseQueue !== L && h("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), R.baseQueue = L = F, S.pending = null;
      }
      if (L !== null) {
        var te = L.next, xe = R.baseState, we = null, De = null, We = null, Je = te;
        do {
          var Vt = Je.lane;
          if (No(rd, Vt)) {
            if (We !== null) {
              var kt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ri,
                action: Je.action,
                hasEagerState: Je.hasEagerState,
                eagerState: Je.eagerState,
                next: null
              };
              We = We.next = kt;
            }
            if (Je.hasEagerState)
              xe = Je.eagerState;
            else {
              var Qn = Je.action;
              xe = s(xe, Qn);
            }
          } else {
            var an = {
              lane: Vt,
              action: Je.action,
              hasEagerState: Je.hasEagerState,
              eagerState: Je.eagerState,
              next: null
            };
            We === null ? (De = We = an, we = xe) : We = We.next = an, Hn.lanes = nn(Hn.lanes, Vt), Pg(Vt);
          }
          Je = Je.next;
        } while (Je !== null && Je !== te);
        We === null ? we = xe : We.next = De, Pi(xe, v.memoizedState) || og(), v.memoizedState = xe, v.baseState = we, v.baseQueue = We, S.lastRenderedState = xe;
      }
      var $n = S.interleaved;
      if ($n !== null) {
        var Me = $n;
        do {
          var Ne = Me.lane;
          Hn.lanes = nn(Hn.lanes, Ne), Pg(Ne), Me = Me.next;
        } while (Me !== $n);
      } else L === null && (S.lanes = Ge);
      var _e = S.dispatch;
      return [v.memoizedState, _e];
    }
    function Wx(s, a, p) {
      var v = oo(), S = v.queue;
      if (S === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      S.lastRenderedReducer = s;
      var R = S.dispatch, L = S.pending, F = v.memoizedState;
      if (L !== null) {
        S.pending = null;
        var H = L.next, Z = H;
        do {
          var te = Z.action;
          F = s(F, te), Z = Z.next;
        } while (Z !== H);
        Pi(F, v.memoizedState) || og(), v.memoizedState = F, v.baseQueue === null && (v.baseState = F), S.lastRenderedState = F;
      }
      return [F, R];
    }
    function W6(s, a, p) {
    }
    function X6(s, a, p) {
    }
    function Xx(s, a, p) {
      var v = Hn, S = Vo(), R, L = Or();
      if (L) {
        if (p === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        R = p(), id || R !== p() && (h("The result of getServerSnapshot should be cached to avoid an infinite loop"), id = !0);
      } else {
        if (R = a(), !id) {
          var F = a();
          Pi(R, F) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), id = !0);
        }
        var H = wg();
        if (H === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        wl(H, rd) || dT(v, a, R);
      }
      S.memoizedState = R;
      var Z = {
        value: R,
        getSnapshot: a
      };
      return S.queue = Z, up(pT.bind(null, v, Z, s), [s]), v.flags |= bn, op(si | Mr, hT.bind(null, v, Z, R, a), void 0, null), R;
    }
    function Iv(s, a, p) {
      var v = Hn, S = oo(), R = a();
      if (!id) {
        var L = a();
        Pi(R, L) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), id = !0);
      }
      var F = S.memoizedState, H = !Pi(F, R);
      H && (S.memoizedState = R, og());
      var Z = S.queue;
      if (tc(pT.bind(null, v, Z, s), [s]), Z.getSnapshot !== a || H || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Qi !== null && Qi.memoizedState.tag & si) {
        v.flags |= bn, op(si | Mr, hT.bind(null, v, Z, R, a), void 0, null);
        var te = wg();
        if (te === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        wl(te, rd) || dT(v, a, R);
      }
      return R;
    }
    function dT(s, a, p) {
      s.flags |= va;
      var v = {
        getSnapshot: a,
        value: p
      }, S = Hn.updateQueue;
      if (S === null)
        S = fT(), Hn.updateQueue = S, S.stores = [v];
      else {
        var R = S.stores;
        R === null ? S.stores = [v] : R.push(v);
      }
    }
    function hT(s, a, p, v) {
      a.value = p, a.getSnapshot = v, mT(a) && vT(s);
    }
    function pT(s, a, p) {
      var v = function() {
        mT(a) && vT(s);
      };
      return p(v);
    }
    function mT(s) {
      var a = s.getSnapshot, p = s.value;
      try {
        var v = a();
        return !Pi(p, v);
      } catch {
        return !0;
      }
    }
    function vT(s) {
      tr(s, ln, Fn);
    }
    function ap(s) {
      var a = Vo();
      typeof s == "function" && (s = s()), a.memoizedState = a.baseState = s;
      var p = {
        pending: null,
        interleaved: null,
        lanes: Ge,
        dispatch: null,
        lastRenderedReducer: Hx,
        lastRenderedState: s
      };
      a.queue = p;
      var v = p.dispatch = dN.bind(null, Hn, p);
      return [a.memoizedState, v];
    }
    function Fv(s) {
      return Gx(Hx);
    }
    function zv(s) {
      return Wx(Hx);
    }
    function op(s, a, p, v) {
      var S = {
        tag: s,
        create: a,
        destroy: p,
        deps: v,
        // Circular
        next: null
      }, R = Hn.updateQueue;
      if (R === null)
        R = fT(), Hn.updateQueue = R, R.lastEffect = S.next = S;
      else {
        var L = R.lastEffect;
        if (L === null)
          R.lastEffect = S.next = S;
        else {
          var F = L.next;
          L.next = S, S.next = F, R.lastEffect = S;
        }
      }
      return S;
    }
    function jx(s) {
      var a = Vo();
      {
        var p = {
          current: s
        };
        return a.memoizedState = p, p;
      }
    }
    function Bv(s) {
      var a = oo();
      return a.memoizedState;
    }
    function lp(s, a, p, v) {
      var S = Vo(), R = v === void 0 ? null : v;
      Hn.flags |= s, S.memoizedState = op(si | a, p, void 0, R);
    }
    function Vv(s, a, p, v) {
      var S = oo(), R = v === void 0 ? null : v, L = void 0;
      if (Ir !== null) {
        var F = Ir.memoizedState;
        if (L = F.destroy, R !== null) {
          var H = F.deps;
          if (Vx(R, H)) {
            S.memoizedState = op(a, p, L, R);
            return;
          }
        }
      }
      Hn.flags |= s, S.memoizedState = op(si | a, p, L, R);
    }
    function up(s, a) {
      return (Hn.mode & Cs) !== Yt ? lp(k | bn | xn, Mr, s, a) : lp(bn | xn, Mr, s, a);
    }
    function tc(s, a) {
      return Vv(bn, Mr, s, a);
    }
    function Yx(s, a) {
      return lp(Te, Wl, s, a);
    }
    function Hv(s, a) {
      return Vv(Te, Wl, s, a);
    }
    function qx(s, a) {
      var p = Te;
      return p |= Ft, (Hn.mode & Cs) !== Yt && (p |= hn), lp(p, Li, s, a);
    }
    function kv(s, a) {
      return Vv(Te, Li, s, a);
    }
    function gT(s, a) {
      if (typeof a == "function") {
        var p = a, v = s();
        return p(v), function() {
          p(null);
        };
      } else if (a != null) {
        var S = a;
        S.hasOwnProperty("current") || h("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(S).join(", ") + "}");
        var R = s();
        return S.current = R, function() {
          S.current = null;
        };
      }
    }
    function Zx(s, a, p) {
      typeof a != "function" && h("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var v = p != null ? p.concat([s]) : null, S = Te;
      return S |= Ft, (Hn.mode & Cs) !== Yt && (S |= hn), lp(S, Li, gT.bind(null, a, s), v);
    }
    function Gv(s, a, p) {
      typeof a != "function" && h("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var v = p != null ? p.concat([s]) : null;
      return Vv(Te, Li, gT.bind(null, a, s), v);
    }
    function lN(s, a) {
    }
    var Wv = lN;
    function Kx(s, a) {
      var p = Vo(), v = a === void 0 ? null : a;
      return p.memoizedState = [s, v], s;
    }
    function Xv(s, a) {
      var p = oo(), v = a === void 0 ? null : a, S = p.memoizedState;
      if (S !== null && v !== null) {
        var R = S[1];
        if (Vx(v, R))
          return S[0];
      }
      return p.memoizedState = [s, v], s;
    }
    function Jx(s, a) {
      var p = Vo(), v = a === void 0 ? null : a, S = s();
      return p.memoizedState = [S, v], S;
    }
    function jv(s, a) {
      var p = oo(), v = a === void 0 ? null : a, S = p.memoizedState;
      if (S !== null && v !== null) {
        var R = S[1];
        if (Vx(v, R))
          return S[0];
      }
      var L = s();
      return p.memoizedState = [L, v], L;
    }
    function Qx(s) {
      var a = ap(s), p = a[0], v = a[1];
      return up(function() {
        var S = gs.transition;
        gs.transition = {};
        try {
          v(s);
        } finally {
          gs.transition = S;
        }
      }, [s]), p;
    }
    function yT(s) {
      var a = Fv(), p = a[0], v = a[1];
      return tc(function() {
        var S = gs.transition;
        gs.transition = {};
        try {
          v(s);
        } finally {
          gs.transition = S;
        }
      }, [s]), p;
    }
    function xT(s) {
      var a = zv(), p = a[0], v = a[1];
      return tc(function() {
        var S = gs.transition;
        gs.transition = {};
        try {
          v(s);
        } finally {
          gs.transition = S;
        }
      }, [s]), p;
    }
    function uN(s, a, p) {
      var v = ms();
      Ai(zh(v, Uo)), s(!0);
      var S = gs.transition;
      gs.transition = {};
      var R = gs.transition;
      gs.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        s(!1), a();
      } finally {
        if (Ai(v), gs.transition = S, S === null && R._updatedFibers) {
          var L = R._updatedFibers.size;
          L > 10 && d("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), R._updatedFibers.clear();
        }
      }
    }
    function $x() {
      var s = ap(!1), a = s[0], p = s[1], v = uN.bind(null, p), S = Vo();
      return S.memoizedState = v, [a, v];
    }
    function _T() {
      var s = Fv(), a = s[0], p = oo(), v = p.memoizedState;
      return [a, v];
    }
    function ST() {
      var s = zv(), a = s[0], p = oo(), v = p.memoizedState;
      return [a, v];
    }
    var MT = !1;
    function cN() {
      return MT;
    }
    function e_() {
      var s = Vo(), a = wg(), p = a.identifierPrefix, v;
      if (Or()) {
        var S = V2();
        v = ":" + p + "R" + S;
        var R = sp++;
        R > 0 && (v += "H" + R.toString(32)), v += ":";
      } else {
        var L = sN++;
        v = ":" + p + "r" + L.toString(32) + ":";
      }
      return s.memoizedState = v, v;
    }
    function Yv() {
      var s = oo(), a = s.memoizedState;
      return a;
    }
    function fN(s, a, p) {
      typeof arguments[3] == "function" && h("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var v = ql(s), S = {
        lane: v,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (ET(s))
        bT(a, S);
      else {
        TT(s, a, S);
        var R = $r(), L = tr(s, v, R);
        L !== null && wT(L, a, v);
      }
      AT(s, v);
    }
    function dN(s, a, p) {
      typeof arguments[3] == "function" && h("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var v = ql(s), S = {
        lane: v,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (ET(s))
        bT(a, S);
      else {
        TT(s, a, S);
        var R = s.alternate;
        if (s.lanes === Ge && (R === null || R.lanes === Ge)) {
          var L = a.lastRenderedReducer;
          if (L !== null) {
            var F;
            F = St.current, St.current = La;
            try {
              var H = a.lastRenderedState, Z = L(H, p);
              if (S.hasEagerState = !0, S.eagerState = Z, Pi(Z, H))
                return;
            } catch {
            } finally {
              St.current = F;
            }
          }
        }
        var te = $r(), xe = tr(s, v, te);
        xe !== null && wT(xe, a, v);
      }
      AT(s, v);
    }
    function ET(s) {
      var a = s.alternate;
      return s === Hn || a !== null && a === Hn;
    }
    function bT(s, a) {
      rp = Ov = !0;
      var p = s.pending;
      p === null ? a.next = a : (a.next = p.next, p.next = a), s.pending = a;
    }
    function TT(s, a, p, v) {
      if (B1(s)) {
        var S = a.interleaved;
        S === null ? (p.next = p, Ce(a)) : (p.next = S.next, S.next = p), a.interleaved = p;
      } else {
        var R = a.pending;
        R === null ? p.next = p : (p.next = R.next, R.next = p), a.pending = p;
      }
    }
    function wT(s, a, p) {
      if (Fh(p)) {
        var v = a.lanes;
        v = $s(v, s.pendingLanes);
        var S = nn(v, p);
        a.lanes = S, zu(s, S);
      }
    }
    function AT(s, a, p) {
      Nl(s, a);
    }
    var qv = {
      readContext: X,
      useCallback: Fr,
      useContext: Fr,
      useEffect: Fr,
      useImperativeHandle: Fr,
      useInsertionEffect: Fr,
      useLayoutEffect: Fr,
      useMemo: Fr,
      useReducer: Fr,
      useRef: Fr,
      useState: Fr,
      useDebugValue: Fr,
      useDeferredValue: Fr,
      useTransition: Fr,
      useMutableSource: Fr,
      useSyncExternalStore: Fr,
      useId: Fr,
      unstable_isNewReconciler: E
    }, RT = null, CT = null, PT = null, LT = null, lo = null, La = null, Zv = null;
    {
      var t_ = function() {
        h("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Qt = function() {
        h("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      RT = {
        readContext: function(s) {
          return X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", Ln(), sd(a), Kx(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", Ln(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", Ln(), sd(a), up(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", Ln(), sd(p), Zx(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", Ln(), sd(a), Yx(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", Ln(), sd(a), qx(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", Ln(), sd(a);
          var p = St.current;
          St.current = lo;
          try {
            return Jx(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", Ln();
          var v = St.current;
          St.current = lo;
          try {
            return kx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", Ln(), jx(s);
        },
        useState: function(s) {
          Ue = "useState", Ln();
          var a = St.current;
          St.current = lo;
          try {
            return ap(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", Ln(), void 0;
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", Ln(), Qx(s);
        },
        useTransition: function() {
          return Ue = "useTransition", Ln(), $x();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", Ln(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", Ln(), Xx(s, a, p);
        },
        useId: function() {
          return Ue = "useId", Ln(), e_();
        },
        unstable_isNewReconciler: E
      }, CT = {
        readContext: function(s) {
          return X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", ct(), Kx(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", ct(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", ct(), up(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", ct(), Zx(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", ct(), Yx(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", ct(), qx(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", ct();
          var p = St.current;
          St.current = lo;
          try {
            return Jx(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", ct();
          var v = St.current;
          St.current = lo;
          try {
            return kx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", ct(), jx(s);
        },
        useState: function(s) {
          Ue = "useState", ct();
          var a = St.current;
          St.current = lo;
          try {
            return ap(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", ct(), void 0;
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", ct(), Qx(s);
        },
        useTransition: function() {
          return Ue = "useTransition", ct(), $x();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", ct(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", ct(), Xx(s, a, p);
        },
        useId: function() {
          return Ue = "useId", ct(), e_();
        },
        unstable_isNewReconciler: E
      }, PT = {
        readContext: function(s) {
          return X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", ct(), Xv(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", ct(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", ct(), tc(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", ct(), Gv(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", ct(), Hv(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", ct(), kv(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", ct();
          var p = St.current;
          St.current = La;
          try {
            return jv(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", ct();
          var v = St.current;
          St.current = La;
          try {
            return Gx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", ct(), Bv();
        },
        useState: function(s) {
          Ue = "useState", ct();
          var a = St.current;
          St.current = La;
          try {
            return Fv(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", ct(), Wv();
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", ct(), yT(s);
        },
        useTransition: function() {
          return Ue = "useTransition", ct(), _T();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", ct(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", ct(), Iv(s, a);
        },
        useId: function() {
          return Ue = "useId", ct(), Yv();
        },
        unstable_isNewReconciler: E
      }, LT = {
        readContext: function(s) {
          return X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", ct(), Xv(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", ct(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", ct(), tc(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", ct(), Gv(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", ct(), Hv(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", ct(), kv(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", ct();
          var p = St.current;
          St.current = Zv;
          try {
            return jv(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", ct();
          var v = St.current;
          St.current = Zv;
          try {
            return Wx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", ct(), Bv();
        },
        useState: function(s) {
          Ue = "useState", ct();
          var a = St.current;
          St.current = Zv;
          try {
            return zv(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", ct(), Wv();
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", ct(), xT(s);
        },
        useTransition: function() {
          return Ue = "useTransition", ct(), ST();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", ct(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", ct(), Iv(s, a);
        },
        useId: function() {
          return Ue = "useId", ct(), Yv();
        },
        unstable_isNewReconciler: E
      }, lo = {
        readContext: function(s) {
          return t_(), X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", Qt(), Ln(), Kx(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", Qt(), Ln(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", Qt(), Ln(), up(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", Qt(), Ln(), Zx(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", Qt(), Ln(), Yx(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", Qt(), Ln(), qx(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", Qt(), Ln();
          var p = St.current;
          St.current = lo;
          try {
            return Jx(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", Qt(), Ln();
          var v = St.current;
          St.current = lo;
          try {
            return kx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", Qt(), Ln(), jx(s);
        },
        useState: function(s) {
          Ue = "useState", Qt(), Ln();
          var a = St.current;
          St.current = lo;
          try {
            return ap(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", Qt(), Ln(), void 0;
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", Qt(), Ln(), Qx(s);
        },
        useTransition: function() {
          return Ue = "useTransition", Qt(), Ln(), $x();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", Qt(), Ln(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", Qt(), Ln(), Xx(s, a, p);
        },
        useId: function() {
          return Ue = "useId", Qt(), Ln(), e_();
        },
        unstable_isNewReconciler: E
      }, La = {
        readContext: function(s) {
          return t_(), X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", Qt(), ct(), Xv(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", Qt(), ct(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", Qt(), ct(), tc(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", Qt(), ct(), Gv(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", Qt(), ct(), Hv(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", Qt(), ct(), kv(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", Qt(), ct();
          var p = St.current;
          St.current = La;
          try {
            return jv(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", Qt(), ct();
          var v = St.current;
          St.current = La;
          try {
            return Gx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", Qt(), ct(), Bv();
        },
        useState: function(s) {
          Ue = "useState", Qt(), ct();
          var a = St.current;
          St.current = La;
          try {
            return Fv(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", Qt(), ct(), Wv();
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", Qt(), ct(), yT(s);
        },
        useTransition: function() {
          return Ue = "useTransition", Qt(), ct(), _T();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", Qt(), ct(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", Qt(), ct(), Iv(s, a);
        },
        useId: function() {
          return Ue = "useId", Qt(), ct(), Yv();
        },
        unstable_isNewReconciler: E
      }, Zv = {
        readContext: function(s) {
          return t_(), X(s);
        },
        useCallback: function(s, a) {
          return Ue = "useCallback", Qt(), ct(), Xv(s, a);
        },
        useContext: function(s) {
          return Ue = "useContext", Qt(), ct(), X(s);
        },
        useEffect: function(s, a) {
          return Ue = "useEffect", Qt(), ct(), tc(s, a);
        },
        useImperativeHandle: function(s, a, p) {
          return Ue = "useImperativeHandle", Qt(), ct(), Gv(s, a, p);
        },
        useInsertionEffect: function(s, a) {
          return Ue = "useInsertionEffect", Qt(), ct(), Hv(s, a);
        },
        useLayoutEffect: function(s, a) {
          return Ue = "useLayoutEffect", Qt(), ct(), kv(s, a);
        },
        useMemo: function(s, a) {
          Ue = "useMemo", Qt(), ct();
          var p = St.current;
          St.current = La;
          try {
            return jv(s, a);
          } finally {
            St.current = p;
          }
        },
        useReducer: function(s, a, p) {
          Ue = "useReducer", Qt(), ct();
          var v = St.current;
          St.current = La;
          try {
            return Wx(s, a, p);
          } finally {
            St.current = v;
          }
        },
        useRef: function(s) {
          return Ue = "useRef", Qt(), ct(), Bv();
        },
        useState: function(s) {
          Ue = "useState", Qt(), ct();
          var a = St.current;
          St.current = La;
          try {
            return zv(s);
          } finally {
            St.current = a;
          }
        },
        useDebugValue: function(s, a) {
          return Ue = "useDebugValue", Qt(), ct(), Wv();
        },
        useDeferredValue: function(s) {
          return Ue = "useDeferredValue", Qt(), ct(), xT(s);
        },
        useTransition: function() {
          return Ue = "useTransition", Qt(), ct(), ST();
        },
        useMutableSource: function(s, a, p) {
          return Ue = "useMutableSource", Qt(), ct(), void 0;
        },
        useSyncExternalStore: function(s, a, p) {
          return Ue = "useSyncExternalStore", Qt(), ct(), Iv(s, a);
        },
        useId: function() {
          return Ue = "useId", Qt(), ct(), Yv();
        },
        unstable_isNewReconciler: E
      };
    }
    var jl = r.unstable_now, DT = 0, Kv = -1, cp = -1, Jv = -1, n_ = !1, Qv = !1;
    function NT() {
      return n_;
    }
    function hN() {
      Qv = !0;
    }
    function pN() {
      n_ = !1, Qv = !1;
    }
    function mN() {
      n_ = Qv, Qv = !1;
    }
    function UT() {
      return DT;
    }
    function OT() {
      DT = jl();
    }
    function i_(s) {
      cp = jl(), s.actualStartTime < 0 && (s.actualStartTime = jl());
    }
    function IT(s) {
      cp = -1;
    }
    function $v(s, a) {
      if (cp >= 0) {
        var p = jl() - cp;
        s.actualDuration += p, a && (s.selfBaseDuration = p), cp = -1;
      }
    }
    function oa(s) {
      if (Kv >= 0) {
        var a = jl() - Kv;
        Kv = -1;
        for (var p = s.return; p !== null; ) {
          switch (p.tag) {
            case W:
              var v = p.stateNode;
              v.effectDuration += a;
              return;
            case Ee:
              var S = p.stateNode;
              S.effectDuration += a;
              return;
          }
          p = p.return;
        }
      }
    }
    function r_(s) {
      if (Jv >= 0) {
        var a = jl() - Jv;
        Jv = -1;
        for (var p = s.return; p !== null; ) {
          switch (p.tag) {
            case W:
              var v = p.stateNode;
              v !== null && (v.passiveEffectDuration += a);
              return;
            case Ee:
              var S = p.stateNode;
              S !== null && (S.passiveEffectDuration += a);
              return;
          }
          p = p.return;
        }
      }
    }
    function la() {
      Kv = jl();
    }
    function s_() {
      Jv = jl();
    }
    function a_(s) {
      for (var a = s.child; a; )
        s.actualDuration += a.actualDuration, a = a.sibling;
    }
    function eg(s, a) {
      return {
        value: s,
        source: a,
        stack: Jh(a)
      };
    }
    function vN(s, a) {
      return !0;
    }
    function o_(s, a) {
      try {
        var p = vN(s, a);
        if (p === !1)
          return;
        var v = a.value, S = a.source, R = a.stack, L = R !== null ? R : "";
        if (v != null && v._suppressLogging) {
          if (s.tag === I)
            return;
          console.error(v);
        }
        var F = S ? Y(S) : null, H = F ? "The above error occurred in the <" + F + "> component:" : "The above error occurred in one of your React components:", Z;
        if (s.tag === W)
          Z = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var te = Y(s) || "Anonymous";
          Z = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + te + ".");
        }
        var xe = H + `
` + L + `

` + ("" + Z);
        console.error(xe);
      } catch (we) {
        setTimeout(function() {
          throw we;
        });
      }
    }
    var gN = typeof WeakMap == "function" ? WeakMap : Map;
    function FT(s, a, p) {
      var v = be(Fn, p);
      v.tag = Nn, v.payload = {
        element: null
      };
      var S = a.value;
      return v.callback = function() {
        E3(S), o_(s, a);
      }, v;
    }
    function l_(s, a, p) {
      var v = be(Fn, p);
      v.tag = Nn;
      var S = s.type.getDerivedStateFromError;
      if (typeof S == "function") {
        var R = a.value;
        v.payload = function() {
          return S(R);
        }, v.callback = function() {
          iw(s), o_(s, a);
        };
      }
      var L = s.stateNode;
      return L !== null && typeof L.componentDidCatch == "function" && (v.callback = function() {
        iw(s), o_(s, a), typeof S != "function" && S3(this);
        var H = a.value, Z = a.stack;
        this.componentDidCatch(H, {
          componentStack: Z !== null ? Z : ""
        }), typeof S != "function" && (lr(s.lanes, ln) || h("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Y(s) || "Unknown"));
      }), v;
    }
    function zT(s, a, p) {
      var v = s.pingCache, S;
      if (v === null ? (v = s.pingCache = new gN(), S = /* @__PURE__ */ new Set(), v.set(a, S)) : (S = v.get(a), S === void 0 && (S = /* @__PURE__ */ new Set(), v.set(a, S))), !S.has(p)) {
        S.add(p);
        var R = b3.bind(null, s, a, p);
        Kr && wp(s, p), a.then(R, R);
      }
    }
    function yN(s, a, p, v) {
      var S = s.updateQueue;
      if (S === null) {
        var R = /* @__PURE__ */ new Set();
        R.add(p), s.updateQueue = R;
      } else
        S.add(p);
    }
    function xN(s, a) {
      var p = s.tag;
      if ((s.mode & Rn) === Yt && (p === z || p === ie || p === re)) {
        var v = s.alternate;
        v ? (s.updateQueue = v.updateQueue, s.memoizedState = v.memoizedState, s.lanes = v.lanes) : (s.updateQueue = null, s.memoizedState = null);
      }
    }
    function BT(s) {
      var a = s;
      do {
        if (a.tag === Q && iN(a))
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function VT(s, a, p, v, S) {
      if ((s.mode & Rn) === Yt) {
        if (s === a)
          s.flags |= Zn;
        else {
          if (s.flags |= Ye, p.flags |= $, p.flags &= -52805, p.tag === I) {
            var R = p.alternate;
            if (R === null)
              p.tag = Le;
            else {
              var L = be(Fn, ln);
              L.tag = Bt, ut(p, L);
            }
          }
          p.lanes = nn(p.lanes, ln);
        }
        return s;
      }
      return s.flags |= Zn, s.lanes = S, s;
    }
    function _N(s, a, p, v, S) {
      if (p.flags |= ws, Kr && wp(s, S), v !== null && typeof v == "object" && typeof v.then == "function") {
        var R = v;
        xN(p);
        var L = BT(a);
        if (L !== null) {
          L.flags &= ~qt, VT(L, a, p, s, S), L.mode & Rn && zT(s, R, S), yN(L, s, R);
          return;
        } else {
          if (!uv(S)) {
            zT(s, R, S), H_();
            return;
          }
          var F = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          v = F;
        }
      } else if (Or() && p.mode & Rn) {
        X2();
        var H = BT(a);
        if (H !== null) {
          (H.flags & Zn) === he && (H.flags |= qt), VT(H, a, p, s, S), Tx(v);
          return;
        }
      }
      h3(v), v = eg(v, p);
      var Z = a;
      do {
        switch (Z.tag) {
          case W: {
            var te = v;
            Z.flags |= Zn;
            var xe = Do(S);
            Z.lanes = nn(Z.lanes, xe);
            var we = FT(Z, te, xe);
            sn(Z, we);
            return;
          }
          case I:
            var De = v, We = Z.type, Je = Z.stateNode;
            if ((Z.flags & Ye) === he && (typeof We.getDerivedStateFromError == "function" || Je !== null && typeof Je.componentDidCatch == "function" && !q1(Je))) {
              Z.flags |= Zn;
              var Vt = Do(S);
              Z.lanes = nn(Z.lanes, Vt);
              var an = l_(Z, De, Vt);
              sn(Z, an);
              return;
            }
            break;
        }
        Z = Z.return;
      } while (Z !== null);
    }
    function SN() {
      return null;
    }
    function uo(s) {
      s.flags |= Te;
    }
    function HT(s) {
      s.flags |= tn, s.flags |= vt;
    }
    function kT(s, a) {
      var p = s !== null && s.child === a.child;
      if (p)
        return !0;
      if ((a.flags & Ke) !== he)
        return !1;
      for (var v = a.child; v !== null; ) {
        if ((v.flags & ge) !== he || (v.subtreeFlags & ge) !== he)
          return !1;
        v = v.sibling;
      }
      return !0;
    }
    var fp, dp, tg, ng;
    if (Cr)
      fp = function(s, a, p, v) {
        for (var S = a.child; S !== null; ) {
          if (S.tag === O || S.tag === q)
            Kn(s, S.stateNode);
          else if (S.tag !== U) {
            if (S.child !== null) {
              S.child.return = S, S = S.child;
              continue;
            }
          }
          if (S === a)
            return;
          for (; S.sibling === null; ) {
            if (S.return === null || S.return === a)
              return;
            S = S.return;
          }
          S.sibling.return = S.return, S = S.sibling;
        }
      }, dp = function(s, a) {
      }, tg = function(s, a, p, v, S) {
        var R = s.memoizedProps;
        if (R !== v) {
          var L = a.stateNode, F = np(), H = Eo(L, p, R, v, S, F);
          a.updateQueue = H, H && uo(a);
        }
      }, ng = function(s, a, p, v) {
        p !== v && uo(a);
      };
    else if (Xa) {
      fp = function(s, a, p, v) {
        for (var S = a.child; S !== null; ) {
          if (S.tag === O) {
            var R = S.stateNode;
            if (p && v) {
              var L = S.memoizedProps, F = S.type;
              R = Cu(R, F, L, S);
            }
            Kn(s, R);
          } else if (S.tag === q) {
            var H = S.stateNode;
            if (p && v) {
              var Z = S.memoizedProps;
              H = To(H, Z, S);
            }
            Kn(s, H);
          } else if (S.tag !== U) {
            if (S.tag === je && S.memoizedState !== null) {
              var te = S.child;
              te !== null && (te.return = S), fp(s, S, !0, !0);
            } else if (S.child !== null) {
              S.child.return = S, S = S.child;
              continue;
            }
          }
          if (S = S, S === a)
            return;
          for (; S.sibling === null; ) {
            if (S.return === null || S.return === a)
              return;
            S = S.return;
          }
          S.sibling.return = S.return, S = S.sibling;
        }
      };
      var GT = function(s, a, p, v) {
        for (var S = a.child; S !== null; ) {
          if (S.tag === O) {
            var R = S.stateNode;
            if (p && v) {
              var L = S.memoizedProps, F = S.type;
              R = Cu(R, F, L, S);
            }
            Zm(s, R);
          } else if (S.tag === q) {
            var H = S.stateNode;
            if (p && v) {
              var Z = S.memoizedProps;
              H = To(H, Z, S);
            }
            Zm(s, H);
          } else if (S.tag !== U) {
            if (S.tag === je && S.memoizedState !== null) {
              var te = S.child;
              te !== null && (te.return = S), GT(s, S, !0, !0);
            } else if (S.child !== null) {
              S.child.return = S, S = S.child;
              continue;
            }
          }
          if (S = S, S === a)
            return;
          for (; S.sibling === null; ) {
            if (S.return === null || S.return === a)
              return;
            S = S.return;
          }
          S.sibling.return = S.return, S = S.sibling;
        }
      };
      dp = function(s, a) {
        var p = a.stateNode, v = kT(s, a);
        if (!v) {
          var S = p.containerInfo, R = Au(S);
          GT(R, a, !1, !1), p.pendingChildren = R, uo(a), Rs(S, R);
        }
      }, tg = function(s, a, p, v, S) {
        var R = s.stateNode, L = s.memoizedProps, F = kT(s, a);
        if (F && L === v) {
          a.stateNode = R;
          return;
        }
        var H = a.stateNode, Z = np(), te = null;
        if (L !== v && (te = Eo(H, p, L, v, S, Z)), F && te === null) {
          a.stateNode = R;
          return;
        }
        var xe = ex(R, te, p, L, v, a, F, H);
        As(xe, p, v, S, Z) && uo(a), a.stateNode = xe, F ? uo(a) : fp(xe, a, !1, !1);
      }, ng = function(s, a, p, v) {
        if (p !== v) {
          var S = Lx(), R = np();
          a.stateNode = bo(v, S, R, a), uo(a);
        } else
          a.stateNode = s.stateNode;
      };
    } else
      dp = function(s, a) {
      }, tg = function(s, a, p, v, S) {
      }, ng = function(s, a, p, v) {
      };
    function hp(s, a) {
      if (!Or())
        switch (s.tailMode) {
          case "hidden": {
            for (var p = s.tail, v = null; p !== null; )
              p.alternate !== null && (v = p), p = p.sibling;
            v === null ? s.tail = null : v.sibling = null;
            break;
          }
          case "collapsed": {
            for (var S = s.tail, R = null; S !== null; )
              S.alternate !== null && (R = S), S = S.sibling;
            R === null ? !a && s.tail !== null ? s.tail.sibling = null : s.tail = null : R.sibling = null;
            break;
          }
        }
    }
    function Er(s) {
      var a = s.alternate !== null && s.alternate.child === s.child, p = Ge, v = he;
      if (a) {
        if ((s.mode & Tn) !== Yt) {
          for (var H = s.selfBaseDuration, Z = s.child; Z !== null; )
            p = nn(p, nn(Z.lanes, Z.childLanes)), v |= Z.subtreeFlags & Qe, v |= Z.flags & Qe, H += Z.treeBaseDuration, Z = Z.sibling;
          s.treeBaseDuration = H;
        } else
          for (var te = s.child; te !== null; )
            p = nn(p, nn(te.lanes, te.childLanes)), v |= te.subtreeFlags & Qe, v |= te.flags & Qe, te.return = s, te = te.sibling;
        s.subtreeFlags |= v;
      } else {
        if ((s.mode & Tn) !== Yt) {
          for (var S = s.actualDuration, R = s.selfBaseDuration, L = s.child; L !== null; )
            p = nn(p, nn(L.lanes, L.childLanes)), v |= L.subtreeFlags, v |= L.flags, S += L.actualDuration, R += L.treeBaseDuration, L = L.sibling;
          s.actualDuration = S, s.treeBaseDuration = R;
        } else
          for (var F = s.child; F !== null; )
            p = nn(p, nn(F.lanes, F.childLanes)), v |= F.subtreeFlags, v |= F.flags, F.return = s, F = F.sibling;
        s.subtreeFlags |= v;
      }
      return s.childLanes = p, a;
    }
    function WT(s, a, p) {
      var v = a.pendingProps;
      switch (_x(a), a.tag) {
        case V:
        case ue:
        case re:
        case z:
        case ie:
        case le:
        case ye:
        case Ee:
        case K:
        case se:
          return Er(a), null;
        case I: {
          var S = a.type;
          return Dr(S) && Ja(a), Er(a), null;
        }
        case W: {
          var R = a.stateNode;
          if (ed(a), wh(a), Fx(), R.pendingContext && (R.context = R.pendingContext, R.pendingContext = null), s === null || s.child === null) {
            var L = Qh(a);
            if (L)
              uo(a);
            else if (s !== null) {
              var F = s.memoizedState;
              // Check if this is a client root
              (!F.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (a.flags & qt) !== he) && (a.flags |= Sn, tT());
            }
          }
          return dp(s, a), Er(a), null;
        }
        case O: {
          Nx(a);
          var H = Lx(), Z = a.type;
          if (s !== null && a.stateNode != null)
            tg(s, a, Z, v, H), s.ref !== a.ref && HT(a);
          else {
            if (!v) {
              if (a.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Er(a), null;
            }
            var te = np(), xe = Qh(a);
            if (xe)
              q2(a, H, te) && uo(a);
            else {
              var we = Bi(Z, v, H, te, a);
              fp(we, a, !1, !1), a.stateNode = we, As(we, Z, v, H, te) && uo(a);
            }
            a.ref !== null && HT(a);
          }
          return Er(a), null;
        }
        case q: {
          var De = v;
          if (s && a.stateNode != null) {
            var We = s.memoizedProps;
            ng(s, a, We, De);
          } else {
            if (typeof De != "string" && a.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Je = Lx(), Vt = np(), an = Qh(a);
            an ? Z2(a) && uo(a) : a.stateNode = bo(De, Je, Vt, a);
          }
          return Er(a), null;
        }
        case Q: {
          nd(a);
          var kt = a.memoizedState;
          {
            if (Q2() && (a.mode & Rn) !== Yt && (a.flags & Ye) === he)
              return eT(a), Qf(), a.flags |= qt | ws | Zn, a;
            if (kt !== null && kt.dehydrated !== null) {
              var Qn = Qh(a);
              if (s === null) {
                if (!Qn)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (K2(a), Er(a), (a.mode & Tn) !== Yt) {
                  var $n = kt !== null;
                  if ($n) {
                    var Me = a.child;
                    Me !== null && (a.treeBaseDuration -= Me.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (Qf(), (a.flags & Ye) === he && (a.memoizedState = null), a.flags |= Te, Er(a), (a.mode & Tn) !== Yt) {
                  var Ne = kt !== null;
                  if (Ne) {
                    var _e = a.child;
                    _e !== null && (a.treeBaseDuration -= _e.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            tT();
          }
          if ((a.flags & Ye) !== he)
            return a.lanes = p, (a.mode & Tn) !== Yt && a_(a), a;
          var tt = kt !== null, It = !1;
          if (s === null)
            Qh(a);
          else {
            var Et = s.memoizedState;
            It = Et !== null;
          }
          if (tt && !It) {
            var En = a.child;
            if (En.flags |= hi, (a.mode & Rn) !== Yt) {
              var Un = s === null && (a.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              Un || Ux(Pa.current, lT) ? d3() : H_();
            }
          }
          var Xn = a.updateQueue;
          if (Xn !== null && (a.flags |= Te), Er(a), (a.mode & Tn) !== Yt && tt) {
            var On = a.child;
            On !== null && (a.treeBaseDuration -= On.treeBaseDuration);
          }
          return null;
        }
        case U:
          return ed(a), dp(s, a), s === null && X0(a.stateNode.containerInfo), Er(a), null;
        case oe:
          var li = a.type._context;
          return f(li, a), Er(a), null;
        case Le: {
          var Cn = a.type;
          return Dr(Cn) && Ja(a), Er(a), null;
        }
        case Ae: {
          nd(a);
          var yn = a.memoizedState;
          if (yn === null)
            return Er(a), null;
          var Di = (a.flags & Ye) !== he, ui = yn.rendering;
          if (ui === null)
            if (Di)
              hp(yn, !1);
            else {
              var fa = p3() && (s === null || (s.flags & Ye) === he);
              if (!fa)
                for (var wr = a.child; wr !== null; ) {
                  var Os = Uv(wr);
                  if (Os !== null) {
                    Di = !0, a.flags |= Ye, hp(yn, !1);
                    var Is = Os.updateQueue;
                    return Is !== null && (a.updateQueue = Is, a.flags |= Te), a.subtreeFlags = he, eN(a, p), Gl(a, Ox(Pa.current, ip)), a.child;
                  }
                  wr = wr.sibling;
                }
              yn.tail !== null && Ri() > z1() && (a.flags |= Ye, Di = !0, hp(yn, !1), a.lanes = Oh);
            }
          else {
            if (!Di) {
              var ho = Uv(ui);
              if (ho !== null) {
                a.flags |= Ye, Di = !0;
                var pd = ho.updateQueue;
                if (pd !== null && (a.updateQueue = pd, a.flags |= Te), hp(yn, !0), yn.tail === null && yn.tailMode === "hidden" && !ui.alternate && !Or())
                  return Er(a), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Ri() * 2 - yn.renderingStartTime > z1() && p !== or && (a.flags |= Ye, Di = !0, hp(yn, !1), a.lanes = Oh);
            }
            if (yn.isBackwards)
              ui.sibling = a.child, a.child = ui;
            else {
              var md = yn.last;
              md !== null ? md.sibling = ui : a.child = ui, yn.last = ui;
            }
          }
          if (yn.tail !== null) {
            var Fs = yn.tail;
            yn.rendering = Fs, yn.tail = Fs.sibling, yn.renderingStartTime = Ri(), Fs.sibling = null;
            var lc = Pa.current;
            return Di ? lc = Ox(lc, ip) : lc = td(lc), Gl(a, lc), Fs;
          }
          return Er(a), null;
        }
        case qe:
          break;
        case je:
        case $e: {
          V_(a);
          var sS = a.memoizedState, Pw = sS !== null;
          if (s !== null) {
            var dO = s.memoizedState, hO = dO !== null;
            hO !== Pw && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !T && (a.flags |= hi);
          }
          return !Pw || (a.mode & Rn) === Yt ? Er(a) : lr(co, or) && (Er(a), Cr && a.subtreeFlags & (Ve | Te) && (a.flags |= hi)), null;
        }
        case Rt:
          return null;
        case Ut:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var pp = o.ReactCurrentOwner, Da = !1, u_, mp, c_, f_, d_, nc, h_, ig;
    u_ = {}, mp = {}, c_ = {}, f_ = {}, d_ = {}, nc = !1, h_ = {}, ig = {};
    function Qr(s, a, p, v) {
      s === null ? a.child = sT(a, null, p, v) : a.child = $f(a, s.child, p, v);
    }
    function MN(s, a, p, v) {
      a.child = $f(a, s.child, null, v), a.child = $f(a, null, p, v);
    }
    function XT(s, a, p, v, S) {
      if (a.type !== a.elementType) {
        var R = p.propTypes;
        R && pi(
          R,
          v,
          // Resolved props
          "prop",
          Xe(p)
        );
      }
      var L = p.render, F = a.ref, H, Z;
      D(a, S), Zi(a);
      {
        if (pp.current = a, na(!0), H = ad(s, a, L, v, F, S), Z = od(), a.mode & ii) {
          mn(!0);
          try {
            H = ad(s, a, L, v, F, S), Z = od();
          } finally {
            mn(!1);
          }
        }
        na(!1);
      }
      return Ds(), s !== null && !Da ? (uT(s, a, S), Ho(s, a, S)) : (Or() && Z && xx(a), a.flags |= Ze, Qr(s, a, H, S), a.child);
    }
    function jT(s, a, p, v, S) {
      if (s === null) {
        var R = p.type;
        if (H3(R) && p.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        p.defaultProps === void 0) {
          var L = R;
          return L = hd(R), a.tag = re, a.type = L, v_(a, R), YT(s, a, L, v, S);
        }
        {
          var F = R.propTypes;
          F && pi(
            F,
            v,
            // Resolved props
            "prop",
            Xe(R)
          );
        }
        var H = J_(p.type, null, v, a, a.mode, S);
        return H.ref = a.ref, H.return = a, a.child = H, H;
      }
      {
        var Z = p.type, te = Z.propTypes;
        te && pi(
          te,
          v,
          // Resolved props
          "prop",
          Xe(Z)
        );
      }
      var xe = s.child, we = __(s, S);
      if (!we) {
        var De = xe.memoizedProps, We = p.compare;
        if (We = We !== null ? We : ta, We(De, v) && s.ref === a.ref)
          return Ho(s, a, S);
      }
      a.flags |= Ze;
      var Je = oc(xe, v);
      return Je.ref = a.ref, Je.return = a, a.child = Je, Je;
    }
    function YT(s, a, p, v, S) {
      if (a.type !== a.elementType) {
        var R = a.elementType;
        if (R.$$typeof === ce) {
          var L = R, F = L._payload, H = L._init;
          try {
            R = H(F);
          } catch {
            R = null;
          }
          var Z = R && R.propTypes;
          Z && pi(
            Z,
            v,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Xe(R)
          );
        }
      }
      if (s !== null) {
        var te = s.memoizedProps;
        if (ta(te, v) && s.ref === a.ref && // Prevent bailout if the implementation changed due to hot reload.
        a.type === s.type)
          if (Da = !1, __(s, S))
            (s.flags & $) !== he && (Da = !0);
          else return a.lanes = s.lanes, Ho(s, a, S);
      }
      return p_(s, a, p, v, S);
    }
    function qT(s, a, p) {
      var v = a.pendingProps, S = v.children, R = s !== null ? s.memoizedState : null;
      if (v.mode === "hidden" || T)
        if ((a.mode & Rn) === Yt) {
          var L = {
            baseLanes: Ge,
            cachePool: null
          };
          a.memoizedState = L, Cg(a, p);
        } else if (lr(p, or)) {
          var xe = {
            baseLanes: Ge,
            cachePool: null
          };
          a.memoizedState = xe;
          var we = R !== null ? R.baseLanes : p;
          Cg(a, we);
        } else {
          var F = null, H;
          if (R !== null) {
            var Z = R.baseLanes;
            H = nn(Z, p);
          } else
            H = p;
          a.lanes = a.childLanes = or;
          var te = {
            baseLanes: H,
            cachePool: F
          };
          return a.memoizedState = te, a.updateQueue = null, Cg(a, H), null;
        }
      else {
        var De;
        R !== null ? (De = nn(R.baseLanes, p), a.memoizedState = null) : De = p, Cg(a, De);
      }
      return Qr(s, a, S, p), a.child;
    }
    function EN(s, a, p) {
      var v = a.pendingProps;
      return Qr(s, a, v, p), a.child;
    }
    function bN(s, a, p) {
      var v = a.pendingProps.children;
      return Qr(s, a, v, p), a.child;
    }
    function TN(s, a, p) {
      {
        a.flags |= Te;
        {
          var v = a.stateNode;
          v.effectDuration = 0, v.passiveEffectDuration = 0;
        }
      }
      var S = a.pendingProps, R = S.children;
      return Qr(s, a, R, p), a.child;
    }
    function ZT(s, a) {
      var p = a.ref;
      (s === null && p !== null || s !== null && s.ref !== p) && (a.flags |= tn, a.flags |= vt);
    }
    function p_(s, a, p, v, S) {
      if (a.type !== a.elementType) {
        var R = p.propTypes;
        R && pi(
          R,
          v,
          // Resolved props
          "prop",
          Xe(p)
        );
      }
      var L;
      {
        var F = In(a, p, !0);
        L = Jn(a, F);
      }
      var H, Z;
      D(a, S), Zi(a);
      {
        if (pp.current = a, na(!0), H = ad(s, a, p, v, L, S), Z = od(), a.mode & ii) {
          mn(!0);
          try {
            H = ad(s, a, p, v, L, S), Z = od();
          } finally {
            mn(!1);
          }
        }
        na(!1);
      }
      return Ds(), s !== null && !Da ? (uT(s, a, S), Ho(s, a, S)) : (Or() && Z && xx(a), a.flags |= Ze, Qr(s, a, H, S), a.child);
    }
    function KT(s, a, p, v, S) {
      {
        switch (dw(a)) {
          case !1: {
            var R = a.stateNode, L = a.type, F = new L(a.memoizedProps, R.context), H = F.state;
            R.updater.enqueueSetState(R, H, null);
            break;
          }
          case !0: {
            a.flags |= Ye, a.flags |= Zn;
            var Z = new Error("Simulated error coming from DevTools"), te = Do(S);
            a.lanes = nn(a.lanes, te);
            var xe = l_(a, eg(Z, a), te);
            sn(a, xe);
            break;
          }
        }
        if (a.type !== a.elementType) {
          var we = p.propTypes;
          we && pi(
            we,
            v,
            // Resolved props
            "prop",
            Xe(p)
          );
        }
      }
      var De;
      Dr(p) ? (De = !0, Sl(a)) : De = !1, D(a, S);
      var We = a.stateNode, Je;
      We === null ? (s !== null && (s.alternate = null, a.alternate = null, a.flags |= Ve), jb(a, p, v), yx(a, p, v, S), Je = !0) : s === null ? Je = I2(a, p, v, S) : Je = F2(s, a, p, v, S);
      var Vt = m_(s, a, p, Je, De, S);
      {
        var an = a.stateNode;
        Je && an.props !== v && (nc || h("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Y(a) || "a component"), nc = !0);
      }
      return Vt;
    }
    function m_(s, a, p, v, S, R) {
      ZT(s, a);
      var L = (a.flags & Ye) !== he;
      if (!v && !L)
        return S && hf(a, p, !1), Ho(s, a, R);
      var F = a.stateNode;
      pp.current = a;
      var H;
      if (L && typeof p.getDerivedStateFromError != "function")
        H = null, IT();
      else {
        Zi(a);
        {
          if (na(!0), H = F.render(), a.mode & ii) {
            mn(!0);
            try {
              F.render();
            } finally {
              mn(!1);
            }
          }
          na(!1);
        }
        Ds();
      }
      return a.flags |= Ze, s !== null && L ? MN(s, a, H, R) : Qr(s, a, H, R), a.memoizedState = F.state, S && hf(a, p, !0), a.child;
    }
    function JT(s) {
      var a = s.stateNode;
      a.pendingContext ? qi(s, a.pendingContext, a.pendingContext !== a.context) : a.context && qi(s, a.context, !1), Dx(s, a.containerInfo);
    }
    function wN(s, a, p) {
      if (JT(a), s === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var v = a.pendingProps, S = a.memoizedState, R = S.element;
      fe(s, a), Mn(a, v, null, p);
      var L = a.memoizedState;
      a.stateNode;
      var F = L.element;
      if (ar && S.isDehydrated) {
        var H = {
          element: F,
          isDehydrated: !1,
          cache: L.cache,
          transitions: L.transitions
        }, Z = a.updateQueue;
        if (Z.baseState = H, a.memoizedState = H, a.flags & qt) {
          var te = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return QT(s, a, F, p, te);
        } else if (F !== R) {
          var xe = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return QT(s, a, F, p, xe);
        } else {
          j2(a);
          var we = sT(a, null, F, p);
          a.child = we;
          for (var De = we; De; )
            De.flags = De.flags & ~Ve | Jt, De = De.sibling;
        }
      } else {
        if (Qf(), F === R)
          return Ho(s, a, p);
        Qr(s, a, F, p);
      }
      return a.child;
    }
    function QT(s, a, p, v, S) {
      return Qf(), Tx(S), a.flags |= qt, Qr(s, a, p, v), a.child;
    }
    function AN(s, a, p) {
      aT(a), s === null && bx(a);
      var v = a.type, S = a.pendingProps, R = s !== null ? s.memoizedProps : null, L = S.children, F = Ti(v, S);
      return F ? L = null : R !== null && Ti(v, R) && (a.flags |= st), ZT(s, a), Qr(s, a, L, p), a.child;
    }
    function RN(s, a) {
      return s === null && bx(a), null;
    }
    function CN(s, a, p, v) {
      s !== null && (s.alternate = null, a.alternate = null, a.flags |= Ve);
      var S = a.pendingProps, R = p, L = R._payload, F = R._init, H = F(L);
      a.type = H;
      var Z = a.tag = k3(H), te = Jr(H, S), xe;
      switch (Z) {
        case z:
          return v_(a, H), a.type = H = hd(H), xe = p_(null, a, H, te, v), xe;
        case I:
          return a.type = H = X_(H), xe = KT(null, a, H, te, v), xe;
        case ie:
          return a.type = H = j_(H), xe = XT(null, a, H, te, v), xe;
        case se: {
          if (a.type !== a.elementType) {
            var we = H.propTypes;
            we && pi(
              we,
              te,
              // Resolved for outer only
              "prop",
              Xe(H)
            );
          }
          return xe = jT(
            null,
            a,
            H,
            Jr(H.type, te),
            // The inner type can have defaults too
            v
          ), xe;
        }
      }
      var De = "";
      throw H !== null && typeof H == "object" && H.$$typeof === ce && (De = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + H + ". " + ("Lazy element type must resolve to a class or function." + De));
    }
    function PN(s, a, p, v, S) {
      s !== null && (s.alternate = null, a.alternate = null, a.flags |= Ve), a.tag = I;
      var R;
      return Dr(p) ? (R = !0, Sl(a)) : R = !1, D(a, S), jb(a, p, v), yx(a, p, v, S), m_(null, a, p, !0, R, S);
    }
    function LN(s, a, p, v) {
      s !== null && (s.alternate = null, a.alternate = null, a.flags |= Ve);
      var S = a.pendingProps, R;
      {
        var L = In(a, p, !1);
        R = Jn(a, L);
      }
      D(a, v);
      var F, H;
      Zi(a);
      {
        if (p.prototype && typeof p.prototype.render == "function") {
          var Z = Xe(p) || "Unknown";
          u_[Z] || (h("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Z, Z), u_[Z] = !0);
        }
        a.mode & ii && Ji.recordLegacyContextWarning(a, null), na(!0), pp.current = a, F = ad(null, a, p, S, R, v), H = od(), na(!1);
      }
      if (Ds(), a.flags |= Ze, typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0) {
        var te = Xe(p) || "Unknown";
        mp[te] || (h("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", te, te, te), mp[te] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0
      ) {
        {
          var xe = Xe(p) || "Unknown";
          mp[xe] || (h("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", xe, xe, xe), mp[xe] = !0);
        }
        a.tag = I, a.memoizedState = null, a.updateQueue = null;
        var we = !1;
        return Dr(p) ? (we = !0, Sl(a)) : we = !1, a.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null, Se(a), Xb(a, F), yx(a, p, S, v), m_(null, a, p, !0, we, v);
      } else {
        if (a.tag = z, a.mode & ii) {
          mn(!0);
          try {
            F = ad(null, a, p, S, R, v), H = od();
          } finally {
            mn(!1);
          }
        }
        return Or() && H && xx(a), Qr(null, a, F, v), v_(a, p), a.child;
      }
    }
    function v_(s, a) {
      {
        if (a && a.childContextTypes && h("%s(...): childContextTypes cannot be defined on a function component.", a.displayName || a.name || "Component"), s.ref !== null) {
          var p = "", v = ax();
          v && (p += `

Check the render method of \`` + v + "`.");
          var S = v || "", R = s._debugSource;
          R && (S = R.fileName + ":" + R.lineNumber), d_[S] || (d_[S] = !0, h("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", p));
        }
        if (typeof a.getDerivedStateFromProps == "function") {
          var L = Xe(a) || "Unknown";
          f_[L] || (h("%s: Function components do not support getDerivedStateFromProps.", L), f_[L] = !0);
        }
        if (typeof a.contextType == "object" && a.contextType !== null) {
          var F = Xe(a) || "Unknown";
          c_[F] || (h("%s: Function components do not support contextType.", F), c_[F] = !0);
        }
      }
    }
    var rg = {
      dehydrated: null,
      treeContext: null,
      retryLane: ri
    };
    function sg(s) {
      return {
        baseLanes: s,
        cachePool: SN()
      };
    }
    function $T(s, a) {
      var p = null;
      return {
        baseLanes: nn(s.baseLanes, a),
        cachePool: p
      };
    }
    function DN(s, a, p, v) {
      if (a !== null) {
        var S = a.memoizedState;
        if (S === null)
          return !1;
      }
      return Ux(s, ip);
    }
    function e1(s, a) {
      return Fu(s.childLanes, a);
    }
    function t1(s, a, p) {
      var v = a.pendingProps;
      pw(a) && (a.flags |= Ye);
      var S = Pa.current, R = !1, L = (a.flags & Ye) !== he;
      if (L || DN(S, s) ? (R = !0, a.flags &= ~Ye) : (s === null || s.memoizedState !== null) && (S = nN(S, lT)), S = td(S), Gl(a, S), s === null) {
        bx(a);
        {
          var F = a.memoizedState;
          if (F !== null) {
            var H = F.dehydrated;
            if (H !== null)
              return ON(a, H);
          }
        }
        var Z = v.children, te = v.fallback;
        if (R) {
          var xe = NN(a, Z, te, p), we = a.child;
          return we.memoizedState = sg(p), a.memoizedState = rg, xe;
        } else
          return g_(a, Z);
      } else {
        var De = s.memoizedState;
        if (De !== null) {
          {
            var We = De.dehydrated;
            if (We !== null)
              if (L) {
                if (a.flags & qt)
                  return a.flags &= ~qt, ag(s, a, p, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (a.memoizedState !== null)
                  return a.child = s.child, a.flags |= Ye, null;
                var Je = v.children, Vt = v.fallback, an = UN(s, a, Je, Vt, p), kt = a.child;
                return kt.memoizedState = sg(p), a.memoizedState = rg, an;
              } else return IN(s, a, We, De, p);
          }
          if (R) {
            var Qn = v.fallback, $n = v.children, Me = r1(s, a, $n, Qn, p), Ne = a.child, _e = s.child.memoizedState;
            return Ne.memoizedState = _e === null ? sg(p) : $T(_e, p), Ne.childLanes = e1(s, p), a.memoizedState = rg, Me;
          } else {
            var tt = v.children, It = i1(s, a, tt, p);
            return a.memoizedState = null, It;
          }
        } else if (R) {
          var Et = v.fallback, En = v.children, Un = r1(s, a, En, Et, p), Xn = a.child, On = s.child.memoizedState;
          return Xn.memoizedState = On === null ? sg(p) : $T(On, p), Xn.childLanes = e1(s, p), a.memoizedState = rg, Un;
        } else {
          var li = v.children, Cn = i1(s, a, li, p);
          return a.memoizedState = null, Cn;
        }
      }
    }
    function g_(s, a, p) {
      var v = s.mode, S = {
        mode: "visible",
        children: a
      }, R = y_(S, v);
      return R.return = s, s.child = R, R;
    }
    function NN(s, a, p, v) {
      var S = s.mode, R = s.child, L = {
        mode: "hidden",
        children: a
      }, F, H;
      return (S & Rn) === Yt && R !== null ? (F = R, F.childLanes = Ge, F.pendingProps = L, s.mode & Tn && (F.actualDuration = 0, F.actualStartTime = -1, F.selfBaseDuration = 0, F.treeBaseDuration = 0), H = Kl(p, S, v, null)) : (F = y_(L, S), H = Kl(p, S, v, null)), F.return = s, H.return = s, F.sibling = H, s.child = F, H;
    }
    function y_(s, a, p) {
      return sw(s, a, Ge, null);
    }
    function n1(s, a) {
      return oc(s, a);
    }
    function i1(s, a, p, v) {
      var S = s.child, R = S.sibling, L = n1(S, {
        mode: "visible",
        children: p
      });
      if ((a.mode & Rn) === Yt && (L.lanes = v), L.return = a, L.sibling = null, R !== null) {
        var F = a.deletions;
        F === null ? (a.deletions = [R], a.flags |= Ke) : F.push(R);
      }
      return a.child = L, L;
    }
    function r1(s, a, p, v, S) {
      var R = a.mode, L = s.child, F = L.sibling, H = {
        mode: "hidden",
        children: p
      }, Z;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (R & Rn) === Yt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        a.child !== L
      ) {
        var te = a.child;
        Z = te, Z.childLanes = Ge, Z.pendingProps = H, a.mode & Tn && (Z.actualDuration = 0, Z.actualStartTime = -1, Z.selfBaseDuration = L.selfBaseDuration, Z.treeBaseDuration = L.treeBaseDuration), a.deletions = null;
      } else
        Z = n1(L, H), Z.subtreeFlags = L.subtreeFlags & Qe;
      var xe;
      return F !== null ? xe = oc(F, v) : (xe = Kl(v, R, S, null), xe.flags |= Ve), xe.return = a, Z.return = a, Z.sibling = xe, a.child = Z, xe;
    }
    function ag(s, a, p, v) {
      v !== null && Tx(v), $f(a, s.child, null, p);
      var S = a.pendingProps, R = S.children, L = g_(a, R);
      return L.flags |= Ve, a.memoizedState = null, L;
    }
    function UN(s, a, p, v, S) {
      var R = a.mode, L = {
        mode: "visible",
        children: p
      }, F = y_(L, R), H = Kl(v, R, S, null);
      return H.flags |= Ve, F.return = a, H.return = a, F.sibling = H, a.child = F, (a.mode & Rn) !== Yt && $f(a, s.child, null, S), H;
    }
    function ON(s, a, p) {
      return (s.mode & Rn) === Yt ? (h("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), s.lanes = ln) : Pu(a) ? s.lanes = eo : s.lanes = or, null;
    }
    function IN(s, a, p, v, S) {
      if (W2(), (a.mode & Rn) === Yt)
        return ag(
          s,
          a,
          S,
          // TODO: When we delete legacy mode, we should make this error argument
          // required  every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (Pu(p))
        return ag(
          s,
          a,
          S,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var R = lr(S, s.childLanes);
      if (Da || R) {
        var L = wg();
        if (L !== null) {
          var F = dv(L, S);
          if (F !== ri && F !== v.retryLane) {
            v.retryLane = F;
            var H = Fn;
            tr(s, F, H);
          }
        }
        return H_(), ag(s, a, S, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (ef(p)) {
        a.flags |= Ye, a.child = s.child;
        var Z = T3.bind(null, s);
        return fl(p, Z), null;
      } else {
        Y2(a, p, v.treeContext);
        var te = a.pendingProps, xe = te.children, we = g_(a, xe);
        return we.flags |= Jt, we;
      }
    }
    function s1(s, a, p) {
      s.lanes = nn(s.lanes, a);
      var v = s.alternate;
      v !== null && (v.lanes = nn(v.lanes, a)), x(s.return, a, p);
    }
    function FN(s, a, p) {
      for (var v = a; v !== null; ) {
        if (v.tag === Q) {
          var S = v.memoizedState;
          S !== null && s1(v, p, s);
        } else if (v.tag === Ae)
          s1(v, p, s);
        else if (v.child !== null) {
          v.child.return = v, v = v.child;
          continue;
        }
        if (v === s)
          return;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === s)
            return;
          v = v.return;
        }
        v.sibling.return = v.return, v = v.sibling;
      }
    }
    function zN(s) {
      for (var a = s, p = null; a !== null; ) {
        var v = a.alternate;
        v !== null && Uv(v) === null && (p = a), a = a.sibling;
      }
      return p;
    }
    function BN(s) {
      if (s !== void 0 && s !== "forwards" && s !== "backwards" && s !== "together" && !h_[s])
        if (h_[s] = !0, typeof s == "string")
          switch (s.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              h('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', s, s.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              h('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', s, s.toLowerCase());
              break;
            }
            default:
              h('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', s);
              break;
          }
        else
          h('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', s);
    }
    function VN(s, a) {
      s !== void 0 && !ig[s] && (s !== "collapsed" && s !== "hidden" ? (ig[s] = !0, h('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', s)) : a !== "forwards" && a !== "backwards" && (ig[s] = !0, h('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', s)));
    }
    function a1(s, a) {
      {
        var p = ht(s), v = !p && typeof de(s) == "function";
        if (p || v) {
          var S = p ? "array" : "iterable";
          return h("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", S, a, S), !1;
        }
      }
      return !0;
    }
    function HN(s, a) {
      if ((a === "forwards" || a === "backwards") && s !== void 0 && s !== null && s !== !1)
        if (ht(s)) {
          for (var p = 0; p < s.length; p++)
            if (!a1(s[p], p))
              return;
        } else {
          var v = de(s);
          if (typeof v == "function") {
            var S = v.call(s);
            if (S)
              for (var R = S.next(), L = 0; !R.done; R = S.next()) {
                if (!a1(R.value, L))
                  return;
                L++;
              }
          } else
            h('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', a);
        }
    }
    function x_(s, a, p, v, S) {
      var R = s.memoizedState;
      R === null ? s.memoizedState = {
        isBackwards: a,
        rendering: null,
        renderingStartTime: 0,
        last: v,
        tail: p,
        tailMode: S
      } : (R.isBackwards = a, R.rendering = null, R.renderingStartTime = 0, R.last = v, R.tail = p, R.tailMode = S);
    }
    function o1(s, a, p) {
      var v = a.pendingProps, S = v.revealOrder, R = v.tail, L = v.children;
      BN(S), VN(R, S), HN(L, S), Qr(s, a, L, p);
      var F = Pa.current, H = Ux(F, ip);
      if (H)
        F = Ox(F, ip), a.flags |= Ye;
      else {
        var Z = s !== null && (s.flags & Ye) !== he;
        Z && FN(a, a.child, p), F = td(F);
      }
      if (Gl(a, F), (a.mode & Rn) === Yt)
        a.memoizedState = null;
      else
        switch (S) {
          case "forwards": {
            var te = zN(a.child), xe;
            te === null ? (xe = a.child, a.child = null) : (xe = te.sibling, te.sibling = null), x_(
              a,
              !1,
              // isBackwards
              xe,
              te,
              R
            );
            break;
          }
          case "backwards": {
            var we = null, De = a.child;
            for (a.child = null; De !== null; ) {
              var We = De.alternate;
              if (We !== null && Uv(We) === null) {
                a.child = De;
                break;
              }
              var Je = De.sibling;
              De.sibling = we, we = De, De = Je;
            }
            x_(
              a,
              !0,
              // isBackwards
              we,
              null,
              // last
              R
            );
            break;
          }
          case "together": {
            x_(
              a,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            a.memoizedState = null;
        }
      return a.child;
    }
    function kN(s, a, p) {
      Dx(a, a.stateNode.containerInfo);
      var v = a.pendingProps;
      return s === null ? a.child = $f(a, null, v, p) : Qr(s, a, v, p), a.child;
    }
    var l1 = !1;
    function GN(s, a, p) {
      var v = a.type, S = v._context, R = a.pendingProps, L = a.memoizedProps, F = R.value;
      {
        "value" in R || l1 || (l1 = !0, h("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var H = a.type.propTypes;
        H && pi(H, R, "prop", "Context.Provider");
      }
      if (c(a, S, F), L !== null) {
        var Z = L.value;
        if (Pi(Z, F)) {
          if (L.children === R.children && !Ro())
            return Ho(s, a, p);
        } else
          b(a, S, p);
      }
      var te = R.children;
      return Qr(s, a, te, p), a.child;
    }
    var u1 = !1;
    function WN(s, a, p) {
      var v = a.type;
      v._context === void 0 ? v !== v.Consumer && (u1 || (u1 = !0, h("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : v = v._context;
      var S = a.pendingProps, R = S.children;
      typeof R != "function" && h("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), D(a, p);
      var L = X(v);
      Zi(a);
      var F;
      return pp.current = a, na(!0), F = R(L), na(!1), Ds(), a.flags |= Ze, Qr(s, a, F, p), a.child;
    }
    function og() {
      Da = !0;
    }
    function Ho(s, a, p) {
      return s !== null && (a.dependencies = s.dependencies), IT(), Pg(a.lanes), lr(p, a.childLanes) ? ($2(s, a), a.child) : null;
    }
    function XN(s, a, p) {
      {
        var v = a.return;
        if (v === null)
          throw new Error("Cannot swap the root fiber.");
        if (s.alternate = null, a.alternate = null, p.index = a.index, p.sibling = a.sibling, p.return = a.return, p.ref = a.ref, a === v.child)
          v.child = p;
        else {
          var S = v.child;
          if (S === null)
            throw new Error("Expected parent to have a child.");
          for (; S.sibling !== a; )
            if (S = S.sibling, S === null)
              throw new Error("Expected to find the previous sibling.");
          S.sibling = p;
        }
        var R = v.deletions;
        return R === null ? (v.deletions = [s], v.flags |= Ke) : R.push(s), p.flags |= Ve, p;
      }
    }
    function __(s, a) {
      var p = s.lanes;
      return !!lr(p, a);
    }
    function jN(s, a, p) {
      switch (a.tag) {
        case W:
          JT(a), a.stateNode, Qf();
          break;
        case O:
          aT(a);
          break;
        case I: {
          var v = a.type;
          Dr(v) && Sl(a);
          break;
        }
        case U:
          Dx(a, a.stateNode.containerInfo);
          break;
        case oe: {
          var S = a.memoizedProps.value, R = a.type._context;
          c(a, R, S);
          break;
        }
        case Ee:
          {
            var L = lr(p, a.childLanes);
            L && (a.flags |= Te);
            {
              var F = a.stateNode;
              F.effectDuration = 0, F.passiveEffectDuration = 0;
            }
          }
          break;
        case Q: {
          var H = a.memoizedState;
          if (H !== null) {
            if (H.dehydrated !== null)
              return Gl(a, td(Pa.current)), a.flags |= Ye, null;
            var Z = a.child, te = Z.childLanes;
            if (lr(p, te))
              return t1(s, a, p);
            Gl(a, td(Pa.current));
            var xe = Ho(s, a, p);
            return xe !== null ? xe.sibling : null;
          } else
            Gl(a, td(Pa.current));
          break;
        }
        case Ae: {
          var we = (s.flags & Ye) !== he, De = lr(p, a.childLanes);
          if (we) {
            if (De)
              return o1(s, a, p);
            a.flags |= Ye;
          }
          var We = a.memoizedState;
          if (We !== null && (We.rendering = null, We.tail = null, We.lastEffect = null), Gl(a, Pa.current), De)
            break;
          return null;
        }
        case je:
        case $e:
          return a.lanes = Ge, qT(s, a, p);
      }
      return Ho(s, a, p);
    }
    function c1(s, a, p) {
      if (a._debugNeedsRemount && s !== null)
        return XN(s, a, J_(a.type, a.key, a.pendingProps, a._debugOwner || null, a.mode, a.lanes));
      if (s !== null) {
        var v = s.memoizedProps, S = a.pendingProps;
        if (v !== S || Ro() || // Force a re-render if the implementation changed due to hot reload:
        a.type !== s.type)
          Da = !0;
        else {
          var R = __(s, p);
          if (!R && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (a.flags & Ye) === he)
            return Da = !1, jN(s, a, p);
          (s.flags & $) !== he ? Da = !0 : Da = !1;
        }
      } else if (Da = !1, Or() && z2(a)) {
        var L = a.index, F = B2();
        qb(a, F, L);
      }
      switch (a.lanes = Ge, a.tag) {
        case V:
          return LN(s, a, a.type, p);
        case ue: {
          var H = a.elementType;
          return CN(s, a, H, p);
        }
        case z: {
          var Z = a.type, te = a.pendingProps, xe = a.elementType === Z ? te : Jr(Z, te);
          return p_(s, a, Z, xe, p);
        }
        case I: {
          var we = a.type, De = a.pendingProps, We = a.elementType === we ? De : Jr(we, De);
          return KT(s, a, we, We, p);
        }
        case W:
          return wN(s, a, p);
        case O:
          return AN(s, a, p);
        case q:
          return RN(s, a);
        case Q:
          return t1(s, a, p);
        case U:
          return kN(s, a, p);
        case ie: {
          var Je = a.type, Vt = a.pendingProps, an = a.elementType === Je ? Vt : Jr(Je, Vt);
          return XT(s, a, Je, an, p);
        }
        case le:
          return EN(s, a, p);
        case ye:
          return bN(s, a, p);
        case Ee:
          return TN(s, a, p);
        case oe:
          return GN(s, a, p);
        case K:
          return WN(s, a, p);
        case se: {
          var kt = a.type, Qn = a.pendingProps, $n = Jr(kt, Qn);
          if (a.type !== a.elementType) {
            var Me = kt.propTypes;
            Me && pi(
              Me,
              $n,
              // Resolved for outer only
              "prop",
              Xe(kt)
            );
          }
          return $n = Jr(kt.type, $n), jT(s, a, kt, $n, p);
        }
        case re:
          return YT(s, a, a.type, a.pendingProps, p);
        case Le: {
          var Ne = a.type, _e = a.pendingProps, tt = a.elementType === Ne ? _e : Jr(Ne, _e);
          return PN(s, a, Ne, tt, p);
        }
        case Ae:
          return o1(s, a, p);
        case qe:
          break;
        case je:
          return qT(s, a, p);
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function YN(s, a, p) {
      switch (_x(a), a.tag) {
        case I: {
          var v = a.type;
          Dr(v) && Ja(a);
          var S = a.flags;
          return S & Zn ? (a.flags = S & ~Zn | Ye, (a.mode & Tn) !== Yt && a_(a), a) : null;
        }
        case W: {
          ed(a), wh(a), Fx();
          var R = a.flags;
          return (R & Zn) !== he && (R & Ye) === he ? (a.flags = R & ~Zn | Ye, a) : null;
        }
        case O:
          return Nx(a), null;
        case Q: {
          nd(a);
          {
            var L = a.memoizedState;
            if (L !== null && L.dehydrated !== null) {
              if (a.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              Qf();
            }
          }
          var F = a.flags;
          return F & Zn ? (a.flags = F & ~Zn | Ye, (a.mode & Tn) !== Yt && a_(a), a) : null;
        }
        case Ae:
          return nd(a), null;
        case U:
          return ed(a), null;
        case oe:
          var H = a.type._context;
          return f(H, a), null;
        case je:
        case $e:
          return V_(a), null;
        case Rt:
          return null;
        default:
          return null;
      }
    }
    function f1(s, a, p) {
      switch (_x(a), a.tag) {
        case I: {
          var v = a.type.childContextTypes;
          v != null && Ja(a);
          break;
        }
        case W: {
          ed(a), wh(a), Fx();
          break;
        }
        case O: {
          Nx(a);
          break;
        }
        case U:
          ed(a);
          break;
        case Q:
          nd(a);
          break;
        case Ae:
          nd(a);
          break;
        case oe:
          var S = a.type._context;
          f(S, a);
          break;
        case je:
        case $e:
          V_(a);
          break;
      }
    }
    function d1(s, a, p, v, S, R, L, F, H) {
      var Z = Array.prototype.slice.call(arguments, 3);
      try {
        a.apply(p, Z);
      } catch (te) {
        this.onError(te);
      }
    }
    var h1 = d1;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var S_ = document.createElement("react");
      h1 = function(a, p, v, S, R, L, F, H, Z) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var te = document.createEvent("Event"), xe = !1, we = !0, De = window.event, We = Object.getOwnPropertyDescriptor(window, "event");
        function Je() {
          S_.removeEventListener(Ne, an, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = De);
        }
        var Vt = Array.prototype.slice.call(arguments, 3);
        function an() {
          xe = !0, Je(), p.apply(v, Vt), we = !1;
        }
        var kt, Qn = !1, $n = !1;
        function Me(_e) {
          if (kt = _e.error, Qn = !0, kt === null && _e.colno === 0 && _e.lineno === 0 && ($n = !0), _e.defaultPrevented && kt != null && typeof kt == "object")
            try {
              kt._suppressLogging = !0;
            } catch {
            }
        }
        var Ne = "react-" + (a || "invokeguardedcallback");
        if (window.addEventListener("error", Me), S_.addEventListener(Ne, an, !1), te.initEvent(Ne, !1, !1), S_.dispatchEvent(te), We && Object.defineProperty(window, "event", We), xe && we && (Qn ? $n && (kt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : kt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(kt)), window.removeEventListener("error", Me), !xe)
          return Je(), d1.apply(this, arguments);
      };
    }
    var qN = h1, vp = !1, lg = null, ZN = {
      onError: function(s) {
        vp = !0, lg = s;
      }
    };
    function p1(s, a, p, v, S, R, L, F, H) {
      vp = !1, lg = null, qN.apply(ZN, arguments);
    }
    function KN() {
      return vp;
    }
    function m1() {
      if (vp) {
        var s = lg;
        return vp = !1, lg = null, s;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var v1 = null;
    v1 = /* @__PURE__ */ new Set();
    var ug = !1, Yl = !1, JN = typeof WeakSet == "function" ? WeakSet : Set, xt = null, ld = null, ud = null;
    function br(s) {
      p1(null, function() {
        throw s;
      }), m1();
    }
    var QN = function(s, a) {
      if (a.props = s.memoizedProps, a.state = s.memoizedState, s.mode & Tn)
        try {
          la(), a.componentWillUnmount();
        } finally {
          oa(s);
        }
      else
        a.componentWillUnmount();
    };
    function g1(s, a) {
      try {
        ko(Li, s);
      } catch (p) {
        br(p), Tr(s, a, p);
      }
    }
    function M_(s, a, p) {
      try {
        QN(s, p);
      } catch (v) {
        br(v), Tr(s, a, v);
      }
    }
    function $N(s, a, p) {
      try {
        p.componentDidMount();
      } catch (v) {
        br(v), Tr(s, a, v);
      }
    }
    function y1(s, a) {
      try {
        _1(s);
      } catch (p) {
        br(p), Tr(s, a, p);
      }
    }
    function cg(s, a) {
      var p = s.ref;
      if (p !== null)
        if (typeof p == "function") {
          var v;
          try {
            if (A && N && s.mode & Tn)
              try {
                la(), v = p(null);
              } finally {
                oa(s);
              }
            else
              v = p(null);
          } catch (S) {
            br(S), Tr(s, a, S);
          }
          typeof v == "function" && h("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Y(s));
        } else
          p.current = null;
    }
    function fg(s, a, p) {
      try {
        p();
      } catch (v) {
        br(v), Tr(s, a, v);
      }
    }
    var x1 = !1;
    function eU(s, a) {
      Ws(s.containerInfo), xt = a, tU();
      var p = x1;
      return x1 = !1, p;
    }
    function tU() {
      for (; xt !== null; ) {
        var s = xt, a = s.child;
        (s.subtreeFlags & ne) !== he && a !== null ? (ua(a, s), xt = a) : nU();
      }
    }
    function nU() {
      for (; xt !== null; ) {
        var s = xt;
        jn(s);
        try {
          iU(s);
        } catch (p) {
          br(p), Tr(s, s.return, p);
        }
        Ki();
        var a = s.sibling;
        if (a !== null) {
          ua(a, s.return), xt = a;
          return;
        }
        xt = s.return;
      }
    }
    function iU(s) {
      var a = s.alternate, p = s.flags;
      if ((p & Sn) !== he) {
        switch (jn(s), s.tag) {
          case z:
          case ie:
          case re:
            break;
          case I: {
            if (a !== null) {
              var v = a.memoizedProps, S = a.memoizedState, R = s.stateNode;
              s.type === s.elementType && !nc && (R.props !== s.memoizedProps && h("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Y(s) || "instance"), R.state !== s.memoizedState && h("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Y(s) || "instance"));
              var L = R.getSnapshotBeforeUpdate(s.elementType === s.type ? v : Jr(s.type, v), S);
              {
                var F = v1;
                L === void 0 && !F.has(s.type) && (F.add(s.type), h("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Y(s)));
              }
              R.__reactInternalSnapshotBeforeUpdate = L;
            }
            break;
          }
          case W: {
            if (Cr) {
              var H = s.stateNode;
              qs(H.containerInfo);
            }
            break;
          }
          case O:
          case q:
          case U:
          case Le:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ki();
      }
    }
    function ys(s, a, p) {
      var v = a.updateQueue, S = v !== null ? v.lastEffect : null;
      if (S !== null) {
        var R = S.next, L = R;
        do {
          if ((L.tag & s) === s) {
            var F = L.destroy;
            L.destroy = void 0, F !== void 0 && ((s & Mr) !== ao ? Pl(a) : (s & Li) !== ao && vr(a), fg(a, p, F), (s & Mr) !== ao ? Bf() : (s & Li) !== ao && Vf());
          }
          L = L.next;
        } while (L !== R);
      }
    }
    function ko(s, a) {
      var p = a.updateQueue, v = p !== null ? p.lastEffect : null;
      if (v !== null) {
        var S = v.next, R = S;
        do {
          if ((R.tag & s) === s) {
            (s & Mr) !== ao ? Ci(a) : (s & Li) !== ao && Wh(a);
            var L = R.create;
            R.destroy = L(), (s & Mr) !== ao ? ku() : (s & Li) !== ao && Gu();
            {
              var F = R.destroy;
              if (F !== void 0 && typeof F != "function") {
                var H = void 0;
                (R.tag & Li) !== he ? H = "useLayoutEffect" : (R.tag & Wl) !== he ? H = "useInsertionEffect" : H = "useEffect";
                var Z = void 0;
                F === null ? Z = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof F.then == "function" ? Z = `

It looks like you wrote ` + H + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + H + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Z = " You returned: " + F, h("%s must not return anything besides a function, which is used for clean-up.%s", H, Z);
              }
            }
          }
          R = R.next;
        } while (R !== S);
      }
    }
    function rU(s, a) {
      if ((a.flags & Te) !== he)
        switch (a.tag) {
          case Ee: {
            var p = a.stateNode.passiveEffectDuration, v = a.memoizedProps, S = v.id, R = v.onPostCommit, L = UT(), F = a.alternate === null ? "mount" : "update";
            NT() && (F = "nested-update"), typeof R == "function" && R(S, F, p, L);
            var H = a.return;
            e: for (; H !== null; ) {
              switch (H.tag) {
                case W:
                  var Z = H.stateNode;
                  Z.passiveEffectDuration += p;
                  break e;
                case Ee:
                  var te = H.stateNode;
                  te.passiveEffectDuration += p;
                  break e;
              }
              H = H.return;
            }
            break;
          }
        }
    }
    function sU(s, a, p, v) {
      if ((p.flags & ve) !== he)
        switch (p.tag) {
          case z:
          case ie:
          case re: {
            if (!Yl)
              if (p.mode & Tn)
                try {
                  la(), ko(Li | si, p);
                } finally {
                  oa(p);
                }
              else
                ko(Li | si, p);
            break;
          }
          case I: {
            var S = p.stateNode;
            if (p.flags & Te && !Yl)
              if (a === null)
                if (p.type === p.elementType && !nc && (S.props !== p.memoizedProps && h("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Y(p) || "instance"), S.state !== p.memoizedState && h("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Y(p) || "instance")), p.mode & Tn)
                  try {
                    la(), S.componentDidMount();
                  } finally {
                    oa(p);
                  }
                else
                  S.componentDidMount();
              else {
                var R = p.elementType === p.type ? a.memoizedProps : Jr(p.type, a.memoizedProps), L = a.memoizedState;
                if (p.type === p.elementType && !nc && (S.props !== p.memoizedProps && h("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Y(p) || "instance"), S.state !== p.memoizedState && h("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Y(p) || "instance")), p.mode & Tn)
                  try {
                    la(), S.componentDidUpdate(R, L, S.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    oa(p);
                  }
                else
                  S.componentDidUpdate(R, L, S.__reactInternalSnapshotBeforeUpdate);
              }
            var F = p.updateQueue;
            F !== null && (p.type === p.elementType && !nc && (S.props !== p.memoizedProps && h("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Y(p) || "instance"), S.state !== p.memoizedState && h("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Y(p) || "instance")), Tv(p, F, S));
            break;
          }
          case W: {
            var H = p.updateQueue;
            if (H !== null) {
              var Z = null;
              if (p.child !== null)
                switch (p.child.tag) {
                  case O:
                    Z = Ar(p.child.stateNode);
                    break;
                  case I:
                    Z = p.child.stateNode;
                    break;
                }
              Tv(p, H, Z);
            }
            break;
          }
          case O: {
            var te = p.stateNode;
            if (a === null && p.flags & Te) {
              var xe = p.type, we = p.memoizedProps;
              K0(te, xe, we, p);
            }
            break;
          }
          case q:
            break;
          case U:
            break;
          case Ee: {
            {
              var De = p.memoizedProps, We = De.onCommit, Je = De.onRender, Vt = p.stateNode.effectDuration, an = UT(), kt = a === null ? "mount" : "update";
              NT() && (kt = "nested-update"), typeof Je == "function" && Je(p.memoizedProps.id, kt, p.actualDuration, p.treeBaseDuration, p.actualStartTime, an);
              {
                typeof We == "function" && We(p.memoizedProps.id, kt, Vt, an), x3(p);
                var Qn = p.return;
                e: for (; Qn !== null; ) {
                  switch (Qn.tag) {
                    case W:
                      var $n = Qn.stateNode;
                      $n.effectDuration += Vt;
                      break e;
                    case Ee:
                      var Me = Qn.stateNode;
                      Me.effectDuration += Vt;
                      break e;
                  }
                  Qn = Qn.return;
                }
              }
            }
            break;
          }
          case Q: {
            pU(s, p);
            break;
          }
          case Ae:
          case Le:
          case qe:
          case je:
          case $e:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Yl || p.flags & tn && _1(p);
    }
    function aU(s) {
      switch (s.tag) {
        case z:
        case ie:
        case re: {
          if (s.mode & Tn)
            try {
              la(), g1(s, s.return);
            } finally {
              oa(s);
            }
          else
            g1(s, s.return);
          break;
        }
        case I: {
          var a = s.stateNode;
          typeof a.componentDidMount == "function" && $N(s, s.return, a), y1(s, s.return);
          break;
        }
        case O: {
          y1(s, s.return);
          break;
        }
      }
    }
    function oU(s, a) {
      var p = null;
      if (Cr)
        for (var v = s; ; ) {
          if (v.tag === O) {
            if (p === null) {
              p = v;
              var S = v.stateNode;
              a ? $c(S) : qm(v.stateNode, v.memoizedProps);
            }
          } else if (v.tag === q) {
            if (p === null) {
              var R = v.stateNode;
              a ? gh(R) : $0(R, v.memoizedProps);
            }
          } else if (!((v.tag === je || v.tag === $e) && v.memoizedState !== null && v !== s)) {
            if (v.child !== null) {
              v.child.return = v, v = v.child;
              continue;
            }
          }
          if (v === s)
            return;
          for (; v.sibling === null; ) {
            if (v.return === null || v.return === s)
              return;
            p === v && (p = null), v = v.return;
          }
          p === v && (p = null), v.sibling.return = v.return, v = v.sibling;
        }
    }
    function _1(s) {
      var a = s.ref;
      if (a !== null) {
        var p = s.stateNode, v;
        switch (s.tag) {
          case O:
            v = Ar(p);
            break;
          default:
            v = p;
        }
        if (typeof a == "function") {
          var S;
          if (s.mode & Tn)
            try {
              la(), S = a(v);
            } finally {
              oa(s);
            }
          else
            S = a(v);
          typeof S == "function" && h("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Y(s));
        } else
          a.hasOwnProperty("current") || h("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Y(s)), a.current = v;
      }
    }
    function lU(s) {
      var a = s.ref;
      if (a !== null)
        if (typeof a == "function")
          if (s.mode & Tn)
            try {
              la(), a(null);
            } finally {
              oa(s);
            }
          else
            a(null);
        else
          a.current = null;
    }
    function S1(s, a, p) {
      switch (Gh(a), a.tag) {
        case z:
        case ie:
        case se:
        case re: {
          var v = a.updateQueue;
          if (v !== null) {
            var S = v.lastEffect;
            if (S !== null) {
              var R = S.next, L = R;
              do {
                var F = L, H = F.destroy, Z = F.tag;
                H !== void 0 && ((Z & Wl) !== ao ? fg(a, p, H) : (Z & Li) !== ao && (vr(a), a.mode & Tn ? (la(), fg(a, p, H), oa(a)) : fg(a, p, H), Vf())), L = L.next;
              } while (L !== R);
            }
          }
          return;
        }
        case I: {
          cg(a, p);
          var te = a.stateNode;
          typeof te.componentWillUnmount == "function" && M_(a, p, te);
          return;
        }
        case O: {
          cg(a, p);
          return;
        }
        case U: {
          Cr ? A1(s, a, p) : Xa && cU(a);
          return;
        }
        case pe:
          return;
        case qe:
          return;
      }
    }
    function M1(s, a, p) {
      for (var v = a; ; ) {
        if (S1(s, v, p), v.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!Cr || v.tag !== U)) {
          v.child.return = v, v = v.child;
          continue;
        }
        if (v === a)
          return;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === a)
            return;
          v = v.return;
        }
        v.sibling.return = v.return, v = v.sibling;
      }
    }
    function uU(s) {
      var a = s.alternate;
      a !== null && (a.return = null), s.return = null;
    }
    function E1(s) {
      var a = s.alternate;
      a !== null && (s.alternate = null, E1(a));
      {
        if (s.child = null, s.deletions = null, s.sibling = null, s.tag === O) {
          var p = s.stateNode;
          p !== null && hh(p);
        }
        s.stateNode = null, s._debugOwner = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
      }
    }
    function cU(s) {
      if (Xa) {
        var a = s.stateNode, p = a.containerInfo, v = Au(p);
        Ru(p, v);
      }
    }
    function fU(s) {
      if (Xa) {
        switch (s.tag) {
          case I:
          case O:
          case q:
            return;
          case W:
          case U: {
            var a = s.stateNode, p = a.containerInfo, v = a.pendingChildren;
            Ru(p, v);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function dU(s) {
      for (var a = s.return; a !== null; ) {
        if (b1(a))
          return a;
        a = a.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function b1(s) {
      return s.tag === O || s.tag === W || s.tag === U;
    }
    function T1(s) {
      var a = s;
      e: for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || b1(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== O && a.tag !== q && a.tag !== pe; ) {
          if (a.flags & Ve || a.child === null || a.tag === U)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & Ve))
          return a.stateNode;
      }
    }
    function w1(s) {
      if (Cr) {
        var a = dU(s);
        switch (a.tag) {
          case O: {
            var p = a.stateNode;
            a.flags & st && (Ys(p), a.flags &= ~st);
            var v = T1(s);
            b_(s, v, p);
            break;
          }
          case W:
          case U: {
            var S = a.stateNode.containerInfo, R = T1(s);
            E_(s, R, S);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function E_(s, a, p) {
      var v = s.tag, S = v === O || v === q;
      if (S) {
        var R = s.stateNode;
        a ? J0(p, R, a) : Z0(p, R);
      } else if (v !== U) {
        var L = s.child;
        if (L !== null) {
          E_(L, a, p);
          for (var F = L.sibling; F !== null; )
            E_(F, a, p), F = F.sibling;
        }
      }
    }
    function b_(s, a, p) {
      var v = s.tag, S = v === O || v === q;
      if (S) {
        var R = s.stateNode;
        a ? Xs(p, R, a) : mh(p, R);
      } else if (v !== U) {
        var L = s.child;
        if (L !== null) {
          b_(L, a, p);
          for (var F = L.sibling; F !== null; )
            b_(F, a, p), F = F.sibling;
        }
      }
    }
    function A1(s, a, p) {
      for (var v = a, S = !1, R, L; ; ) {
        if (!S) {
          var F = v.return;
          e: for (; ; ) {
            if (F === null)
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            var H = F.stateNode;
            switch (F.tag) {
              case O:
                R = H, L = !1;
                break e;
              case W:
                R = H.containerInfo, L = !0;
                break e;
              case U:
                R = H.containerInfo, L = !0;
                break e;
            }
            F = F.return;
          }
          S = !0;
        }
        if (v.tag === O || v.tag === q)
          M1(s, v, p), L ? js(R, v.stateNode) : Q0(R, v.stateNode);
        else if (v.tag === pe)
          L ? $m(R, v.stateNode) : Qm(R, v.stateNode);
        else if (v.tag === U) {
          if (v.child !== null) {
            R = v.stateNode.containerInfo, L = !0, v.child.return = v, v = v.child;
            continue;
          }
        } else if (S1(s, v, p), v.child !== null) {
          v.child.return = v, v = v.child;
          continue;
        }
        if (v === a)
          return;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === a)
            return;
          v = v.return, v.tag === U && (S = !1);
        }
        v.sibling.return = v.return, v = v.sibling;
      }
    }
    function hU(s, a, p) {
      Cr ? A1(s, a, p) : M1(s, a, p), uU(a);
    }
    function T_(s, a) {
      if (!Cr) {
        switch (a.tag) {
          case z:
          case ie:
          case se:
          case re: {
            if (ys(Wl | si, a, a.return), ko(Wl | si, a), a.mode & Tn)
              try {
                la(), ys(Li | si, a, a.return);
              } finally {
                oa(a);
              }
            else
              ys(Li | si, a, a.return);
            return;
          }
          case Ee:
            return;
          case Q: {
            R1(a), dg(a);
            return;
          }
          case Ae: {
            dg(a);
            return;
          }
          case W: {
            if (ar && s !== null) {
              var p = s.memoizedState;
              if (p.isDehydrated) {
                var v = a.stateNode;
                Sh(v.containerInfo);
              }
            }
            break;
          }
          case je:
          case $e:
            return;
        }
        fU(a);
        return;
      }
      switch (a.tag) {
        case z:
        case ie:
        case se:
        case re: {
          if (ys(Wl | si, a, a.return), ko(Wl | si, a), a.mode & Tn)
            try {
              la(), ys(Li | si, a, a.return);
            } finally {
              oa(a);
            }
          else
            ys(Li | si, a, a.return);
          return;
        }
        case I:
          return;
        case O: {
          var S = a.stateNode;
          if (S != null) {
            var R = a.memoizedProps, L = s !== null ? s.memoizedProps : R, F = a.type, H = a.updateQueue;
            a.updateQueue = null, H !== null && Qc(S, H, F, L, R, a);
          }
          return;
        }
        case q: {
          if (a.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Z = a.stateNode, te = a.memoizedProps, xe = s !== null ? s.memoizedProps : te;
          vh(Z, xe, te);
          return;
        }
        case W: {
          if (ar && s !== null) {
            var we = s.memoizedState;
            if (we.isDehydrated) {
              var De = a.stateNode;
              Sh(De.containerInfo);
            }
          }
          return;
        }
        case Ee:
          return;
        case Q: {
          R1(a), dg(a);
          return;
        }
        case Ae: {
          dg(a);
          return;
        }
        case Le:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function R1(s) {
      s.memoizedState;
    }
    function pU(s, a) {
      if (ar) {
        var p = a.memoizedState;
        if (p === null) {
          var v = a.alternate;
          if (v !== null) {
            var S = v.memoizedState;
            if (S !== null) {
              var R = S.dehydrated;
              R !== null && nf(R);
            }
          }
        }
      }
    }
    function dg(s) {
      var a = s.updateQueue;
      if (a !== null) {
        s.updateQueue = null;
        var p = s.stateNode;
        p === null && (p = s.stateNode = new JN()), a.forEach(function(v) {
          var S = w3.bind(null, s, v);
          if (!p.has(v)) {
            if (p.add(v), Kr)
              if (ld !== null && ud !== null)
                wp(ud, ld);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            v.then(S, S);
          }
        });
      }
    }
    function mU(s) {
      Cr && Ys(s.stateNode);
    }
    function vU(s, a, p) {
      ld = p, ud = s, xt = a, gU(s, p), ld = null, ud = null;
    }
    function gU(s, a) {
      for (; xt !== null; ) {
        var p = xt, v = p.deletions;
        if (v !== null)
          for (var S = 0; S < v.length; S++) {
            var R = v[S];
            try {
              hU(s, R, p);
            } catch (F) {
              br(F), Tr(R, p, F);
            }
          }
        var L = p.child;
        (p.subtreeFlags & ge) !== he && L !== null ? (ua(L, p), xt = L) : yU(s, a);
      }
    }
    function yU(s, a) {
      for (; xt !== null; ) {
        var p = xt;
        jn(p);
        try {
          xU(p, s, a);
        } catch (S) {
          br(S), Tr(p, p.return, S);
        }
        Ki();
        var v = p.sibling;
        if (v !== null) {
          ua(v, p.return), xt = v;
          return;
        }
        xt = p.return;
      }
    }
    function xU(s, a, p) {
      var v = s.flags;
      if (v & st && mU(s), v & tn) {
        var S = s.alternate;
        S !== null && lU(S);
      }
      if (v & hi)
        switch (s.tag) {
          case Q: {
            var R = s.memoizedState, L = R !== null;
            if (L) {
              var F = s.alternate, H = F !== null && F.memoizedState !== null;
              H || f3();
            }
            break;
          }
          case je: {
            var Z = s.memoizedState, te = Z !== null, xe = s.alternate, we = xe !== null && xe.memoizedState !== null, De = s;
            Cr && oU(De, te);
            {
              if (te && !we && (De.mode & Rn) !== Yt) {
                xt = De;
                for (var We = De.child; We !== null; )
                  xt = We, SU(We), We = We.sibling;
              }
              break;
            }
          }
        }
      var Je = v & (Ve | Te | Jt);
      switch (Je) {
        case Ve: {
          w1(s), s.flags &= ~Ve;
          break;
        }
        case ee: {
          w1(s), s.flags &= ~Ve;
          var Vt = s.alternate;
          T_(Vt, s);
          break;
        }
        case Jt: {
          s.flags &= ~Jt;
          break;
        }
        case di: {
          s.flags &= ~Jt;
          var an = s.alternate;
          T_(an, s);
          break;
        }
        case Te: {
          var kt = s.alternate;
          T_(kt, s);
          break;
        }
      }
    }
    function _U(s, a, p) {
      ld = p, ud = a, xt = s, C1(s, a, p), ld = null, ud = null;
    }
    function C1(s, a, p) {
      for (var v = (s.mode & Rn) !== Yt; xt !== null; ) {
        var S = xt, R = S.child;
        if (S.tag === je && v) {
          var L = S.memoizedState !== null, F = L || ug;
          if (F) {
            w_(s, a, p);
            continue;
          } else {
            var H = S.alternate, Z = H !== null && H.memoizedState !== null, te = Z || Yl, xe = ug, we = Yl;
            ug = F, Yl = te, Yl && !we && (xt = S, MU(S));
            for (var De = R; De !== null; )
              xt = De, C1(
                De,
                // New root; bubble back up to here and stop.
                a,
                p
              ), De = De.sibling;
            xt = S, ug = xe, Yl = we, w_(s, a, p);
            continue;
          }
        }
        (S.subtreeFlags & ve) !== he && R !== null ? (ua(R, S), xt = R) : w_(s, a, p);
      }
    }
    function w_(s, a, p) {
      for (; xt !== null; ) {
        var v = xt;
        if ((v.flags & ve) !== he) {
          var S = v.alternate;
          jn(v);
          try {
            sU(a, S, v, p);
          } catch (L) {
            br(L), Tr(v, v.return, L);
          }
          Ki();
        }
        if (v === s) {
          xt = null;
          return;
        }
        var R = v.sibling;
        if (R !== null) {
          ua(R, v.return), xt = R;
          return;
        }
        xt = v.return;
      }
    }
    function SU(s) {
      for (; xt !== null; ) {
        var a = xt, p = a.child;
        switch (a.tag) {
          case z:
          case ie:
          case se:
          case re: {
            if (a.mode & Tn)
              try {
                la(), ys(Li, a, a.return);
              } finally {
                oa(a);
              }
            else
              ys(Li, a, a.return);
            break;
          }
          case I: {
            cg(a, a.return);
            var v = a.stateNode;
            typeof v.componentWillUnmount == "function" && M_(a, a.return, v);
            break;
          }
          case O: {
            cg(a, a.return);
            break;
          }
          case je: {
            var S = a.memoizedState !== null;
            if (S) {
              P1(s);
              continue;
            }
            break;
          }
        }
        p !== null ? (p.return = a, xt = p) : P1(s);
      }
    }
    function P1(s) {
      for (; xt !== null; ) {
        var a = xt;
        if (a === s) {
          xt = null;
          return;
        }
        var p = a.sibling;
        if (p !== null) {
          p.return = a.return, xt = p;
          return;
        }
        xt = a.return;
      }
    }
    function MU(s) {
      for (; xt !== null; ) {
        var a = xt, p = a.child;
        if (a.tag === je) {
          var v = a.memoizedState !== null;
          if (v) {
            L1(s);
            continue;
          }
        }
        p !== null ? (p.return = a, xt = p) : L1(s);
      }
    }
    function L1(s) {
      for (; xt !== null; ) {
        var a = xt;
        jn(a);
        try {
          aU(a);
        } catch (v) {
          br(v), Tr(a, a.return, v);
        }
        if (Ki(), a === s) {
          xt = null;
          return;
        }
        var p = a.sibling;
        if (p !== null) {
          p.return = a.return, xt = p;
          return;
        }
        xt = a.return;
      }
    }
    function EU(s, a) {
      xt = a, bU(a, s);
    }
    function bU(s, a) {
      for (; xt !== null; ) {
        var p = xt, v = p.child;
        (p.subtreeFlags & me) !== he && v !== null ? (ua(v, p), xt = v) : TU(s, a);
      }
    }
    function TU(s, a) {
      for (; xt !== null; ) {
        var p = xt;
        if ((p.flags & bn) !== he) {
          jn(p);
          try {
            wU(a, p);
          } catch (S) {
            br(S), Tr(p, p.return, S);
          }
          Ki();
        }
        if (p === s) {
          xt = null;
          return;
        }
        var v = p.sibling;
        if (v !== null) {
          ua(v, p.return), xt = v;
          return;
        }
        xt = p.return;
      }
    }
    function wU(s, a) {
      switch (a.tag) {
        case z:
        case ie:
        case re: {
          if (a.mode & Tn) {
            s_();
            try {
              ko(Mr | si, a);
            } finally {
              r_(a);
            }
          } else
            ko(Mr | si, a);
          break;
        }
      }
    }
    function AU(s) {
      xt = s, RU();
    }
    function RU() {
      for (; xt !== null; ) {
        var s = xt, a = s.child;
        if ((xt.flags & Ke) !== he) {
          var p = s.deletions;
          if (p !== null) {
            for (var v = 0; v < p.length; v++) {
              var S = p[v];
              xt = S, LU(S, s);
            }
            {
              var R = s.alternate;
              if (R !== null) {
                var L = R.child;
                if (L !== null) {
                  R.child = null;
                  do {
                    var F = L.sibling;
                    L.sibling = null, L = F;
                  } while (L !== null);
                }
              }
            }
            xt = s;
          }
        }
        (s.subtreeFlags & me) !== he && a !== null ? (ua(a, s), xt = a) : CU();
      }
    }
    function CU() {
      for (; xt !== null; ) {
        var s = xt;
        (s.flags & bn) !== he && (jn(s), PU(s), Ki());
        var a = s.sibling;
        if (a !== null) {
          ua(a, s.return), xt = a;
          return;
        }
        xt = s.return;
      }
    }
    function PU(s) {
      switch (s.tag) {
        case z:
        case ie:
        case re: {
          s.mode & Tn ? (s_(), ys(Mr | si, s, s.return), r_(s)) : ys(Mr | si, s, s.return);
          break;
        }
      }
    }
    function LU(s, a) {
      for (; xt !== null; ) {
        var p = xt;
        jn(p), NU(p, a), Ki();
        var v = p.child;
        v !== null ? (ua(v, p), xt = v) : DU(s);
      }
    }
    function DU(s) {
      for (; xt !== null; ) {
        var a = xt, p = a.sibling, v = a.return;
        if (E1(a), a === s) {
          xt = null;
          return;
        }
        if (p !== null) {
          ua(p, v), xt = p;
          return;
        }
        xt = v;
      }
    }
    function NU(s, a) {
      switch (s.tag) {
        case z:
        case ie:
        case re: {
          s.mode & Tn ? (s_(), ys(Mr, s, a), r_(s)) : ys(Mr, s, a);
          break;
        }
      }
    }
    var D1 = !1;
    function ua(s, a) {
      !D1 && s.return !== a && (D1 = !0, h("Internal React error: Return pointer is inconsistent with parent.")), s.return = a;
    }
    function UU(s) {
      switch (s.tag) {
        case z:
        case ie:
        case re: {
          try {
            ko(Li | si, s);
          } catch (p) {
            br(p), Tr(s, s.return, p);
          }
          break;
        }
        case I: {
          var a = s.stateNode;
          try {
            a.componentDidMount();
          } catch (p) {
            br(p), Tr(s, s.return, p);
          }
          break;
        }
      }
    }
    function OU(s) {
      switch (s.tag) {
        case z:
        case ie:
        case re: {
          try {
            ko(Mr | si, s);
          } catch (a) {
            br(a), Tr(s, s.return, a);
          }
          break;
        }
      }
    }
    function IU(s) {
      switch (s.tag) {
        case z:
        case ie:
        case re: {
          try {
            ys(Li | si, s, s.return);
          } catch (p) {
            br(p), Tr(s, s.return, p);
          }
          break;
        }
        case I: {
          var a = s.stateNode;
          typeof a.componentWillUnmount == "function" && M_(s, s.return, a);
          break;
        }
      }
    }
    function FU(s) {
      switch (s.tag) {
        case z:
        case ie:
        case re:
          try {
            ys(Mr | si, s, s.return);
          } catch (a) {
            br(a), Tr(s, s.return, a);
          }
      }
    }
    var hg = 0, pg = 1, mg = 2, vg = 3, gg = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var gp = Symbol.for;
      hg = gp("selector.component"), pg = gp("selector.has_pseudo_class"), mg = gp("selector.role"), vg = gp("selector.test_id"), gg = gp("selector.text");
    }
    function zU(s) {
      return {
        $$typeof: hg,
        value: s
      };
    }
    function BU(s) {
      return {
        $$typeof: pg,
        value: s
      };
    }
    function VU(s) {
      return {
        $$typeof: mg,
        value: s
      };
    }
    function HU(s) {
      return {
        $$typeof: gg,
        value: s
      };
    }
    function kU(s) {
      return {
        $$typeof: vg,
        value: s
      };
    }
    function A_(s) {
      var a = W0(s);
      if (a != null) {
        if (typeof a.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return a;
      } else {
        var p = An(s);
        if (p === null)
          throw new Error("Could not find React container within specified host subtree.");
        return p.stateNode.current;
      }
    }
    function R_(s, a) {
      switch (a.$$typeof) {
        case hg:
          if (s.type === a.value)
            return !0;
          break;
        case pg:
          return GU(s, a.value);
        case mg:
          if (s.tag === O) {
            var p = s.stateNode;
            if (Y0(p, a.value))
              return !0;
          }
          break;
        case gg:
          if (s.tag === O || s.tag === q) {
            var v = ph(s);
            if (v !== null && v.indexOf(a.value) >= 0)
              return !0;
          }
          break;
        case vg:
          if (s.tag === O) {
            var S = s.memoizedProps["data-testname"];
            if (typeof S == "string" && S.toLowerCase() === a.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function C_(s) {
      switch (s.$$typeof) {
        case hg:
          var a = Xe(s.value) || "Unknown";
          return "<" + a + ">";
        case pg:
          return ":has(" + (C_(s) || "") + ")";
        case mg:
          return '[role="' + s.value + '"]';
        case gg:
          return '"' + s.value + '"';
        case vg:
          return '[data-testname="' + s.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function N1(s, a) {
      for (var p = [], v = [s, 0], S = 0; S < v.length; ) {
        var R = v[S++], L = v[S++], F = a[L];
        if (!(R.tag === O && cl(R))) {
          for (; F != null && R_(R, F); )
            L++, F = a[L];
          if (L === a.length)
            p.push(R);
          else
            for (var H = R.child; H !== null; )
              v.push(H, L), H = H.sibling;
        }
      }
      return p;
    }
    function GU(s, a) {
      for (var p = [s, 0], v = 0; v < p.length; ) {
        var S = p[v++], R = p[v++], L = a[R];
        if (!(S.tag === O && cl(S))) {
          for (; L != null && R_(S, L); )
            R++, L = a[R];
          if (R === a.length)
            return !0;
          for (var F = S.child; F !== null; )
            p.push(F, R), F = F.sibling;
        }
      }
      return !1;
    }
    function yg(s, a) {
      if (!ja)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var p = A_(s), v = N1(p, a), S = [], R = Array.from(v), L = 0; L < R.length; ) {
        var F = R[L++];
        if (F.tag === O) {
          if (cl(F))
            continue;
          S.push(F.stateNode);
        } else
          for (var H = F.child; H !== null; )
            R.push(H), H = H.sibling;
      }
      return S;
    }
    function WU(s, a) {
      if (!ja)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var p = A_(s), v = 0, S = [], R = [p, 0], L = 0; L < R.length; ) {
        var F = R[L++], H = R[L++], Z = a[H];
        if (!(F.tag === O && cl(F)) && (R_(F, Z) && (S.push(C_(Z)), H++, H > v && (v = H)), H < a.length))
          for (var te = F.child; te !== null; )
            R.push(te, H), te = te.sibling;
      }
      if (v < a.length) {
        for (var xe = [], we = v; we < a.length; we++)
          xe.push(C_(a[we]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + S.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + xe.join(" > "));
      }
      return null;
    }
    function XU(s, a) {
      if (!ja)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var p = yg(s, a), v = [], S = 0; S < p.length; S++)
        v.push(Ym(p[S]));
      for (var R = v.length - 1; R > 0; R--)
        for (var L = v[R], F = L.x, H = F + L.width, Z = L.y, te = Z + L.height, xe = R - 1; xe >= 0; xe--)
          if (R !== xe) {
            var we = v[xe], De = we.x, We = De + we.width, Je = we.y, Vt = Je + we.height;
            if (F >= De && Z >= Je && H <= We && te <= Vt) {
              v.splice(R, 1);
              break;
            } else if (F === De && L.width === we.width && !(Vt < Z) && !(Je > te)) {
              Je > Z && (we.height += Je - Z, we.y = Z), Vt < te && (we.height = te - Je), v.splice(R, 1);
              break;
            } else if (Z === Je && L.height === we.height && !(We < F) && !(De > H)) {
              De > F && (we.width += De - F, we.x = F), We < H && (we.width = H - De), v.splice(R, 1);
              break;
            }
          }
      return v;
    }
    function jU(s, a) {
      if (!ja)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var p = A_(s), v = N1(p, a), S = Array.from(v), R = 0; R < S.length; ) {
        var L = S[R++];
        if (!cl(L)) {
          if (L.tag === O) {
            var F = L.stateNode;
            if (q0(F))
              return !0;
          }
          for (var H = L.child; H !== null; )
            S.push(H), H = H.sibling;
        }
      }
      return !1;
    }
    var xg = [];
    function YU() {
      ja && xg.forEach(function(s) {
        return s();
      });
    }
    function qU(s, a, p, v) {
      if (!ja)
        throw new Error("Test selector API is not supported by this renderer.");
      var S = yg(s, a), R = Vi(S, p, v), L = R.disconnect, F = R.observe, H = R.unobserve, Z = function() {
        var te = yg(s, a);
        S.forEach(function(xe) {
          te.indexOf(xe) < 0 && H(xe);
        }), te.forEach(function(xe) {
          S.indexOf(xe) < 0 && F(xe);
        });
      };
      return xg.push(Z), {
        disconnect: function() {
          var te = xg.indexOf(Z);
          te >= 0 && xg.splice(te, 1), L();
        }
      };
    }
    var ZU = o.ReactCurrentActQueue;
    function KU(s) {
      {
        var a = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), p = typeof jest < "u";
        return Jc && p && a !== !1;
      }
    }
    function U1() {
      {
        var s = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !s && ZU.current !== null && h("The current testing environment is not configured to support act(...)"), s;
      }
    }
    var JU = Math.ceil, P_ = o.ReactCurrentDispatcher, L_ = o.ReactCurrentOwner, ai = o.ReactCurrentBatchConfig, Na = o.ReactCurrentActQueue, Wi = (
      /*             */
      0
    ), D_ = (
      /*               */
      1
    ), zr = (
      /*                */
      2
    ), Ua = (
      /*                */
      4
    ), Go = 0, yp = 1, ic = 2, _g = 3, xp = 4, O1 = 5, N_ = 6, cn = Wi, Br = null, oi = null, $i = Ge, co = Ge, U_ = Js(Ge), er = Go, _p = null, Sg = Ge, Sp = Ge, Mg = Ge, Mp = null, xs = null, O_ = 0, I1 = 500, F1 = 1 / 0, QU = 500;
    function cd() {
      F1 = Ri() + QU;
    }
    function z1() {
      return F1;
    }
    var Eg = !1, I_ = null, fd = null, rc = !1, Wo = null, Ep = Ge, F_ = [], $U = 50, bp = 0, z_ = null, e3 = 50, bg = 0, Tp = Fn, Tg = Ge;
    function wg() {
      return Br;
    }
    function $r() {
      return (cn & (zr | Ua)) !== Wi ? Ri() : (Tp !== Fn || (Tp = Ri()), Tp);
    }
    function ql(s) {
      var a = s.mode;
      if ((a & Rn) === Yt)
        return ln;
      if ((cn & zr) !== Wi && $i !== Ge)
        return Do($i);
      var p = Kh() !== yv;
      if (p) {
        if (ai.transition !== null) {
          var v = ai.transition;
          v._updatedFibers || (v._updatedFibers = /* @__PURE__ */ new Set()), v._updatedFibers.add(s);
        }
        return Tg === ri && (Tg = Pf()), Tg;
      }
      var S = ms();
      if (S !== ri)
        return S;
      var R = dh();
      return R;
    }
    function t3(s) {
      var a = s.mode;
      return (a & Rn) === Yt ? ln : Lf();
    }
    function tr(s, a, p) {
      R3();
      var v = Ag(s, a);
      return v === null ? null : (Ls(v, a, p), (cn & zr) !== Ge && v === Br ? L3(s) : (Kr && hv(v, s, a), D3(s), v === Br && ((cn & zr) === Wi && (Sp = nn(Sp, a)), er === xp && Zl(v, $i)), _s(v, p), a === ln && cn === Wi && (s.mode & Rn) === Yt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Na.isBatchingLegacy && (cd(), Xf())), v);
    }
    function n3(s, a, p) {
      var v = s.current;
      v.lanes = a, Ls(s, a, p), _s(s, p);
    }
    function Ag(s, a) {
      s.lanes = nn(s.lanes, a);
      var p = s.alternate;
      p !== null && (p.lanes = nn(p.lanes, a)), p === null && (s.flags & (Ve | Jt)) !== he && Q1(s);
      for (var v = s, S = s.return; S !== null; )
        S.childLanes = nn(S.childLanes, a), p = S.alternate, p !== null ? p.childLanes = nn(p.childLanes, a) : (S.flags & (Ve | Jt)) !== he && Q1(s), v = S, S = S.return;
      if (v.tag === W) {
        var R = v.stateNode;
        return R;
      } else
        return null;
    }
    function B1(s, a) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        Br !== null && (s.mode & Rn) !== Yt && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (cn & zr) === Wi
      );
    }
    function _s(s, a) {
      var p = s.callbackNode;
      ov(s, a);
      var v = wf(s, s === Br ? $i : Ge);
      if (v === Ge) {
        p !== null && ew(p), s.callbackNode = null, s.callbackPriority = ri;
        return;
      }
      var S = no(v), R = s.callbackPriority;
      if (R === S && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Na.current !== null && p !== W_)) {
        p == null && R !== ln && h("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      p != null && ew(p);
      var L;
      if (S === ln)
        s.tag === pr ? (Na.isBatchingLegacy !== null && (Na.didScheduleLegacyUpdate = !0), Zh(k1.bind(null, s))) : qh(k1.bind(null, s)), wu ? Na.current !== null ? Na.current.push(ea) : j0(function() {
          cn === Wi && ea();
        }) : Ug(Vu, ea), L = null;
      else {
        var F;
        switch (Of(v)) {
          case Ur:
            F = Vu;
            break;
          case Uo:
            F = Hh;
            break;
          case Rl:
            F = ba;
            break;
          case Uf:
            F = Hu;
            break;
          default:
            F = ba;
            break;
        }
        L = Ug(F, V1.bind(null, s));
      }
      s.callbackPriority = S, s.callbackNode = L;
    }
    function V1(s, a) {
      if (pN(), Tp = Fn, Tg = Ge, (cn & (zr | Ua)) !== Wi)
        throw new Error("Should not already be working.");
      var p = s.callbackNode, v = fo();
      if (v && s.callbackNode !== p)
        return null;
      var S = wf(s, s === Br ? $i : Ge);
      if (S === Ge)
        return null;
      var R = !wl(s, S) && !fv(s, S) && !a, L = R ? v3(s, S) : Lg(s, S);
      if (L !== Go) {
        if (L === ic) {
          var F = Af(s);
          F !== Ge && (S = F, L = B_(s, F));
        }
        if (L === yp) {
          var H = _p;
          throw sc(s, Ge), Zl(s, S), _s(s, Ri()), H;
        }
        if (L === N_)
          Zl(s, S);
        else {
          var Z = !wl(s, S), te = s.current.alternate;
          if (Z && !r3(te)) {
            if (L = Lg(s, S), L === ic) {
              var xe = Af(s);
              xe !== Ge && (S = xe, L = B_(s, xe));
            }
            if (L === yp) {
              var we = _p;
              throw sc(s, Ge), Zl(s, S), _s(s, Ri()), we;
            }
          }
          s.finishedWork = te, s.finishedLanes = S, i3(s, L, S);
        }
      }
      return _s(s, Ri()), s.callbackNode === p ? V1.bind(null, s) : null;
    }
    function B_(s, a) {
      var p = Mp;
      if (Aa(s)) {
        var v = sc(s, a);
        v.flags |= qt, Ao(s.containerInfo);
      }
      var S = Lg(s, a);
      if (S !== ic) {
        var R = xs;
        xs = p, R !== null && H1(R);
      }
      return S;
    }
    function H1(s) {
      xs === null ? xs = s : xs.push.apply(xs, s);
    }
    function i3(s, a, p) {
      switch (a) {
        case Go:
        case yp:
          throw new Error("Root did not complete. This is a bug in React.");
        case ic: {
          ac(s, xs);
          break;
        }
        case _g: {
          if (Zl(s, p), Cf(p) && // do not delay if we're inside an act() scope
          !tw()) {
            var v = O_ + I1 - Ri();
            if (v > 10) {
              var S = wf(s, Ge);
              if (S !== Ge)
                break;
              var R = s.suspendedLanes;
              if (!No(R, p)) {
                $r(), gt(s, R);
                break;
              }
              s.timeoutHandle = Rr(ac.bind(null, s, xs), v);
              break;
            }
          }
          ac(s, xs);
          break;
        }
        case xp: {
          if (Zl(s, p), cv(p))
            break;
          if (!tw()) {
            var L = Zr(s, p), F = L, H = Ri() - F, Z = A3(H) - H;
            if (Z > 10) {
              s.timeoutHandle = Rr(ac.bind(null, s, xs), Z);
              break;
            }
          }
          ac(s, xs);
          break;
        }
        case O1: {
          ac(s, xs);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function r3(s) {
      for (var a = s; ; ) {
        if (a.flags & va) {
          var p = a.updateQueue;
          if (p !== null) {
            var v = p.stores;
            if (v !== null)
              for (var S = 0; S < v.length; S++) {
                var R = v[S], L = R.getSnapshot, F = R.value;
                try {
                  if (!Pi(L(), F))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var H = a.child;
        if (a.subtreeFlags & va && H !== null) {
          H.return = a, a = H;
          continue;
        }
        if (a === s)
          return !0;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === s)
            return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !0;
    }
    function Zl(s, a) {
      a = Fu(a, Mg), a = Fu(a, Sp), nx(s, a);
    }
    function k1(s) {
      if (mN(), (cn & (zr | Ua)) !== Wi)
        throw new Error("Should not already be working.");
      fo();
      var a = wf(s, Ge);
      if (!lr(a, ln))
        return _s(s, Ri()), null;
      var p = Lg(s, a);
      if (s.tag !== pr && p === ic) {
        var v = Af(s);
        v !== Ge && (a = v, p = B_(s, v));
      }
      if (p === yp) {
        var S = _p;
        throw sc(s, Ge), Zl(s, a), _s(s, Ri()), S;
      }
      if (p === N_)
        throw new Error("Root did not complete. This is a bug in React.");
      var R = s.current.alternate;
      return s.finishedWork = R, s.finishedLanes = a, ac(s, xs), _s(s, Ri()), null;
    }
    function s3(s, a) {
      a !== Ge && (zu(s, nn(a, ln)), _s(s, Ri()), (cn & (zr | Ua)) === Wi && (cd(), ea()));
    }
    function a3(s) {
      var a = ms(), p = ai.transition;
      try {
        return ai.transition = null, Ai(Rl), s();
      } finally {
        Ai(a), ai.transition = p;
      }
    }
    function o3(s, a) {
      var p = cn;
      cn |= D_;
      try {
        return s(a);
      } finally {
        cn = p, cn === Wi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Na.isBatchingLegacy && (cd(), Xf());
      }
    }
    function l3(s, a, p, v, S) {
      var R = ms(), L = ai.transition;
      try {
        return ai.transition = null, Ai(Ur), s(a, p, v, S);
      } finally {
        Ai(R), ai.transition = L, cn === Wi && cd();
      }
    }
    function Rg(s) {
      Wo !== null && Wo.tag === pr && (cn & (zr | Ua)) === Wi && fo();
      var a = cn;
      cn |= D_;
      var p = ai.transition, v = ms();
      try {
        return ai.transition = null, Ai(Ur), s ? s() : void 0;
      } finally {
        Ai(v), ai.transition = p, cn = a, (cn & (zr | Ua)) === Wi && ea();
      }
    }
    function u3() {
      return (cn & (zr | Ua)) !== Wi;
    }
    function c3(s) {
      var a = cn;
      cn |= D_;
      var p = ai.transition, v = ms();
      try {
        ai.transition = null, Ai(Ur), s();
      } finally {
        Ai(v), ai.transition = p, cn = a, cn === Wi && (cd(), ea());
      }
    }
    function Cg(s, a) {
      mi(U_, co, s), co = nn(co, a);
    }
    function V_(s) {
      co = U_.current, pn(U_, s);
    }
    function sc(s, a) {
      s.finishedWork = null, s.finishedLanes = Ge;
      var p = s.timeoutHandle;
      if (p !== fh && (s.timeoutHandle = fh, Zc(p)), oi !== null)
        for (var v = oi.return; v !== null; ) {
          var S = v.alternate;
          f1(S, v), v = v.return;
        }
      Br = s;
      var R = oc(s.current, null);
      return oi = R, $i = co = a, er = Go, _p = null, Sg = Ge, Sp = Ge, Mg = Ge, Mp = null, xs = null, et(), Ji.discardPendingWarnings(), R;
    }
    function G1(s, a) {
      do {
        var p = oi;
        try {
          if (Vl(), cT(), Ki(), L_.current = null, p === null || p.return === null) {
            er = yp, _p = a, oi = null;
            return;
          }
          if (A && p.mode & Tn && $v(p, !0), C)
            if (Ds(), a !== null && typeof a == "object" && typeof a.then == "function") {
              var v = a;
              Ll(p, v, $i);
            } else
              Xh(p, a, $i);
          _N(s, p.return, p, a, $i), Y1(p);
        } catch (S) {
          a = S, oi === p && p !== null ? (p = p.return, oi = p) : p = oi;
          continue;
        }
        return;
      } while (!0);
    }
    function W1() {
      var s = P_.current;
      return P_.current = qv, s === null ? qv : s;
    }
    function X1(s) {
      P_.current = s;
    }
    function f3() {
      O_ = Ri();
    }
    function Pg(s) {
      Sg = nn(s, Sg);
    }
    function d3() {
      er === Go && (er = _g);
    }
    function H_() {
      (er === Go || er === _g || er === ic) && (er = xp), Br !== null && (Rf(Sg) || Rf(Sp)) && Zl(Br, $i);
    }
    function h3(s) {
      er !== xp && (er = ic), Mp === null ? Mp = [s] : Mp.push(s);
    }
    function p3() {
      return er === Go;
    }
    function Lg(s, a) {
      var p = cn;
      cn |= zr;
      var v = W1();
      if (Br !== s || $i !== a) {
        if (Kr) {
          var S = s.memoizedUpdaters;
          S.size > 0 && (wp(s, $i), S.clear()), ro(s, a);
        }
        sc(s, a);
      }
      wa(a);
      do
        try {
          m3();
          break;
        } catch (R) {
          G1(s, R);
        }
      while (!0);
      if (Vl(), cn = p, X1(v), oi !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Dl(), Br = null, $i = Ge, er;
    }
    function m3() {
      for (; oi !== null; )
        j1(oi);
    }
    function v3(s, a) {
      var p = cn;
      cn |= zr;
      var v = W1();
      if (Br !== s || $i !== a) {
        if (Kr) {
          var S = s.memoizedUpdaters;
          S.size > 0 && (wp(s, $i), S.clear()), ro(s, a);
        }
        cd(), sc(s, a);
      }
      wa(a);
      do
        try {
          g3();
          break;
        } catch (R) {
          G1(s, R);
        }
      while (!0);
      return Vl(), X1(v), cn = p, oi !== null ? (Gf(), Go) : (Dl(), Br = null, $i = Ge, er);
    }
    function g3() {
      for (; oi !== null && !rx(); )
        j1(oi);
    }
    function j1(s) {
      var a = s.alternate;
      jn(s);
      var p;
      (s.mode & Tn) !== Yt ? (i_(s), p = k_(a, s, co), $v(s, !0)) : p = k_(a, s, co), Ki(), s.memoizedProps = s.pendingProps, p === null ? Y1(s) : oi = p, L_.current = null;
    }
    function Y1(s) {
      var a = s;
      do {
        var p = a.alternate, v = a.return;
        if ((a.flags & ws) === he) {
          jn(a);
          var S = void 0;
          if ((a.mode & Tn) === Yt ? S = WT(p, a, co) : (i_(a), S = WT(p, a, co), $v(a, !1)), Ki(), S !== null) {
            oi = S;
            return;
          }
        } else {
          var R = YN(p, a);
          if (R !== null) {
            R.flags &= Mo, oi = R;
            return;
          }
          if ((a.mode & Tn) !== Yt) {
            $v(a, !1);
            for (var L = a.actualDuration, F = a.child; F !== null; )
              L += F.actualDuration, F = F.sibling;
            a.actualDuration = L;
          }
          if (v !== null)
            v.flags |= ws, v.subtreeFlags = he, v.deletions = null;
          else {
            er = N_, oi = null;
            return;
          }
        }
        var H = a.sibling;
        if (H !== null) {
          oi = H;
          return;
        }
        a = v, oi = a;
      } while (a !== null);
      er === Go && (er = O1);
    }
    function ac(s, a) {
      var p = ms(), v = ai.transition;
      try {
        ai.transition = null, Ai(Ur), y3(s, a, p);
      } finally {
        ai.transition = v, Ai(p);
      }
      return null;
    }
    function y3(s, a, p) {
      do
        fo();
      while (Wo !== null);
      if (C3(), (cn & (zr | Ua)) !== Wi)
        throw new Error("Should not already be working.");
      var v = s.finishedWork, S = s.finishedLanes;
      if (yi(S), v === null)
        return Hi(), null;
      if (S === Ge && h("root.finishedLanes should not be empty during a commit. This is a bug in React."), s.finishedWork = null, s.finishedLanes = Ge, v === s.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      s.callbackNode = null, s.callbackPriority = ri;
      var R = nn(v.lanes, v.childLanes);
      Nf(s, R), s === Br && (Br = null, oi = null, $i = Ge), ((v.subtreeFlags & me) !== he || (v.flags & me) !== he) && (rc || (rc = !0, Ug(ba, function() {
        return fo(), null;
      })));
      var L = (v.subtreeFlags & (ne | ge | ve | me)) !== he, F = (v.flags & (ne | ge | ve | me)) !== he;
      if (L || F) {
        var H = ai.transition;
        ai.transition = null;
        var Z = ms();
        Ai(Ur);
        var te = cn;
        cn |= Ua, L_.current = null, eU(s, v), OT(), vU(s, v, S), ls(s.containerInfo), s.current = v, Hf(S), _U(v, s, S), jh(), mv(), cn = te, Ai(Z), ai.transition = H;
      } else
        s.current = v, OT();
      var xe = rc;
      if (rc && (rc = !1, Wo = s, Ep = S), R = s.pendingLanes, R === Ge && (fd = null), xe || J1(s.current, !1), sx(v.stateNode, p), Kr && s.memoizedUpdaters.clear(), YU(), _s(s, Ri()), a !== null)
        for (var we = s.onRecoverableError, De = 0; De < a.length; De++) {
          var We = a[De];
          we(We);
        }
      if (Eg) {
        Eg = !1;
        var Je = I_;
        throw I_ = null, Je;
      }
      return lr(Ep, ln) && s.tag !== pr && fo(), R = s.pendingLanes, lr(R, ln) ? (hN(), s === z_ ? bp++ : (bp = 0, z_ = s)) : bp = 0, ea(), Hi(), null;
    }
    function fo() {
      if (Wo !== null) {
        var s = Of(Ep), a = Bh(Rl, s), p = ai.transition, v = ms();
        try {
          return ai.transition = null, Ai(a), _3();
        } finally {
          Ai(v), ai.transition = p;
        }
      }
      return !1;
    }
    function x3(s) {
      F_.push(s), rc || (rc = !0, Ug(ba, function() {
        return fo(), null;
      }));
    }
    function _3() {
      if (Wo === null)
        return !1;
      var s = Wo, a = Ep;
      if (Wo = null, Ep = Ge, (cn & (zr | Ua)) !== Wi)
        throw new Error("Cannot flush passive effects while already rendering.");
      so(a);
      var p = cn;
      cn |= Ua, AU(s.current), EU(s, s.current);
      {
        var v = F_;
        F_ = [];
        for (var S = 0; S < v.length; S++) {
          var R = v[S];
          rU(s, R);
        }
      }
      kf(), J1(s.current, !0), cn = p, ea(), bg = Wo === null ? 0 : bg + 1, zf(s);
      {
        var L = s.current.stateNode;
        L.effectDuration = 0, L.passiveEffectDuration = 0;
      }
      return !0;
    }
    function q1(s) {
      return fd !== null && fd.has(s);
    }
    function S3(s) {
      fd === null ? fd = /* @__PURE__ */ new Set([s]) : fd.add(s);
    }
    function M3(s) {
      Eg || (Eg = !0, I_ = s);
    }
    var E3 = M3;
    function Z1(s, a, p) {
      var v = eg(p, a), S = FT(s, v, ln);
      ut(s, S);
      var R = $r(), L = Ag(s, ln);
      L !== null && (Ls(L, ln, R), _s(L, R));
    }
    function Tr(s, a, p) {
      if (s.tag === W) {
        Z1(s, s, p);
        return;
      }
      var v = null;
      for (v = a; v !== null; ) {
        if (v.tag === W) {
          Z1(v, s, p);
          return;
        } else if (v.tag === I) {
          var S = v.type, R = v.stateNode;
          if (typeof S.getDerivedStateFromError == "function" || typeof R.componentDidCatch == "function" && !q1(R)) {
            var L = eg(p, s), F = l_(v, L, ln);
            ut(v, F);
            var H = $r(), Z = Ag(v, ln);
            Z !== null && (Ls(Z, ln, H), _s(Z, H));
            return;
          }
        }
        v = v.return;
      }
      h(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, p);
    }
    function b3(s, a, p) {
      var v = s.pingCache;
      v !== null && v.delete(a);
      var S = $r();
      gt(s, p), N3(s), Br === s && No($i, p) && (er === xp || er === _g && Cf($i) && Ri() - O_ < I1 ? sc(s, Ge) : Mg = nn(Mg, p)), _s(s, S);
    }
    function K1(s, a) {
      a === ri && (a = t3(s));
      var p = $r(), v = Ag(s, a);
      v !== null && (Ls(v, a, p), _s(v, p));
    }
    function T3(s) {
      var a = s.memoizedState, p = ri;
      a !== null && (p = a.retryLane), K1(s, p);
    }
    function w3(s, a) {
      var p = ri, v;
      switch (s.tag) {
        case Q:
          v = s.stateNode;
          var S = s.memoizedState;
          S !== null && (p = S.retryLane);
          break;
        case Ae:
          v = s.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      v !== null && v.delete(a), K1(s, p);
    }
    function A3(s) {
      return s < 120 ? 120 : s < 480 ? 480 : s < 1080 ? 1080 : s < 1920 ? 1920 : s < 3e3 ? 3e3 : s < 4320 ? 4320 : JU(s / 1960) * 1960;
    }
    function R3() {
      if (bp > $U)
        throw bp = 0, z_ = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      bg > e3 && (bg = 0, h("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function C3() {
      Ji.flushLegacyContextWarning(), Ji.flushPendingUnsafeLifecycleWarnings();
    }
    function J1(s, a) {
      jn(s), Dg(s, hn, IU), a && Dg(s, k, FU), Dg(s, hn, UU), a && Dg(s, k, OU), Ki();
    }
    function Dg(s, a, p) {
      for (var v = s, S = null; v !== null; ) {
        var R = v.subtreeFlags & a;
        v !== S && v.child !== null && R !== he ? v = v.child : ((v.flags & a) !== he && p(v), v.sibling !== null ? v = v.sibling : v = S = v.return);
      }
    }
    var Ng = null;
    function Q1(s) {
      {
        if ((cn & zr) !== Wi || !(s.mode & Rn))
          return;
        var a = s.tag;
        if (a !== V && a !== W && a !== I && a !== z && a !== ie && a !== se && a !== re)
          return;
        var p = Y(s) || "ReactComponent";
        if (Ng !== null) {
          if (Ng.has(p))
            return;
          Ng.add(p);
        } else
          Ng = /* @__PURE__ */ new Set([p]);
        var v = yr;
        try {
          jn(s), h("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          v ? jn(s) : Ki();
        }
      }
    }
    var k_;
    {
      var P3 = null;
      k_ = function(s, a, p) {
        var v = aw(P3, a);
        try {
          return c1(s, a, p);
        } catch (R) {
          if (R !== null && typeof R == "object" && typeof R.then == "function")
            throw R;
          if (Vl(), cT(), f1(s, a), aw(a, v), a.mode & Tn && i_(a), p1(null, c1, null, s, a, p), KN()) {
            var S = m1();
            typeof S == "object" && S !== null && S._suppressLogging && typeof R == "object" && R !== null && !R._suppressLogging && (R._suppressLogging = !0);
          }
          throw R;
        }
      };
    }
    var $1 = !1, G_;
    G_ = /* @__PURE__ */ new Set();
    function L3(s) {
      if (Wu && !cN())
        switch (s.tag) {
          case z:
          case ie:
          case re: {
            var a = oi && Y(oi) || "Unknown", p = a;
            if (!G_.has(p)) {
              G_.add(p);
              var v = Y(s) || "Unknown";
              h("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", v, a, a);
            }
            break;
          }
          case I: {
            $1 || (h("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), $1 = !0);
            break;
          }
        }
    }
    function wp(s, a) {
      if (Kr) {
        var p = s.memoizedUpdaters;
        p.forEach(function(v) {
          hv(s, v, a);
        });
      }
    }
    var W_ = {};
    function Ug(s, a) {
      {
        var p = Na.current;
        return p !== null ? (p.push(a), W_) : Bu(s, a);
      }
    }
    function ew(s) {
      if (s !== W_)
        return ix(s);
    }
    function tw() {
      return Na.current !== null;
    }
    function D3(s) {
      {
        if (s.mode & Rn) {
          if (!U1())
            return;
        } else if (!KU() || cn !== Wi || s.tag !== z && s.tag !== ie && s.tag !== re)
          return;
        if (Na.current === null) {
          var a = yr;
          try {
            jn(s), h(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Y(s));
          } finally {
            a ? jn(s) : Ki();
          }
        }
      }
    }
    function N3(s) {
      s.tag !== pr && U1() && Na.current === null && h(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var ca = null, dd = null, U3 = function(s) {
      ca = s;
    };
    function hd(s) {
      {
        if (ca === null)
          return s;
        var a = ca(s);
        return a === void 0 ? s : a.current;
      }
    }
    function X_(s) {
      return hd(s);
    }
    function j_(s) {
      {
        if (ca === null)
          return s;
        var a = ca(s);
        if (a === void 0) {
          if (s != null && typeof s.render == "function") {
            var p = hd(s.render);
            if (s.render !== p) {
              var v = {
                $$typeof: _t,
                render: p
              };
              return s.displayName !== void 0 && (v.displayName = s.displayName), v;
            }
          }
          return s;
        }
        return a.current;
      }
    }
    function nw(s, a) {
      {
        if (ca === null)
          return !1;
        var p = s.elementType, v = a.type, S = !1, R = typeof v == "object" && v !== null ? v.$$typeof : null;
        switch (s.tag) {
          case I: {
            typeof v == "function" && (S = !0);
            break;
          }
          case z: {
            (typeof v == "function" || R === ce) && (S = !0);
            break;
          }
          case ie: {
            (R === _t || R === ce) && (S = !0);
            break;
          }
          case se:
          case re: {
            (R === B || R === ce) && (S = !0);
            break;
          }
          default:
            return !1;
        }
        if (S) {
          var L = ca(p);
          if (L !== void 0 && L === ca(v))
            return !0;
        }
        return !1;
      }
    }
    function iw(s) {
      {
        if (ca === null || typeof WeakSet != "function")
          return;
        dd === null && (dd = /* @__PURE__ */ new WeakSet()), dd.add(s);
      }
    }
    var O3 = function(s, a) {
      {
        if (ca === null)
          return;
        var p = a.staleFamilies, v = a.updatedFamilies;
        fo(), Rg(function() {
          Y_(s.current, v, p);
        });
      }
    }, I3 = function(s, a) {
      {
        if (s.context !== hr)
          return;
        fo(), Rg(function() {
          uw(a, s, null, null);
        });
      }
    };
    function Y_(s, a, p) {
      {
        var v = s.alternate, S = s.child, R = s.sibling, L = s.tag, F = s.type, H = null;
        switch (L) {
          case z:
          case re:
          case I:
            H = F;
            break;
          case ie:
            H = F.render;
            break;
        }
        if (ca === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Z = !1, te = !1;
        if (H !== null) {
          var xe = ca(H);
          xe !== void 0 && (p.has(xe) ? te = !0 : a.has(xe) && (L === I ? te = !0 : Z = !0));
        }
        dd !== null && (dd.has(s) || v !== null && dd.has(v)) && (te = !0), te && (s._debugNeedsRemount = !0), (te || Z) && tr(s, ln, Fn), S !== null && !te && Y_(S, a, p), R !== null && Y_(R, a, p);
      }
    }
    var F3 = function(s, a) {
      {
        var p = /* @__PURE__ */ new Set(), v = new Set(a.map(function(S) {
          return S.current;
        }));
        return q_(s.current, v, p), p;
      }
    };
    function q_(s, a, p) {
      {
        var v = s.child, S = s.sibling, R = s.tag, L = s.type, F = null;
        switch (R) {
          case z:
          case re:
          case I:
            F = L;
            break;
          case ie:
            F = L.render;
            break;
        }
        var H = !1;
        F !== null && a.has(F) && (H = !0), H ? z3(s, p) : v !== null && q_(v, a, p), S !== null && q_(S, a, p);
      }
    }
    function z3(s, a) {
      {
        var p = B3(s, a);
        if (p)
          return;
        for (var v = s; ; ) {
          switch (v.tag) {
            case O:
              a.add(v.stateNode);
              return;
            case U:
              a.add(v.stateNode.containerInfo);
              return;
            case W:
              a.add(v.stateNode.containerInfo);
              return;
          }
          if (v.return === null)
            throw new Error("Expected to reach root first.");
          v = v.return;
        }
      }
    }
    function B3(s, a) {
      for (var p = s, v = !1; ; ) {
        if (p.tag === O)
          v = !0, a.add(p.stateNode);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === s)
          return v;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === s)
            return v;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
      return !1;
    }
    var Z_;
    {
      Z_ = !1;
      try {
        var rw = Object.preventExtensions({});
      } catch {
        Z_ = !0;
      }
    }
    function V3(s, a, p, v) {
      this.tag = s, this.key = p, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = a, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = v, this.flags = he, this.subtreeFlags = he, this.deletions = null, this.lanes = Ge, this.childLanes = Ge, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Z_ && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Us = function(s, a, p, v) {
      return new V3(s, a, p, v);
    };
    function K_(s) {
      var a = s.prototype;
      return !!(a && a.isReactComponent);
    }
    function H3(s) {
      return typeof s == "function" && !K_(s) && s.defaultProps === void 0;
    }
    function k3(s) {
      if (typeof s == "function")
        return K_(s) ? I : z;
      if (s != null) {
        var a = s.$$typeof;
        if (a === _t)
          return ie;
        if (a === B)
          return se;
      }
      return V;
    }
    function oc(s, a) {
      var p = s.alternate;
      p === null ? (p = Us(s.tag, a, s.key, s.mode), p.elementType = s.elementType, p.type = s.type, p.stateNode = s.stateNode, p._debugSource = s._debugSource, p._debugOwner = s._debugOwner, p._debugHookTypes = s._debugHookTypes, p.alternate = s, s.alternate = p) : (p.pendingProps = a, p.type = s.type, p.flags = he, p.subtreeFlags = he, p.deletions = null, p.actualDuration = 0, p.actualStartTime = -1), p.flags = s.flags & Qe, p.childLanes = s.childLanes, p.lanes = s.lanes, p.child = s.child, p.memoizedProps = s.memoizedProps, p.memoizedState = s.memoizedState, p.updateQueue = s.updateQueue;
      var v = s.dependencies;
      switch (p.dependencies = v === null ? null : {
        lanes: v.lanes,
        firstContext: v.firstContext
      }, p.sibling = s.sibling, p.index = s.index, p.ref = s.ref, p.selfBaseDuration = s.selfBaseDuration, p.treeBaseDuration = s.treeBaseDuration, p._debugNeedsRemount = s._debugNeedsRemount, p.tag) {
        case V:
        case z:
        case re:
          p.type = hd(s.type);
          break;
        case I:
          p.type = X_(s.type);
          break;
        case ie:
          p.type = j_(s.type);
          break;
      }
      return p;
    }
    function G3(s, a) {
      s.flags &= Qe | Ve;
      var p = s.alternate;
      if (p === null)
        s.childLanes = Ge, s.lanes = a, s.child = null, s.subtreeFlags = he, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null, s.selfBaseDuration = 0, s.treeBaseDuration = 0;
      else {
        s.childLanes = p.childLanes, s.lanes = p.lanes, s.child = p.child, s.subtreeFlags = he, s.deletions = null, s.memoizedProps = p.memoizedProps, s.memoizedState = p.memoizedState, s.updateQueue = p.updateQueue, s.type = p.type;
        var v = p.dependencies;
        s.dependencies = v === null ? null : {
          lanes: v.lanes,
          firstContext: v.firstContext
        }, s.selfBaseDuration = p.selfBaseDuration, s.treeBaseDuration = p.treeBaseDuration;
      }
      return s;
    }
    function W3(s, a, p) {
      var v;
      return s === Qa ? (v = Rn, a === !0 && (v |= ii, v |= Cs)) : v = Yt, Kr && (v |= Tn), Us(W, null, null, v);
    }
    function J_(s, a, p, v, S, R) {
      var L = V, F = s;
      if (typeof s == "function")
        K_(s) ? (L = I, F = X_(F)) : F = hd(F);
      else if (typeof s == "string")
        L = O;
      else
        e: switch (s) {
          case J:
            return Kl(p.children, S, R, a);
          case Be:
            L = ye, S |= ii, (S & Rn) !== Yt && (S |= Cs);
            break;
          case Pe:
            return X3(p, S, R, a);
          case rt:
            return j3(p, S, R, a);
          case G:
            return Y3(p, S, R, a);
          case Ie:
            return sw(p, S, R, a);
          case Mt:
          case Fe:
          case it:
          case mt:
          case ze:
          default: {
            if (typeof s == "object" && s !== null)
              switch (s.$$typeof) {
                case He:
                  L = oe;
                  break e;
                case Re:
                  L = K;
                  break e;
                case _t:
                  L = ie, F = j_(F);
                  break e;
                case B:
                  L = se;
                  break e;
                case ce:
                  L = ue, F = null;
                  break e;
              }
            var H = "";
            {
              (s === void 0 || typeof s == "object" && s !== null && Object.keys(s).length === 0) && (H += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var Z = v ? Y(v) : null;
              Z && (H += `

Check the render method of \`` + Z + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (s == null ? s : typeof s) + "." + H));
          }
        }
      var te = Us(L, p, a, S);
      return te.elementType = s, te.type = F, te.lanes = R, te._debugOwner = v, te;
    }
    function Q_(s, a, p) {
      var v = null;
      v = s._owner;
      var S = s.type, R = s.key, L = s.props, F = J_(S, R, L, v, a, p);
      return F._debugSource = s._source, F._debugOwner = s._owner, F;
    }
    function Kl(s, a, p, v) {
      var S = Us(le, s, v, a);
      return S.lanes = p, S;
    }
    function X3(s, a, p, v) {
      typeof s.id != "string" && h('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof s.id);
      var S = Us(Ee, s, v, a | Tn);
      return S.elementType = Pe, S.lanes = p, S.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, S;
    }
    function j3(s, a, p, v) {
      var S = Us(Q, s, v, a);
      return S.elementType = rt, S.lanes = p, S;
    }
    function Y3(s, a, p, v) {
      var S = Us(Ae, s, v, a);
      return S.elementType = G, S.lanes = p, S;
    }
    function sw(s, a, p, v) {
      var S = Us(je, s, v, a);
      S.elementType = Ie, S.lanes = p;
      var R = {};
      return S.stateNode = R, S;
    }
    function $_(s, a, p) {
      var v = Us(q, s, null, a);
      return v.lanes = p, v;
    }
    function q3() {
      var s = Us(O, null, null, Yt);
      return s.elementType = "DELETED", s;
    }
    function Z3(s) {
      var a = Us(pe, null, null, Yt);
      return a.stateNode = s, a;
    }
    function eS(s, a, p) {
      var v = s.children !== null ? s.children : [], S = Us(U, v, s.key, a);
      return S.lanes = p, S.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: s.implementation
      }, S;
    }
    function aw(s, a) {
      return s === null && (s = Us(V, null, null, Yt)), s.tag = a.tag, s.key = a.key, s.elementType = a.elementType, s.type = a.type, s.stateNode = a.stateNode, s.return = a.return, s.child = a.child, s.sibling = a.sibling, s.index = a.index, s.ref = a.ref, s.pendingProps = a.pendingProps, s.memoizedProps = a.memoizedProps, s.updateQueue = a.updateQueue, s.memoizedState = a.memoizedState, s.dependencies = a.dependencies, s.mode = a.mode, s.flags = a.flags, s.subtreeFlags = a.subtreeFlags, s.deletions = a.deletions, s.lanes = a.lanes, s.childLanes = a.childLanes, s.alternate = a.alternate, s.actualDuration = a.actualDuration, s.actualStartTime = a.actualStartTime, s.selfBaseDuration = a.selfBaseDuration, s.treeBaseDuration = a.treeBaseDuration, s._debugSource = a._debugSource, s._debugOwner = a._debugOwner, s._debugNeedsRemount = a._debugNeedsRemount, s._debugHookTypes = a._debugHookTypes, s;
    }
    function K3(s, a, p, v, S) {
      this.tag = a, this.containerInfo = s, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = fh, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = ri, this.eventTimes = Al(Ge), this.expirationTimes = Al(Fn), this.pendingLanes = Ge, this.suspendedLanes = Ge, this.pingedLanes = Ge, this.expiredLanes = Ge, this.mutableReadLanes = Ge, this.finishedLanes = Ge, this.entangledLanes = Ge, this.entanglements = Al(Ge), this.identifierPrefix = v, this.onRecoverableError = S, ar && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var R = this.pendingUpdatersLaneMap = [], L = 0; L < Co; L++)
          R.push(/* @__PURE__ */ new Set());
      }
      switch (a) {
        case Qa:
          this._debugRootType = p ? "hydrateRoot()" : "createRoot()";
          break;
        case pr:
          this._debugRootType = p ? "hydrate()" : "render()";
          break;
      }
    }
    function ow(s, a, p, v, S, R, L, F, H, Z) {
      var te = new K3(s, a, p, F, H), xe = W3(a, R);
      te.current = xe, xe.stateNode = te;
      {
        var we = {
          element: v,
          isDehydrated: p,
          cache: null,
          // not enabled yet
          transitions: null
        };
        xe.memoizedState = we;
      }
      return Se(xe), te;
    }
    var J3 = "18.0.0-fc46dba67-20220329";
    function Q3(s, a, p) {
      var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Io(v), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: pt,
        key: v == null ? null : "" + v,
        children: s,
        containerInfo: a,
        implementation: p
      };
    }
    var tS, nS;
    tS = !1, nS = {};
    function lw(s) {
      if (!s)
        return hr;
      var a = y(s), p = Ma(a);
      if (a.tag === I) {
        var v = a.type;
        if (Dr(v))
          return df(a, v, p);
      }
      return p;
    }
    function $3(s) {
      var a = y(s);
      if (a === void 0) {
        if (typeof s.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var p = Object.keys(s).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + p);
      }
      var v = kn(a);
      return v === null ? null : v.stateNode;
    }
    function eO(s, a) {
      {
        var p = y(s);
        if (p === void 0) {
          if (typeof s.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var v = Object.keys(s).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + v);
        }
        var S = kn(p);
        if (S === null)
          return null;
        if (S.mode & ii) {
          var R = Y(p) || "Component";
          if (!nS[R]) {
            nS[R] = !0;
            var L = yr;
            try {
              jn(S), p.mode & ii ? h("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, R) : h("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, R);
            } finally {
              L ? jn(L) : Ki();
            }
          }
        }
        return S.stateNode;
      }
    }
    function tO(s, a, p, v, S, R, L, F) {
      var H = !1, Z = null;
      return ow(s, a, H, Z, p, v, S, R, L);
    }
    function nO(s, a, p, v, S, R, L, F, H, Z) {
      var te = !0, xe = ow(p, v, te, s, S, R, L, F, H);
      xe.context = lw(null);
      var we = xe.current, De = $r(), We = ql(we), Je = be(De, We);
      return Je.callback = a ?? null, ut(we, Je), n3(xe, We, De), xe;
    }
    function uw(s, a, p, v) {
      kh(a, s);
      var S = a.current, R = $r(), L = ql(S);
      Yh(L);
      var F = lw(p);
      a.context === null ? a.context = F : a.pendingContext = F, Wu && yr !== null && !tS && (tS = !0, h(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Y(yr) || "Unknown"));
      var H = be(R, L);
      H.payload = {
        element: s
      }, v = v === void 0 ? null : v, v !== null && (typeof v != "function" && h("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", v), H.callback = v), ut(S, H);
      var Z = tr(S, L, R);
      return Z !== null && Pt(Z, S, L), L;
    }
    function iO(s) {
      var a = s.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case O:
          return Ar(a.child.stateNode);
        default:
          return a.child.stateNode;
      }
    }
    function rO(s) {
      switch (s.tag) {
        case W:
          var a = s.stateNode;
          if (Aa(a)) {
            var p = lv(a);
            s3(a, p);
          }
          break;
        case Q:
          var v = $r();
          Rg(function() {
            return tr(s, ln, v);
          });
          var S = ln;
          iS(s, S);
          break;
      }
    }
    function cw(s, a) {
      var p = s.memoizedState;
      p !== null && p.dehydrated !== null && (p.retryLane = tx(p.retryLane, a));
    }
    function iS(s, a) {
      cw(s, a);
      var p = s.alternate;
      p && cw(p, a);
    }
    function sO(s) {
      if (s.tag === Q) {
        var a = $r(), p = Nr;
        tr(s, p, a), iS(s, p);
      }
    }
    function aO(s) {
      if (s.tag === Q) {
        var a = $r(), p = ql(s);
        tr(s, p, a), iS(s, p);
      }
    }
    function oO(s) {
      var a = Gn(s);
      return a === null ? null : a.stateNode;
    }
    var fw = function(s) {
      return null;
    };
    function dw(s) {
      return fw(s);
    }
    var hw = function(s) {
      return !1;
    };
    function pw(s) {
      return hw(s);
    }
    var mw = null, vw = null, gw = null, yw = null, xw = null, _w = null, Sw = null, Mw = null, Ew = null;
    {
      var bw = function(s, a, p) {
        var v = a[p], S = ht(s) ? s.slice() : g({}, s);
        return p + 1 === a.length ? (ht(S) ? S.splice(v, 1) : delete S[v], S) : (S[v] = bw(s[v], a, p + 1), S);
      }, Tw = function(s, a) {
        return bw(s, a, 0);
      }, ww = function(s, a, p, v) {
        var S = a[v], R = ht(s) ? s.slice() : g({}, s);
        if (v + 1 === a.length) {
          var L = p[v];
          R[L] = R[S], ht(R) ? R.splice(S, 1) : delete R[S];
        } else
          R[S] = ww(
            // $FlowFixMe number or string is fine here
            s[S],
            a,
            p,
            v + 1
          );
        return R;
      }, Aw = function(s, a, p) {
        if (a.length !== p.length) {
          d("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var v = 0; v < p.length - 1; v++)
            if (a[v] !== p[v]) {
              d("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return ww(s, a, p, 0);
      }, Rw = function(s, a, p, v) {
        if (p >= a.length)
          return v;
        var S = a[p], R = ht(s) ? s.slice() : g({}, s);
        return R[S] = Rw(s[S], a, p + 1, v), R;
      }, Cw = function(s, a, p) {
        return Rw(s, a, 0, p);
      }, rS = function(s, a) {
        for (var p = s.memoizedState; p !== null && a > 0; )
          p = p.next, a--;
        return p;
      };
      mw = function(s, a, p, v) {
        var S = rS(s, a);
        if (S !== null) {
          var R = Cw(S.memoizedState, p, v);
          S.memoizedState = R, S.baseState = R, s.memoizedProps = g({}, s.memoizedProps), tr(s, ln, Fn);
        }
      }, vw = function(s, a, p) {
        var v = rS(s, a);
        if (v !== null) {
          var S = Tw(v.memoizedState, p);
          v.memoizedState = S, v.baseState = S, s.memoizedProps = g({}, s.memoizedProps), tr(s, ln, Fn);
        }
      }, gw = function(s, a, p, v) {
        var S = rS(s, a);
        if (S !== null) {
          var R = Aw(S.memoizedState, p, v);
          S.memoizedState = R, S.baseState = R, s.memoizedProps = g({}, s.memoizedProps), tr(s, ln, Fn);
        }
      }, yw = function(s, a, p) {
        s.pendingProps = Cw(s.memoizedProps, a, p), s.alternate && (s.alternate.pendingProps = s.pendingProps), tr(s, ln, Fn);
      }, xw = function(s, a) {
        s.pendingProps = Tw(s.memoizedProps, a), s.alternate && (s.alternate.pendingProps = s.pendingProps), tr(s, ln, Fn);
      }, _w = function(s, a, p) {
        s.pendingProps = Aw(s.memoizedProps, a, p), s.alternate && (s.alternate.pendingProps = s.pendingProps), tr(s, ln, Fn);
      }, Sw = function(s) {
        tr(s, ln, Fn);
      }, Mw = function(s) {
        fw = s;
      }, Ew = function(s) {
        hw = s;
      };
    }
    function lO(s) {
      var a = kn(s);
      return a === null ? null : a.stateNode;
    }
    function uO(s) {
      return null;
    }
    function cO() {
      return yr;
    }
    function fO(s) {
      var a = s.findFiberByHostInstance, p = o.ReactCurrentDispatcher;
      return vv({
        bundleType: s.bundleType,
        version: s.version,
        rendererPackageName: s.rendererPackageName,
        rendererConfig: s.rendererConfig,
        overrideHookState: mw,
        overrideHookStateDeletePath: vw,
        overrideHookStateRenamePath: gw,
        overrideProps: yw,
        overridePropsDeletePath: xw,
        overridePropsRenamePath: _w,
        setErrorHandler: Mw,
        setSuspenseHandler: Ew,
        scheduleUpdate: Sw,
        currentDispatcherRef: p,
        findHostInstanceByFiber: lO,
        findFiberByHostInstance: a || uO,
        // React Refresh
        findHostInstancesForRefresh: F3,
        scheduleRefresh: O3,
        scheduleRoot: I3,
        setRefreshHandler: U3,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: cO,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: J3
      });
    }
    return t.attemptContinuousHydration = sO, t.attemptHydrationAtCurrentPriority = aO, t.attemptSynchronousHydration = rO, t.batchedUpdates = o3, t.createComponentSelector = zU, t.createContainer = tO, t.createHasPseudoClassSelector = BU, t.createHydrationContainer = nO, t.createPortal = Q3, t.createRoleSelector = VU, t.createTestNameSelector = kU, t.createTextSelector = HU, t.deferredUpdates = a3, t.discreteUpdates = l3, t.findAllNodes = yg, t.findBoundingRects = XU, t.findHostInstance = $3, t.findHostInstanceWithNoPortals = oO, t.findHostInstanceWithWarning = eO, t.flushControlled = c3, t.flushPassiveEffects = fo, t.flushSync = Rg, t.focusWithin = jU, t.getCurrentUpdatePriority = ms, t.getFindAllNodesFailureDescription = WU, t.getPublicRootInstance = iO, t.injectIntoDevTools = fO, t.isAlreadyRendering = u3, t.observeVisibleRects = qU, t.registerMutableSourceForHydration = rN, t.runWithPriority = pv, t.shouldError = dw, t.shouldSuspend = pw, t.updateContainer = uw, t;
  })), jS.exports;
}
process.env.NODE_ENV === "production" ? oE.exports = b4() : oE.exports = T4();
var w4 = oE.exports;
const A4 = /* @__PURE__ */ MO(w4), vb = {}, R4 = (i) => void Object.assign(vb, i);
function C4(i, e) {
  function t(m, {
    args: g = [],
    attach: y,
    ..._
  }, E) {
    let w = `${m[0].toUpperCase()}${m.slice(1)}`, T;
    if (m === "primitive") {
      if (_.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const M = _.object;
      T = Bd(M, {
        type: m,
        root: E,
        attach: y,
        primitive: !0
      });
    } else {
      const M = vb[w];
      if (!M)
        throw new Error(`R3F: ${w} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(g)) throw new Error("R3F: The args prop must be an array!");
      T = Bd(new M(...g), {
        type: m,
        root: E,
        attach: y,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: g
        }
      });
    }
    return T.__r3f.attach === void 0 && (T.isBufferGeometry ? T.__r3f.attach = "geometry" : T.isMaterial && (T.__r3f.attach = "material")), w !== "inject" && ZS(T, _), T;
  }
  function n(m, g) {
    let y = !1;
    if (g) {
      var _, E;
      (_ = g.__r3f) != null && _.attach ? qS(m, g, g.__r3f.attach) : g.isObject3D && m.isObject3D && (m.add(g), y = !0), y || (E = m.__r3f) == null || E.objects.push(g), g.__r3f || Bd(g, {}), g.__r3f.parent = m, cE(g), Vd(g);
    }
  }
  function r(m, g, y) {
    let _ = !1;
    if (g) {
      var E, w;
      if ((E = g.__r3f) != null && E.attach)
        qS(m, g, g.__r3f.attach);
      else if (g.isObject3D && m.isObject3D) {
        g.parent = m, g.dispatchEvent({
          type: "added"
        }), m.dispatchEvent({
          type: "childadded",
          child: g
        });
        const T = m.children.filter((C) => C !== g), M = T.indexOf(y);
        m.children = [...T.slice(0, M), g, ...T.slice(M)], _ = !0;
      }
      _ || (w = m.__r3f) == null || w.objects.push(g), g.__r3f || Bd(g, {}), g.__r3f.parent = m, cE(g), Vd(g);
    }
  }
  function o(m, g, y = !1) {
    m && [...m].forEach((_) => l(g, _, y));
  }
  function l(m, g, y) {
    if (g) {
      var _, E, w;
      if (g.__r3f && (g.__r3f.parent = null), (_ = m.__r3f) != null && _.objects && (m.__r3f.objects = m.__r3f.objects.filter((N) => N !== g)), (E = g.__r3f) != null && E.attach)
        xR(m, g, g.__r3f.attach);
      else if (g.isObject3D && m.isObject3D) {
        var T;
        m.remove(g), (T = g.__r3f) != null && T.root && F4(Gy(g), g);
      }
      const C = (w = g.__r3f) == null ? void 0 : w.primitive, A = !C && (y === void 0 ? g.dispose !== null : y);
      if (!C) {
        var M;
        o((M = g.__r3f) == null ? void 0 : M.objects, g, A), o(g.children, g, A);
      }
      if (delete g.__r3f, A && g.dispose && g.type !== "Scene") {
        const N = () => {
          try {
            g.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? Qy.unstable_scheduleCallback(Qy.unstable_IdlePriority, N) : N();
      }
      Vd(m);
    }
  }
  function u(m, g, y, _) {
    var E;
    const w = (E = m.__r3f) == null ? void 0 : E.parent;
    if (!w) return;
    const T = t(g, y, m.__r3f.root);
    if (m.children) {
      for (const M of m.children)
        M.__r3f && n(T, M);
      m.children = m.children.filter((M) => !M.__r3f);
    }
    m.__r3f.objects.forEach((M) => n(T, M)), m.__r3f.objects = [], m.__r3f.autoRemovedBeforeAppend || l(w, m), T.parent && (T.__r3f.autoRemovedBeforeAppend = !0), n(w, T), T.raycast && T.__r3f.eventCount && Gy(T).getState().internal.interaction.push(T), [_, _.alternate].forEach((M) => {
      M !== null && (M.stateNode = T, M.ref && (typeof M.ref == "function" ? M.ref(T) : M.ref.current = T));
    });
  }
  const d = () => {
  };
  return {
    reconciler: A4({
      createInstance: t,
      removeChild: l,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (m, g) => {
        if (!g) return;
        const y = m.getState().scene;
        y.__r3f && (y.__r3f.root = m, n(y, g));
      },
      removeChildFromContainer: (m, g) => {
        g && l(m.getState().scene, g);
      },
      insertInContainerBefore: (m, g, y) => {
        if (!g || !y) return;
        const _ = m.getState().scene;
        _.__r3f && r(_, g, y);
      },
      getRootHostContext: () => null,
      getChildHostContext: (m) => m,
      finalizeInitialChildren(m) {
        var g;
        return !!((g = m == null ? void 0 : m.__r3f) != null ? g : {}).handlers;
      },
      prepareUpdate(m, g, y, _) {
        var E;
        if (((E = m == null ? void 0 : m.__r3f) != null ? E : {}).primitive && _.object && _.object !== m)
          return [!0];
        {
          const {
            args: T = [],
            children: M,
            ...C
          } = _, {
            args: A = [],
            children: N,
            ...z
          } = y;
          if (!Array.isArray(T)) throw new Error("R3F: the args prop must be an array!");
          if (T.some((V, W) => V !== A[W])) return [!0];
          const I = tD(m, C, z, !0);
          return I.changes.length ? [!1, I] : null;
        }
      },
      commitUpdate(m, [g, y], _, E, w, T) {
        g ? u(m, _, w, T) : ZS(m, y);
      },
      commitMount(m, g, y, _) {
        var E;
        const w = (E = m.__r3f) != null ? E : {};
        m.raycast && w.handlers && w.eventCount && Gy(m).getState().internal.interaction.push(m);
      },
      getPublicInstance: (m) => m,
      prepareForCommit: () => null,
      preparePortalMount: (m) => Bd(m.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(m) {
        var g;
        const {
          attach: y,
          parent: _
        } = (g = m.__r3f) != null ? g : {};
        y && _ && xR(_, m, y), m.isObject3D && (m.visible = !1), Vd(m);
      },
      unhideInstance(m, g) {
        var y;
        const {
          attach: _,
          parent: E
        } = (y = m.__r3f) != null ? y : {};
        _ && E && qS(E, m, _), (m.isObject3D && g.visible == null || g.visible) && (m.visible = !0), Vd(m);
      },
      createTextInstance: d,
      hideTextInstance: d,
      unhideTextInstance: d,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : jd.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && ei.fun(performance.now) ? performance.now : ei.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: ei.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: ei.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: ZS
  };
}
var mR, vR;
const YS = (i) => "colorSpace" in i || "outputColorSpace" in i, ZL = () => {
  var i;
  return (i = vb.ColorManagement) != null ? i : null;
}, KL = (i) => i && i.isOrthographicCamera, P4 = (i) => i && i.hasOwnProperty("current"), Hm = typeof window < "u" && ((mR = window.document) != null && mR.createElement || ((vR = window.navigator) == null ? void 0 : vR.product) === "ReactNative") ? Lt.useLayoutEffect : Lt.useEffect;
function JL(i) {
  const e = Lt.useRef(i);
  return Hm(() => void (e.current = i), [i]), e;
}
function L4({
  set: i
}) {
  return Hm(() => (i(new Promise(() => null)), () => i(!1)), [i]), null;
}
class QL extends Lt.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
QL.getDerivedStateFromError = () => ({
  error: !0
});
const $L = "__default", gR = /* @__PURE__ */ new Map(), D4 = (i) => i && !!i.memoized && !!i.changes;
function eD(i) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(i) ? Math.min(Math.max(i[0], t), i[1]) : i;
}
const Hp = (i) => {
  var e;
  return (e = i.__r3f) == null ? void 0 : e.root.getState();
};
function Gy(i) {
  let e = i.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const ei = {
  obj: (i) => i === Object(i) && !ei.arr(i) && typeof i != "function",
  fun: (i) => typeof i == "function",
  str: (i) => typeof i == "string",
  num: (i) => typeof i == "number",
  boo: (i) => typeof i == "boolean",
  und: (i) => i === void 0,
  arr: (i) => Array.isArray(i),
  equ(i, e, {
    arrays: t = "shallow",
    objects: n = "reference",
    strict: r = !0
  } = {}) {
    if (typeof i != typeof e || !!i != !!e) return !1;
    if (ei.str(i) || ei.num(i) || ei.boo(i)) return i === e;
    const o = ei.obj(i);
    if (o && n === "reference") return i === e;
    const l = ei.arr(i);
    if (l && t === "reference") return i === e;
    if ((l || o) && i === e) return !0;
    let u;
    for (u in i) if (!(u in e)) return !1;
    if (o && t === "shallow" && n === "shallow") {
      for (u in r ? e : i) if (!ei.equ(i[u], e[u], {
        strict: r,
        objects: "reference"
      })) return !1;
    } else
      for (u in r ? e : i) if (i[u] !== e[u]) return !1;
    if (ei.und(u)) {
      if (l && i.length === 0 && e.length === 0 || o && Object.keys(i).length === 0 && Object.keys(e).length === 0) return !0;
      if (i !== e) return !1;
    }
    return !0;
  }
};
function N4(i) {
  i.dispose && i.type !== "Scene" && i.dispose();
  for (const e in i)
    e.dispose == null || e.dispose(), delete i[e];
}
function Bd(i, e) {
  const t = i;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, i;
}
function uE(i, e) {
  let t = i;
  if (e.includes("-")) {
    const n = e.split("-"), r = n.pop();
    return t = n.reduce((o, l) => o[l], i), {
      target: t,
      key: r
    };
  } else return {
    target: t,
    key: e
  };
}
const yR = /-\d+$/;
function qS(i, e, t) {
  if (ei.str(t)) {
    if (yR.test(t)) {
      const o = t.replace(yR, ""), {
        target: l,
        key: u
      } = uE(i, o);
      Array.isArray(l[u]) || (l[u] = []);
    }
    const {
      target: n,
      key: r
    } = uE(i, t);
    e.__r3f.previousAttach = n[r], n[r] = e;
  } else e.__r3f.previousAttach = t(i, e);
}
function xR(i, e, t) {
  var n, r;
  if (ei.str(t)) {
    const {
      target: o,
      key: l
    } = uE(i, t), u = e.__r3f.previousAttach;
    u === void 0 ? delete o[l] : o[l] = u;
  } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(i, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function tD(i, {
  children: e,
  key: t,
  ref: n,
  ...r
}, {
  children: o,
  key: l,
  ref: u,
  ...d
} = {}, h = !1) {
  const m = i.__r3f, g = Object.entries(r), y = [];
  if (h) {
    const E = Object.keys(d);
    for (let w = 0; w < E.length; w++)
      r.hasOwnProperty(E[w]) || g.unshift([E[w], $L + "remove"]);
  }
  g.forEach(([E, w]) => {
    var T;
    if ((T = i.__r3f) != null && T.primitive && E === "object" || ei.equ(w, d[E])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(E)) return y.push([E, w, !0, []]);
    let M = [];
    E.includes("-") && (M = E.split("-")), y.push([E, w, !1, M]);
    for (const C in r) {
      const A = r[C];
      C.startsWith(`${E}-`) && y.push([C, A, !1, C.split("-")]);
    }
  });
  const _ = {
    ...r
  };
  return m != null && m.memoizedProps && m != null && m.memoizedProps.args && (_.args = m.memoizedProps.args), m != null && m.memoizedProps && m != null && m.memoizedProps.attach && (_.attach = m.memoizedProps.attach), {
    memoized: _,
    changes: y
  };
}
const U4 = typeof process < "u" && process.env.NODE_ENV !== "production";
function ZS(i, e) {
  var t;
  const n = i.__r3f, r = n == null ? void 0 : n.root, o = r == null || r.getState == null ? void 0 : r.getState(), {
    memoized: l,
    changes: u
  } = D4(e) ? e : tD(i, e), d = n == null ? void 0 : n.eventCount;
  i.__r3f && (i.__r3f.memoizedProps = l);
  for (let y = 0; y < u.length; y++) {
    let [_, E, w, T] = u[y];
    if (YS(i)) {
      const N = "srgb", z = "srgb-linear";
      _ === "encoding" ? (_ = "colorSpace", E = E === 3001 ? N : z) : _ === "outputEncoding" && (_ = "outputColorSpace", E = E === 3001 ? N : z);
    }
    let M = i, C = M[_];
    if (T.length && (C = T.reduce((A, N) => A[N], i), !(C && C.set))) {
      const [A, ...N] = T.reverse();
      M = N.reverse().reduce((z, I) => z[I], i), _ = A;
    }
    if (E === $L + "remove")
      if (M.constructor) {
        let A = gR.get(M.constructor);
        A || (A = new M.constructor(), gR.set(M.constructor, A)), E = A[_];
      } else
        E = 0;
    if (w && n)
      E ? n.handlers[_] = E : delete n.handlers[_], n.eventCount = Object.keys(n.handlers).length;
    else if (C && C.set && (C.copy || C instanceof Oc)) {
      if (Array.isArray(E))
        C.fromArray ? C.fromArray(E) : C.set(...E);
      else if (C.copy && E && E.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (U4 ? C.constructor.name === E.constructor.name : C.constructor === E.constructor))
        C.copy(E);
      else if (E !== void 0) {
        var h;
        const A = (h = C) == null ? void 0 : h.isColor;
        !A && C.setScalar ? C.setScalar(E) : C instanceof Oc && E instanceof Oc ? C.mask = E.mask : C.set(E), !ZL() && o && !o.linear && A && C.convertSRGBToLinear();
      }
    } else {
      var m;
      if (M[_] = E, (m = M[_]) != null && m.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      M[_].format === is && M[_].type === vo && o) {
        const A = M[_];
        YS(A) && YS(o.gl) ? A.colorSpace = o.gl.outputColorSpace : A.encoding = o.gl.outputEncoding;
      }
    }
    Vd(i);
  }
  if (n && n.parent && i.raycast && d !== n.eventCount) {
    const y = Gy(i).getState().internal, _ = y.interaction.indexOf(i);
    _ > -1 && y.interaction.splice(_, 1), n.eventCount && y.interaction.push(i);
  }
  return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (t = i.__r3f) != null && t.parent && cE(i), i;
}
function Vd(i) {
  var e, t;
  const n = (e = i.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function cE(i) {
  i.onUpdate == null || i.onUpdate(i);
}
function O4(i, e) {
  i.manual || (KL(i) ? (i.left = e.width / -2, i.right = e.width / 2, i.top = e.height / 2, i.bottom = e.height / -2) : i.aspect = e.width / e.height, i.updateProjectionMatrix(), i.updateMatrixWorld());
}
function Ry(i) {
  return (i.eventObject || i.object).uuid + "/" + i.index + i.instanceId;
}
function I4() {
  var i;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return jd.DefaultEventPriority;
  switch ((i = e.event) == null ? void 0 : i.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return jd.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return jd.ContinuousEventPriority;
    default:
      return jd.DefaultEventPriority;
  }
}
function nD(i, e, t, n) {
  const r = t.get(e);
  r && (t.delete(e), t.size === 0 && (i.delete(n), r.target.releasePointerCapture(n)));
}
function F4(i, e) {
  const {
    internal: t
  } = i.getState();
  t.interaction = t.interaction.filter((n) => n !== e), t.initialHits = t.initialHits.filter((n) => n !== e), t.hovered.forEach((n, r) => {
    (n.eventObject === e || n.object === e) && t.hovered.delete(r);
  }), t.capturedMap.forEach((n, r) => {
    nD(t.capturedMap, e, n, r);
  });
}
function z4(i) {
  function e(d) {
    const {
      internal: h
    } = i.getState(), m = d.offsetX - h.initialClick[0], g = d.offsetY - h.initialClick[1];
    return Math.round(Math.sqrt(m * m + g * g));
  }
  function t(d) {
    return d.filter((h) => ["Move", "Over", "Enter", "Out", "Leave"].some((m) => {
      var g;
      return (g = h.__r3f) == null ? void 0 : g.handlers["onPointer" + m];
    }));
  }
  function n(d, h) {
    const m = i.getState(), g = /* @__PURE__ */ new Set(), y = [], _ = h ? h(m.internal.interaction) : m.internal.interaction;
    for (let M = 0; M < _.length; M++) {
      const C = Hp(_[M]);
      C && (C.raycaster.camera = void 0);
    }
    m.previousRoot || m.events.compute == null || m.events.compute(d, m);
    function E(M) {
      const C = Hp(M);
      if (!C || !C.events.enabled || C.raycaster.camera === null) return [];
      if (C.raycaster.camera === void 0) {
        var A;
        C.events.compute == null || C.events.compute(d, C, (A = C.previousRoot) == null ? void 0 : A.getState()), C.raycaster.camera === void 0 && (C.raycaster.camera = null);
      }
      return C.raycaster.camera ? C.raycaster.intersectObject(M, !0) : [];
    }
    let w = _.flatMap(E).sort((M, C) => {
      const A = Hp(M.object), N = Hp(C.object);
      return !A || !N ? M.distance - C.distance : N.events.priority - A.events.priority || M.distance - C.distance;
    }).filter((M) => {
      const C = Ry(M);
      return g.has(C) ? !1 : (g.add(C), !0);
    });
    m.events.filter && (w = m.events.filter(w, m));
    for (const M of w) {
      let C = M.object;
      for (; C; ) {
        var T;
        (T = C.__r3f) != null && T.eventCount && y.push({
          ...M,
          eventObject: C
        }), C = C.parent;
      }
    }
    if ("pointerId" in d && m.internal.capturedMap.has(d.pointerId))
      for (let M of m.internal.capturedMap.get(d.pointerId).values())
        g.has(Ry(M.intersection)) || y.push(M.intersection);
    return y;
  }
  function r(d, h, m, g) {
    const y = i.getState();
    if (d.length) {
      const _ = {
        stopped: !1
      };
      for (const E of d) {
        const w = Hp(E.object) || y, {
          raycaster: T,
          pointer: M,
          camera: C,
          internal: A
        } = w, N = new j(M.x, M.y, 0).unproject(C), z = (O) => {
          var q, le;
          return (q = (le = A.capturedMap.get(O)) == null ? void 0 : le.has(E.eventObject)) != null ? q : !1;
        }, I = (O) => {
          const q = {
            intersection: E,
            target: h.target
          };
          A.capturedMap.has(O) ? A.capturedMap.get(O).set(E.eventObject, q) : A.capturedMap.set(O, /* @__PURE__ */ new Map([[E.eventObject, q]])), h.target.setPointerCapture(O);
        }, V = (O) => {
          const q = A.capturedMap.get(O);
          q && nD(A.capturedMap, E.eventObject, q, O);
        };
        let W = {};
        for (let O in h) {
          let q = h[O];
          typeof q != "function" && (W[O] = q);
        }
        let U = {
          ...E,
          ...W,
          pointer: M,
          intersections: d,
          stopped: _.stopped,
          delta: m,
          unprojectedPoint: N,
          ray: T.ray,
          camera: C,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const O = "pointerId" in h && A.capturedMap.get(h.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!O || // ... or if the hit object is capturing the pointer
              O.has(E.eventObject)) && (U.stopped = _.stopped = !0, A.hovered.size && Array.from(A.hovered.values()).find((q) => q.eventObject === E.eventObject))
            ) {
              const q = d.slice(0, d.indexOf(E));
              o([...q, E]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: z,
            setPointerCapture: I,
            releasePointerCapture: V
          },
          currentTarget: {
            hasPointerCapture: z,
            setPointerCapture: I,
            releasePointerCapture: V
          },
          nativeEvent: h
        };
        if (g(U), _.stopped === !0) break;
      }
    }
    return d;
  }
  function o(d) {
    const {
      internal: h
    } = i.getState();
    for (const m of h.hovered.values())
      if (!d.length || !d.find((g) => g.object === m.object && g.index === m.index && g.instanceId === m.instanceId)) {
        const y = m.eventObject.__r3f, _ = y == null ? void 0 : y.handlers;
        if (h.hovered.delete(Ry(m)), y != null && y.eventCount) {
          const E = {
            ...m,
            intersections: d
          };
          _.onPointerOut == null || _.onPointerOut(E), _.onPointerLeave == null || _.onPointerLeave(E);
        }
      }
  }
  function l(d, h) {
    for (let m = 0; m < h.length; m++) {
      const g = h[m].__r3f;
      g == null || g.handlers.onPointerMissed == null || g.handlers.onPointerMissed(d);
    }
  }
  function u(d) {
    switch (d) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (h) => {
          const {
            internal: m
          } = i.getState();
          "pointerId" in h && m.capturedMap.has(h.pointerId) && requestAnimationFrame(() => {
            m.capturedMap.has(h.pointerId) && (m.capturedMap.delete(h.pointerId), o([]));
          });
        };
    }
    return function(m) {
      const {
        onPointerMissed: g,
        internal: y
      } = i.getState();
      y.lastEvent.current = m;
      const _ = d === "onPointerMove", E = d === "onClick" || d === "onContextMenu" || d === "onDoubleClick", T = n(m, _ ? t : void 0), M = E ? e(m) : 0;
      d === "onPointerDown" && (y.initialClick = [m.offsetX, m.offsetY], y.initialHits = T.map((A) => A.eventObject)), E && !T.length && M <= 2 && (l(m, y.interaction), g && g(m)), _ && o(T);
      function C(A) {
        const N = A.eventObject, z = N.__r3f, I = z == null ? void 0 : z.handlers;
        if (z != null && z.eventCount)
          if (_) {
            if (I.onPointerOver || I.onPointerEnter || I.onPointerOut || I.onPointerLeave) {
              const V = Ry(A), W = y.hovered.get(V);
              W ? W.stopped && A.stopPropagation() : (y.hovered.set(V, A), I.onPointerOver == null || I.onPointerOver(A), I.onPointerEnter == null || I.onPointerEnter(A));
            }
            I.onPointerMove == null || I.onPointerMove(A);
          } else {
            const V = I[d];
            V ? (!E || y.initialHits.includes(N)) && (l(m, y.interaction.filter((W) => !y.initialHits.includes(W))), V(A)) : E && y.initialHits.includes(N) && l(m, y.interaction.filter((W) => !y.initialHits.includes(W)));
          }
      }
      r(T, m, M, C);
    };
  }
  return {
    handlePointer: u
  };
}
const iD = (i) => !!(i != null && i.render), rD = /* @__PURE__ */ Lt.createContext(null), B4 = (i, e) => {
  const t = S4((u, d) => {
    const h = new j(), m = new j(), g = new j();
    function y(M = d().camera, C = m, A = d().size) {
      const {
        width: N,
        height: z,
        top: I,
        left: V
      } = A, W = N / z;
      C.isVector3 ? g.copy(C) : g.set(...C);
      const U = M.getWorldPosition(h).distanceTo(g);
      if (KL(M))
        return {
          width: N / M.zoom,
          height: z / M.zoom,
          top: I,
          left: V,
          factor: 1,
          distance: U,
          aspect: W
        };
      {
        const O = M.fov * Math.PI / 180, q = 2 * Math.tan(O / 2) * U, le = q * (N / z);
        return {
          width: le,
          height: q,
          top: I,
          left: V,
          factor: N / le,
          distance: U,
          aspect: W
        };
      }
    }
    let _;
    const E = (M) => u((C) => ({
      performance: {
        ...C.performance,
        current: M
      }
    })), w = new Oe();
    return {
      set: u,
      get: d,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (M = 1) => i(d(), M),
      advance: (M, C) => e(M, C, d()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new db(),
      pointer: w,
      mouse: w,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const M = d();
          _ && clearTimeout(_), M.performance.current !== M.performance.min && E(M.performance.min), _ = setTimeout(() => E(d().performance.max), M.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: y
      },
      setEvents: (M) => u((C) => ({
        ...C,
        events: {
          ...C.events,
          ...M
        }
      })),
      setSize: (M, C, A, N, z) => {
        const I = d().camera, V = {
          width: M,
          height: C,
          top: N || 0,
          left: z || 0,
          updateStyle: A
        };
        u((W) => ({
          size: V,
          viewport: {
            ...W.viewport,
            ...y(I, m, V)
          }
        }));
      },
      setDpr: (M) => u((C) => {
        const A = eD(M);
        return {
          viewport: {
            ...C.viewport,
            dpr: A,
            initialDpr: C.viewport.initialDpr || A
          }
        };
      }),
      setFrameloop: (M = "always") => {
        const C = d().clock;
        C.stop(), C.elapsedTime = 0, M !== "never" && (C.start(), C.elapsedTime = 0), u(() => ({
          frameloop: M
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ Lt.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (M, C, A) => {
          const N = d().internal;
          return N.priority = N.priority + (C > 0 ? 1 : 0), N.subscribers.push({
            ref: M,
            priority: C,
            store: A
          }), N.subscribers = N.subscribers.sort((z, I) => z.priority - I.priority), () => {
            const z = d().internal;
            z != null && z.subscribers && (z.priority = z.priority - (C > 0 ? 1 : 0), z.subscribers = z.subscribers.filter((I) => I.ref !== M));
          };
        }
      }
    };
  }), n = t.getState();
  let r = n.size, o = n.viewport.dpr, l = n.camera;
  return t.subscribe(() => {
    const {
      camera: u,
      size: d,
      viewport: h,
      gl: m,
      set: g
    } = t.getState();
    if (d.width !== r.width || d.height !== r.height || h.dpr !== o) {
      var y;
      r = d, o = h.dpr, O4(u, d), m.setPixelRatio(h.dpr);
      const _ = (y = d.updateStyle) != null ? y : typeof HTMLCanvasElement < "u" && m.domElement instanceof HTMLCanvasElement;
      m.setSize(d.width, d.height, _);
    }
    u !== l && (l = u, g((_) => ({
      viewport: {
        ..._.viewport,
        ..._.viewport.getCurrentViewport(u)
      }
    })));
  }), t.subscribe((u) => i(u)), t;
};
let Cy, V4 = /* @__PURE__ */ new Set(), H4 = /* @__PURE__ */ new Set(), k4 = /* @__PURE__ */ new Set();
function KS(i, e) {
  if (i.size)
    for (const {
      callback: t
    } of i.values())
      t(e);
}
function kp(i, e) {
  switch (i) {
    case "before":
      return KS(V4, e);
    case "after":
      return KS(H4, e);
    case "tail":
      return KS(k4, e);
  }
}
let JS, QS;
function $S(i, e, t) {
  let n = e.clock.getDelta();
  for (e.frameloop === "never" && typeof i == "number" && (n = i - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = i), JS = e.internal.subscribers, Cy = 0; Cy < JS.length; Cy++)
    QS = JS[Cy], QS.ref.current(QS.store.getState(), n, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function G4(i) {
  let e = !1, t = !1, n, r, o;
  function l(h) {
    r = requestAnimationFrame(l), e = !0, n = 0, kp("before", h), t = !0;
    for (const g of i.values()) {
      var m;
      o = g.store.getState(), o.internal.active && (o.frameloop === "always" || o.internal.frames > 0) && !((m = o.gl.xr) != null && m.isPresenting) && (n += $S(h, o));
    }
    if (t = !1, kp("after", h), n === 0)
      return kp("tail", h), e = !1, cancelAnimationFrame(r);
  }
  function u(h, m = 1) {
    var g;
    if (!h) return i.forEach((y) => u(y.store.getState(), m));
    (g = h.gl.xr) != null && g.isPresenting || !h.internal.active || h.frameloop === "never" || (m > 1 ? h.internal.frames = Math.min(60, h.internal.frames + m) : t ? h.internal.frames = 2 : h.internal.frames = 1, e || (e = !0, requestAnimationFrame(l)));
  }
  function d(h, m = !0, g, y) {
    if (m && kp("before", h), g) $S(h, g, y);
    else for (const _ of i.values()) $S(h, _.store.getState());
    m && kp("after", h);
  }
  return {
    loop: l,
    invalidate: u,
    advance: d
  };
}
function sD() {
  const i = Lt.useContext(rD);
  if (!i) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return i;
}
function au(i = (t) => t, e) {
  return sD()(i, e);
}
function aD(i, e = 0) {
  const t = sD(), n = t.getState().internal.subscribe, r = JL(i);
  return Hm(() => n(r, e, t), [e, n, t]), null;
}
const ih = /* @__PURE__ */ new Map(), {
  invalidate: _R,
  advance: SR
} = G4(ih), {
  reconciler: $y,
  applyProps: Fd
} = C4(ih, I4), zd = {
  objects: "shallow",
  strict: !1
}, W4 = (i, e) => {
  const t = typeof i == "function" ? i(e) : i;
  return iD(t) ? t : new YE({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...i
  });
};
function X4(i, e) {
  const t = typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: n,
      height: r,
      top: o,
      left: l,
      updateStyle: u = t
    } = e;
    return {
      width: n,
      height: r,
      top: o,
      left: l,
      updateStyle: u
    };
  } else if (typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement && i.parentElement) {
    const {
      width: n,
      height: r,
      top: o,
      left: l
    } = i.parentElement.getBoundingClientRect();
    return {
      width: n,
      height: r,
      top: o,
      left: l,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas)
    return {
      width: i.width,
      height: i.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function j4(i) {
  const e = ih.get(i), t = e == null ? void 0 : e.fiber, n = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), o = n || B4(_R, SR), l = t || $y.createContainer(o, jd.ConcurrentRoot, null, !1, null, "", r, null);
  e || ih.set(i, {
    fiber: l,
    store: o
  });
  let u, d = !1, h;
  return {
    configure(m = {}) {
      let {
        gl: g,
        size: y,
        scene: _,
        events: E,
        onCreated: w,
        shadows: T = !1,
        linear: M = !1,
        flat: C = !1,
        legacy: A = !1,
        orthographic: N = !1,
        frameloop: z = "always",
        dpr: I = [1, 2],
        performance: V,
        raycaster: W,
        camera: U,
        onPointerMissed: O
      } = m, q = o.getState(), le = q.gl;
      q.gl || q.set({
        gl: le = W4(g, i)
      });
      let ye = q.raycaster;
      ye || q.set({
        raycaster: ye = new YL()
      });
      const {
        params: K,
        ...oe
      } = W || {};
      if (ei.equ(oe, ye, zd) || Fd(ye, {
        ...oe
      }), ei.equ(K, ye.params, zd) || Fd(ye, {
        params: {
          ...ye.params,
          ...K
        }
      }), !q.camera || q.camera === h && !ei.equ(h, U, zd)) {
        h = U;
        const re = U instanceof Nm, ue = re ? U : N ? new hu(0, 0, 0, 0, 0.1, 1e3) : new Ii(75, 0, 0.1, 1e3);
        re || (ue.position.z = 5, U && (Fd(ue, U), ("aspect" in U || "left" in U || "right" in U || "bottom" in U || "top" in U) && (ue.manual = !0, ue.updateProjectionMatrix())), !q.camera && !(U != null && U.rotation) && ue.lookAt(0, 0, 0)), q.set({
          camera: ue
        }), ye.camera = ue;
      }
      if (!q.scene) {
        let re;
        _ != null && _.isScene ? re = _ : (re = new qE(), _ && Fd(re, _)), q.set({
          scene: Bd(re)
        });
      }
      if (!q.xr) {
        var ie;
        const re = (pe, Ae) => {
          const qe = o.getState();
          qe.frameloop !== "never" && SR(pe, !0, qe, Ae);
        }, ue = () => {
          const pe = o.getState();
          pe.gl.xr.enabled = pe.gl.xr.isPresenting, pe.gl.xr.setAnimationLoop(pe.gl.xr.isPresenting ? re : null), pe.gl.xr.isPresenting || _R(pe);
        }, Le = {
          connect() {
            const pe = o.getState().gl;
            pe.xr.addEventListener("sessionstart", ue), pe.xr.addEventListener("sessionend", ue);
          },
          disconnect() {
            const pe = o.getState().gl;
            pe.xr.removeEventListener("sessionstart", ue), pe.xr.removeEventListener("sessionend", ue);
          }
        };
        typeof ((ie = le.xr) == null ? void 0 : ie.addEventListener) == "function" && Le.connect(), q.set({
          xr: Le
        });
      }
      if (le.shadowMap) {
        const re = le.shadowMap.enabled, ue = le.shadowMap.type;
        if (le.shadowMap.enabled = !!T, ei.boo(T))
          le.shadowMap.type = Zp;
        else if (ei.str(T)) {
          var Ee;
          const Le = {
            basic: VC,
            percentage: u0,
            soft: Zp,
            variance: za
          };
          le.shadowMap.type = (Ee = Le[T]) != null ? Ee : Zp;
        } else ei.obj(T) && Object.assign(le.shadowMap, T);
        (re !== le.shadowMap.enabled || ue !== le.shadowMap.type) && (le.shadowMap.needsUpdate = !0);
      }
      const Q = ZL();
      Q && ("enabled" in Q ? Q.enabled = !A : "legacyMode" in Q && (Q.legacyMode = A)), d || Fd(le, {
        outputEncoding: M ? 3e3 : 3001,
        toneMapping: C ? mo : wE
      }), q.legacy !== A && q.set(() => ({
        legacy: A
      })), q.linear !== M && q.set(() => ({
        linear: M
      })), q.flat !== C && q.set(() => ({
        flat: C
      })), g && !ei.fun(g) && !iD(g) && !ei.equ(g, le, zd) && Fd(le, g), E && !q.events.handlers && q.set({
        events: E(o)
      });
      const se = X4(i, y);
      return ei.equ(se, q.size, zd) || q.setSize(se.width, se.height, se.updateStyle, se.top, se.left), I && q.viewport.dpr !== eD(I) && q.setDpr(I), q.frameloop !== z && q.setFrameloop(z), q.onPointerMissed || q.set({
        onPointerMissed: O
      }), V && !ei.equ(V, q.performance, zd) && q.set((re) => ({
        performance: {
          ...re.performance,
          ...V
        }
      })), u = w, d = !0, this;
    },
    render(m) {
      return d || this.configure(), $y.updateContainer(/* @__PURE__ */ _n.jsx(Y4, {
        store: o,
        children: m,
        onCreated: u,
        rootElement: i
      }), l, null, () => {
      }), o;
    },
    unmount() {
      oD(i);
    }
  };
}
function Y4({
  store: i,
  children: e,
  onCreated: t,
  rootElement: n
}) {
  return Hm(() => {
    const r = i.getState();
    r.set((o) => ({
      internal: {
        ...o.internal,
        active: !0
      }
    })), t && t(r), i.getState().events.connected || r.events.connect == null || r.events.connect(n);
  }, []), /* @__PURE__ */ _n.jsx(rD.Provider, {
    value: i,
    children: e
  });
}
function oD(i, e) {
  const t = ih.get(i), n = t == null ? void 0 : t.fiber;
  if (n) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1), $y.updateContainer(null, n, null, () => {
      r && setTimeout(() => {
        try {
          var o, l, u, d;
          r.events.disconnect == null || r.events.disconnect(), (o = r.gl) == null || (l = o.renderLists) == null || l.dispose == null || l.dispose(), (u = r.gl) == null || u.forceContextLoss == null || u.forceContextLoss(), (d = r.gl) != null && d.xr && r.xr.disconnect(), N4(r), ih.delete(i);
        } catch {
        }
      }, 500);
    });
  }
}
$y.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: Lt.version
});
const eM = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function q4(i) {
  const {
    handlePointer: e
  } = z4(i);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, r) {
      n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(eM).reduce((t, n) => ({
      ...t,
      [n]: e(n)
    }), {}),
    update: () => {
      var t;
      const {
        events: n,
        internal: r
      } = i.getState();
      (t = r.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const {
        set: r,
        events: o
      } = i.getState();
      o.disconnect == null || o.disconnect(), r((l) => ({
        events: {
          ...l.events,
          connected: t
        }
      })), Object.entries((n = o.handlers) != null ? n : []).forEach(([l, u]) => {
        const [d, h] = eM[l];
        t.addEventListener(d, u, {
          passive: h
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: n
      } = i.getState();
      if (n.connected) {
        var r;
        Object.entries((r = n.handlers) != null ? r : []).forEach(([o, l]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [u] = eM[o];
            n.connected.removeEventListener(u, l);
          }
        }), t((o) => ({
          events: {
            ...o.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function MR(i, e) {
  let t;
  return (...n) => {
    window.clearTimeout(t), t = window.setTimeout(() => i(...n), e);
  };
}
function Z4({ debounce: i, scroll: e, polyfill: t, offsetSize: n } = { debounce: 0, scroll: !1, offsetSize: !1 }) {
  const r = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!r) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [o, l] = qp({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), u = fr({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: o, orientationHandler: null }), d = i ? typeof i == "number" ? i : i.scroll : null, h = i ? typeof i == "number" ? i : i.resize : null, m = fr(!1);
  Hs(() => (m.current = !0, () => void (m.current = !1)));
  const [g, y, _] = zc(() => {
    const M = () => {
      if (!u.current.element) return;
      const { left: C, top: A, width: N, height: z, bottom: I, right: V, x: W, y: U } = u.current.element.getBoundingClientRect(), O = { left: C, top: A, width: N, height: z, bottom: I, right: V, x: W, y: U };
      u.current.element instanceof HTMLElement && n && (O.height = u.current.element.offsetHeight, O.width = u.current.element.offsetWidth), Object.freeze(O), m.current && !$4(u.current.lastBounds, O) && l(u.current.lastBounds = O);
    };
    return [M, h ? MR(M, h) : M, d ? MR(M, d) : M];
  }, [l, n, d, h]);
  function E() {
    u.current.scrollContainers && (u.current.scrollContainers.forEach((M) => M.removeEventListener("scroll", _, !0)), u.current.scrollContainers = null), u.current.resizeObserver && (u.current.resizeObserver.disconnect(), u.current.resizeObserver = null), u.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", u.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", u.current.orientationHandler));
  }
  function w() {
    u.current.element && (u.current.resizeObserver = new r(_), u.current.resizeObserver.observe(u.current.element), e && u.current.scrollContainers && u.current.scrollContainers.forEach((M) => M.addEventListener("scroll", _, { capture: !0, passive: !0 })), u.current.orientationHandler = () => {
      _();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", u.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", u.current.orientationHandler));
  }
  const T = (M) => {
    !M || M === u.current.element || (E(), u.current.element = M, u.current.scrollContainers = lD(M), w());
  };
  return J4(_, !!e), K4(y), Hs(() => {
    E(), w();
  }, [e, _, y]), Hs(() => E, []), [T, o, g];
}
function K4(i) {
  Hs(() => {
    const e = i;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [i]);
}
function J4(i, e) {
  Hs(() => {
    if (e) {
      const t = i;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [i, e]);
}
function lD(i) {
  const e = [];
  if (!i || i === document.body) return e;
  const { overflow: t, overflowX: n, overflowY: r } = window.getComputedStyle(i);
  return [t, n, r].some((o) => o === "auto" || o === "scroll") && e.push(i), [...e, ...lD(i.parentElement)];
}
const Q4 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], $4 = (i, e) => Q4.every((t) => i[t] === e[t]);
var eG = Object.defineProperty, tG = Object.defineProperties, nG = Object.getOwnPropertyDescriptors, ER = Object.getOwnPropertySymbols, iG = Object.prototype.hasOwnProperty, rG = Object.prototype.propertyIsEnumerable, bR = (i, e, t) => e in i ? eG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, TR = (i, e) => {
  for (var t in e || (e = {}))
    iG.call(e, t) && bR(i, t, e[t]);
  if (ER)
    for (var t of ER(e))
      rG.call(e, t) && bR(i, t, e[t]);
  return i;
}, sG = (i, e) => tG(i, nG(e)), wR, AR;
typeof window < "u" && ((wR = window.document) != null && wR.createElement || ((AR = window.navigator) == null ? void 0 : AR.product) === "ReactNative") ? Lt.useLayoutEffect : Lt.useEffect;
function uD(i, e, t) {
  if (!i)
    return;
  if (t(i) === !0)
    return i;
  let n = i.child;
  for (; n; ) {
    const r = uD(n, e, t);
    if (r)
      return r;
    n = n.sibling;
  }
}
function cD(i) {
  try {
    return Object.defineProperties(i, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return i;
  }
}
const RR = console.error;
console.error = function() {
  const i = [...arguments].join("");
  if (i != null && i.startsWith("Warning:") && i.includes("useContext")) {
    console.error = RR;
    return;
  }
  return RR.apply(this, arguments);
};
const gb = cD(Lt.createContext(null));
class fD extends Lt.Component {
  render() {
    return /* @__PURE__ */ Lt.createElement(gb.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function aG() {
  const i = Lt.useContext(gb);
  if (i === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = Lt.useId();
  return Lt.useMemo(() => {
    for (const n of [i, i == null ? void 0 : i.alternate]) {
      if (!n)
        continue;
      const r = uD(n, !1, (o) => {
        let l = o.memoizedState;
        for (; l; ) {
          if (l.memoizedState === e)
            return !0;
          l = l.next;
        }
      });
      if (r)
        return r;
    }
  }, [i, e]);
}
function oG() {
  const i = aG(), [e] = Lt.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = i;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const r = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      r && r !== gb && !e.has(r) && e.set(r, Lt.useContext(cD(r)));
    }
    t = t.return;
  }
  return e;
}
function lG() {
  const i = oG();
  return Lt.useMemo(
    () => Array.from(i.keys()).reduce(
      (e, t) => (n) => /* @__PURE__ */ Lt.createElement(e, null, /* @__PURE__ */ Lt.createElement(t.Provider, sG(TR({}, n), {
        value: i.get(t)
      }))),
      (e) => /* @__PURE__ */ Lt.createElement(fD, TR({}, e))
    ),
    [i]
  );
}
const uG = /* @__PURE__ */ Lt.forwardRef(function({
  children: e,
  fallback: t,
  resize: n,
  style: r,
  gl: o,
  events: l = q4,
  eventSource: u,
  eventPrefix: d,
  shadows: h,
  linear: m,
  flat: g,
  legacy: y,
  orthographic: _,
  frameloop: E,
  dpr: w,
  performance: T,
  raycaster: M,
  camera: C,
  scene: A,
  onPointerMissed: N,
  onCreated: z,
  ...I
}, V) {
  Lt.useMemo(() => R4(v4), []);
  const W = lG(), [U, O] = Z4({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...n
  }), q = Lt.useRef(null), le = Lt.useRef(null);
  Lt.useImperativeHandle(V, () => q.current);
  const ye = JL(N), [K, oe] = Lt.useState(!1), [ie, Ee] = Lt.useState(!1);
  if (K) throw K;
  if (ie) throw ie;
  const Q = Lt.useRef(null);
  Hm(() => {
    const re = q.current;
    O.width > 0 && O.height > 0 && re && (Q.current || (Q.current = j4(re)), Q.current.configure({
      gl: o,
      events: l,
      shadows: h,
      linear: m,
      flat: g,
      legacy: y,
      orthographic: _,
      frameloop: E,
      dpr: w,
      performance: T,
      raycaster: M,
      camera: C,
      scene: A,
      size: O,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...ue) => ye.current == null ? void 0 : ye.current(...ue),
      onCreated: (ue) => {
        ue.events.connect == null || ue.events.connect(u ? P4(u) ? u.current : u : le.current), d && ue.setEvents({
          compute: (Le, pe) => {
            const Ae = Le[d + "X"], qe = Le[d + "Y"];
            pe.pointer.set(Ae / pe.size.width * 2 - 1, -(qe / pe.size.height) * 2 + 1), pe.raycaster.setFromCamera(pe.pointer, pe.camera);
          }
        }), z == null || z(ue);
      }
    }), Q.current.render(/* @__PURE__ */ _n.jsx(W, {
      children: /* @__PURE__ */ _n.jsx(QL, {
        set: Ee,
        children: /* @__PURE__ */ _n.jsx(Lt.Suspense, {
          fallback: /* @__PURE__ */ _n.jsx(L4, {
            set: oe
          }),
          children: e ?? null
        })
      })
    })));
  }), Lt.useEffect(() => {
    const re = q.current;
    if (re) return () => oD(re);
  }, []);
  const se = u ? "none" : "auto";
  return /* @__PURE__ */ _n.jsx("div", {
    ref: le,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: se,
      ...r
    },
    ...I,
    children: /* @__PURE__ */ _n.jsx("div", {
      ref: U,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ _n.jsx("canvas", {
        ref: q,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), cG = /* @__PURE__ */ Lt.forwardRef(function(e, t) {
  return /* @__PURE__ */ _n.jsx(fD, {
    children: /* @__PURE__ */ _n.jsx(uG, {
      ...e,
      ref: t
    })
  });
}), dD = ah({
  transformPagePoint: (i) => i,
  isStatic: !1,
  reducedMotion: "never"
}), I0 = ah({}), F0 = ah(null), z0 = typeof document < "u", yb = z0 ? IC : Hs, hD = ah({ strict: !1 }), xb = (i) => i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), fG = "framerAppearId", pD = "data-" + xb(fG);
function dG(i, e, t, n) {
  const { visualElement: r } = rs(I0), o = rs(hD), l = rs(F0), u = rs(dD).reducedMotion, d = fr();
  n = n || o.renderer, !d.current && n && (d.current = n(i, {
    visualState: e,
    parent: r,
    props: t,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: u
  }));
  const h = d.current;
  FC(() => {
    h && h.update(t, l);
  });
  const m = fr(!!(t[pD] && !window.HandoffComplete));
  return yb(() => {
    h && (h.render(), m.current && h.animationState && h.animationState.animateChanges());
  }), Hs(() => {
    h && (h.updateFeatures(), !m.current && h.animationState && h.animationState.animateChanges(), m.current && (m.current = !1, window.HandoffComplete = !0));
  }), h;
}
function Yd(i) {
  return i && typeof i == "object" && Object.prototype.hasOwnProperty.call(i, "current");
}
function hG(i, e, t) {
  return pM(
    (n) => {
      n && i.mount && i.mount(n), e && (n ? e.mount(n) : e.unmount()), t && (typeof t == "function" ? t(n) : Yd(t) && (t.current = n));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function wm(i) {
  return typeof i == "string" || Array.isArray(i);
}
function B0(i) {
  return i !== null && typeof i == "object" && typeof i.start == "function";
}
const _b = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Sb = ["initial", ..._b];
function V0(i) {
  return B0(i.animate) || Sb.some((e) => wm(i[e]));
}
function mD(i) {
  return !!(V0(i) || i.variants);
}
function pG(i, e) {
  if (V0(i)) {
    const { initial: t, animate: n } = i;
    return {
      initial: t === !1 || wm(t) ? t : void 0,
      animate: wm(n) ? n : void 0
    };
  }
  return i.inherit !== !1 ? e : {};
}
function mG(i) {
  const { initial: e, animate: t } = pG(i, rs(I0));
  return zc(() => ({ initial: e, animate: t }), [CR(e), CR(t)]);
}
function CR(i) {
  return Array.isArray(i) ? i.join(" ") : i;
}
const PR = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Am = {};
for (const i in PR)
  Am[i] = {
    isEnabled: (e) => PR[i].some((t) => !!e[t])
  };
function vG(i) {
  for (const e in i)
    Am[e] = {
      ...Am[e],
      ...i[e]
    };
}
const Mb = ah({}), vD = ah({}), gG = Symbol.for("motionComponentSymbol");
function yG({ preloadedFeatures: i, createVisualElement: e, useRender: t, useVisualState: n, Component: r }) {
  i && vG(i);
  function o(u, d) {
    let h;
    const m = {
      ...rs(dD),
      ...u,
      layoutId: xG(u)
    }, { isStatic: g } = m, y = mG(u), _ = n(u, g);
    if (!g && z0) {
      y.visualElement = dG(r, _, m, e);
      const E = rs(vD), w = rs(hD).strict;
      y.visualElement && (h = y.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        m,
        w,
        i,
        E
      ));
    }
    return Lt.createElement(
      I0.Provider,
      { value: y },
      h && y.visualElement ? Lt.createElement(h, { visualElement: y.visualElement, ...m }) : null,
      t(r, u, hG(_, y.visualElement, d), _, g, y.visualElement)
    );
  }
  const l = vO(o);
  return l[gG] = r, l;
}
function xG({ layoutId: i }) {
  const e = rs(Mb).id;
  return e && i !== void 0 ? e + "-" + i : i;
}
function _G(i) {
  function e(n, r = {}) {
    return yG(i(n, r));
  }
  if (typeof Proxy > "u")
    return e;
  const t = /* @__PURE__ */ new Map();
  return new Proxy(e, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n, r) => (t.has(r) || t.set(r, e(r)), t.get(r))
  });
}
const SG = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Eb(i) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof i != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    i.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(SG.indexOf(i) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(i))
    )
  );
}
const e0 = {};
function MG(i) {
  Object.assign(e0, i);
}
const km = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Yc = new Set(km);
function gD(i, { layout: e, layoutId: t }) {
  return Yc.has(i) || i.startsWith("origin") || (e || t !== void 0) && (!!e0[i] || i === "opacity");
}
const bs = (i) => !!(i && i.getVelocity), EG = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, bG = km.length;
function TG(i, { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 }, n, r) {
  let o = "";
  for (let l = 0; l < bG; l++) {
    const u = km[l];
    if (i[u] !== void 0) {
      const d = EG[u] || u;
      o += `${d}(${i[u]}) `;
    }
  }
  return e && !i.z && (o += "translateZ(0)"), o = o.trim(), r ? o = r(i, n ? "" : o) : t && n && (o = "none"), o;
}
const yD = (i) => (e) => typeof e == "string" && e.startsWith(i), xD = yD("--"), fE = yD("var(--"), wG = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, AG = (i, e) => e && typeof i == "number" ? e.transform(i) : i, xu = (i, e, t) => Math.min(Math.max(t, i), e), qc = {
  test: (i) => typeof i == "number",
  parse: parseFloat,
  transform: (i) => i
}, tm = {
  ...qc,
  transform: (i) => xu(0, 1, i)
}, Py = {
  ...qc,
  default: 1
}, nm = (i) => Math.round(i * 1e5) / 1e5, H0 = /(-)?([\d]*\.?[\d])+/g, _D = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, RG = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function Gm(i) {
  return typeof i == "string";
}
const Wm = (i) => ({
  test: (e) => Gm(e) && e.endsWith(i) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${i}`
}), ou = Wm("deg"), yo = Wm("%"), Kt = Wm("px"), CG = Wm("vh"), PG = Wm("vw"), LR = {
  ...yo,
  parse: (i) => yo.parse(i) / 100,
  transform: (i) => yo.transform(i * 100)
}, DR = {
  ...qc,
  transform: Math.round
}, SD = {
  // Border props
  borderWidth: Kt,
  borderTopWidth: Kt,
  borderRightWidth: Kt,
  borderBottomWidth: Kt,
  borderLeftWidth: Kt,
  borderRadius: Kt,
  radius: Kt,
  borderTopLeftRadius: Kt,
  borderTopRightRadius: Kt,
  borderBottomRightRadius: Kt,
  borderBottomLeftRadius: Kt,
  // Positioning props
  width: Kt,
  maxWidth: Kt,
  height: Kt,
  maxHeight: Kt,
  size: Kt,
  top: Kt,
  right: Kt,
  bottom: Kt,
  left: Kt,
  // Spacing props
  padding: Kt,
  paddingTop: Kt,
  paddingRight: Kt,
  paddingBottom: Kt,
  paddingLeft: Kt,
  margin: Kt,
  marginTop: Kt,
  marginRight: Kt,
  marginBottom: Kt,
  marginLeft: Kt,
  // Transform props
  rotate: ou,
  rotateX: ou,
  rotateY: ou,
  rotateZ: ou,
  scale: Py,
  scaleX: Py,
  scaleY: Py,
  scaleZ: Py,
  skew: ou,
  skewX: ou,
  skewY: ou,
  distance: Kt,
  translateX: Kt,
  translateY: Kt,
  translateZ: Kt,
  x: Kt,
  y: Kt,
  z: Kt,
  perspective: Kt,
  transformPerspective: Kt,
  opacity: tm,
  originX: LR,
  originY: LR,
  originZ: Kt,
  // Misc
  zIndex: DR,
  // SVG
  fillOpacity: tm,
  strokeOpacity: tm,
  numOctaves: DR
};
function bb(i, e, t, n) {
  const { style: r, vars: o, transform: l, transformOrigin: u } = i;
  let d = !1, h = !1, m = !0;
  for (const g in e) {
    const y = e[g];
    if (xD(g)) {
      o[g] = y;
      continue;
    }
    const _ = SD[g], E = AG(y, _);
    if (Yc.has(g)) {
      if (d = !0, l[g] = E, !m)
        continue;
      y !== (_.default || 0) && (m = !1);
    } else g.startsWith("origin") ? (h = !0, u[g] = E) : r[g] = E;
  }
  if (e.transform || (d || n ? r.transform = TG(i.transform, t, m, n) : r.transform && (r.transform = "none")), h) {
    const { originX: g = "50%", originY: y = "50%", originZ: _ = 0 } = u;
    r.transformOrigin = `${g} ${y} ${_}`;
  }
}
const Tb = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function MD(i, e, t) {
  for (const n in e)
    !bs(e[n]) && !gD(n, t) && (i[n] = e[n]);
}
function LG({ transformTemplate: i }, e, t) {
  return zc(() => {
    const n = Tb();
    return bb(n, e, { enableHardwareAcceleration: !t }, i), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function DG(i, e, t) {
  const n = i.style || {}, r = {};
  return MD(r, n, i), Object.assign(r, LG(i, e, t)), i.transformValues ? i.transformValues(r) : r;
}
function NG(i, e, t) {
  const n = {}, r = DG(i, e, t);
  return i.drag && i.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = i.drag === !0 ? "none" : `pan-${i.drag === "x" ? "y" : "x"}`), i.tabIndex === void 0 && (i.onTap || i.onTapStart || i.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const UG = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function t0(i) {
  return i.startsWith("while") || i.startsWith("drag") && i !== "draggable" || i.startsWith("layout") || i.startsWith("onTap") || i.startsWith("onPan") || i.startsWith("onLayout") || UG.has(i);
}
let ED = (i) => !t0(i);
function OG(i) {
  i && (ED = (e) => e.startsWith("on") ? !t0(e) : i(e));
}
try {
  OG(require("@emotion/is-prop-valid").default);
} catch {
}
function IG(i, e, t) {
  const n = {};
  for (const r in i)
    r === "values" && typeof i.values == "object" || (ED(r) || t === !0 && t0(r) || !e && !t0(r) || // If trying to use native HTML drag events, forward drag listeners
    i.draggable && r.startsWith("onDrag")) && (n[r] = i[r]);
  return n;
}
function NR(i, e, t) {
  return typeof i == "string" ? i : Kt.transform(e + t * i);
}
function FG(i, e, t) {
  const n = NR(e, i.x, i.width), r = NR(t, i.y, i.height);
  return `${n} ${r}`;
}
const zG = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, BG = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function VG(i, e, t = 1, n = 0, r = !0) {
  i.pathLength = 1;
  const o = r ? zG : BG;
  i[o.offset] = Kt.transform(-n);
  const l = Kt.transform(e), u = Kt.transform(t);
  i[o.array] = `${l} ${u}`;
}
function wb(i, {
  attrX: e,
  attrY: t,
  attrScale: n,
  originX: r,
  originY: o,
  pathLength: l,
  pathSpacing: u = 1,
  pathOffset: d = 0,
  // This is object creation, which we try to avoid per-frame.
  ...h
}, m, g, y) {
  if (bb(i, h, m, y), g) {
    i.style.viewBox && (i.attrs.viewBox = i.style.viewBox);
    return;
  }
  i.attrs = i.style, i.style = {};
  const { attrs: _, style: E, dimensions: w } = i;
  _.transform && (w && (E.transform = _.transform), delete _.transform), w && (r !== void 0 || o !== void 0 || E.transform) && (E.transformOrigin = FG(w, r !== void 0 ? r : 0.5, o !== void 0 ? o : 0.5)), e !== void 0 && (_.x = e), t !== void 0 && (_.y = t), n !== void 0 && (_.scale = n), l !== void 0 && VG(_, l, u, d, !1);
}
const bD = () => ({
  ...Tb(),
  attrs: {}
}), Ab = (i) => typeof i == "string" && i.toLowerCase() === "svg";
function HG(i, e, t, n) {
  const r = zc(() => {
    const o = bD();
    return wb(o, e, { enableHardwareAcceleration: !1 }, Ab(n), i.transformTemplate), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [e]);
  if (i.style) {
    const o = {};
    MD(o, i.style, i), r.style = { ...o, ...r.style };
  }
  return r;
}
function kG(i = !1) {
  return (t, n, r, { latestValues: o }, l) => {
    const d = (Eb(t) ? HG : NG)(n, o, l, t), m = {
      ...IG(n, typeof t == "string", i),
      ...d,
      ref: r
    }, { children: g } = n, y = zc(() => bs(g) ? g.get() : g, [g]);
    return gO(t, {
      ...m,
      children: y
    });
  };
}
function TD(i, { style: e, vars: t }, n, r) {
  Object.assign(i.style, e, r && r.getProjectionStyles(n));
  for (const o in t)
    i.style.setProperty(o, t[o]);
}
const wD = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function AD(i, e, t, n) {
  TD(i, e, void 0, n);
  for (const r in e.attrs)
    i.setAttribute(wD.has(r) ? r : xb(r), e.attrs[r]);
}
function Rb(i, e) {
  const { style: t } = i, n = {};
  for (const r in t)
    (bs(t[r]) || e.style && bs(e.style[r]) || gD(r, i)) && (n[r] = t[r]);
  return n;
}
function RD(i, e) {
  const t = Rb(i, e);
  for (const n in i)
    if (bs(i[n]) || bs(e[n])) {
      const r = km.indexOf(n) !== -1 ? "attr" + n.charAt(0).toUpperCase() + n.substring(1) : n;
      t[r] = i[n];
    }
  return t;
}
function Cb(i, e, t, n = {}, r = {}) {
  return typeof e == "function" && (e = e(t !== void 0 ? t : i.custom, n, r)), typeof e == "string" && (e = i.variants && i.variants[e]), typeof e == "function" && (e = e(t !== void 0 ? t : i.custom, n, r)), e;
}
function CD(i) {
  const e = fr(null);
  return e.current === null && (e.current = i()), e.current;
}
const n0 = (i) => Array.isArray(i), GG = (i) => !!(i && typeof i == "object" && i.mix && i.toValue), WG = (i) => n0(i) ? i[i.length - 1] || 0 : i;
function Wy(i) {
  const e = bs(i) ? i.get() : i;
  return GG(e) ? e.toValue() : e;
}
function XG({ scrapeMotionValuesFromProps: i, createRenderState: e, onMount: t }, n, r, o) {
  const l = {
    latestValues: jG(n, r, o, i),
    renderState: e()
  };
  return t && (l.mount = (u) => t(n, u, l)), l;
}
const PD = (i) => (e, t) => {
  const n = rs(I0), r = rs(F0), o = () => XG(i, e, n, r);
  return t ? o() : CD(o);
};
function jG(i, e, t, n) {
  const r = {}, o = n(i, {});
  for (const y in o)
    r[y] = Wy(o[y]);
  let { initial: l, animate: u } = i;
  const d = V0(i), h = mD(i);
  e && h && !d && i.inherit !== !1 && (l === void 0 && (l = e.initial), u === void 0 && (u = e.animate));
  let m = t ? t.initial === !1 : !1;
  m = m || l === !1;
  const g = m ? u : l;
  return g && typeof g != "boolean" && !B0(g) && (Array.isArray(g) ? g : [g]).forEach((_) => {
    const E = Cb(i, _);
    if (!E)
      return;
    const { transitionEnd: w, transition: T, ...M } = E;
    for (const C in M) {
      let A = M[C];
      if (Array.isArray(A)) {
        const N = m ? A.length - 1 : 0;
        A = A[N];
      }
      A !== null && (r[C] = A);
    }
    for (const C in w)
      r[C] = w[C];
  }), r;
}
const Ei = (i) => i;
class UR {
  constructor() {
    this.order = [], this.scheduled = /* @__PURE__ */ new Set();
  }
  add(e) {
    if (!this.scheduled.has(e))
      return this.scheduled.add(e), this.order.push(e), !0;
  }
  remove(e) {
    const t = this.order.indexOf(e);
    t !== -1 && (this.order.splice(t, 1), this.scheduled.delete(e));
  }
  clear() {
    this.order.length = 0, this.scheduled.clear();
  }
}
function YG(i) {
  let e = new UR(), t = new UR(), n = 0, r = !1, o = !1;
  const l = /* @__PURE__ */ new WeakSet(), u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (d, h = !1, m = !1) => {
      const g = m && r, y = g ? e : t;
      return h && l.add(d), y.add(d) && g && r && (n = e.order.length), d;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (d) => {
      t.remove(d), l.delete(d);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (d) => {
      if (r) {
        o = !0;
        return;
      }
      if (r = !0, [e, t] = [t, e], t.clear(), n = e.order.length, n)
        for (let h = 0; h < n; h++) {
          const m = e.order[h];
          m(d), l.has(m) && (u.schedule(m), i());
        }
      r = !1, o && (o = !1, u.process(d));
    }
  };
  return u;
}
const Ly = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], qG = 40;
function ZG(i, e) {
  let t = !1, n = !0;
  const r = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = Ly.reduce((g, y) => (g[y] = YG(() => t = !0), g), {}), l = (g) => o[g].process(r), u = () => {
    const g = performance.now();
    t = !1, r.delta = n ? 1e3 / 60 : Math.max(Math.min(g - r.timestamp, qG), 1), r.timestamp = g, r.isProcessing = !0, Ly.forEach(l), r.isProcessing = !1, t && e && (n = !1, i(u));
  }, d = () => {
    t = !0, n = !0, r.isProcessing || i(u);
  };
  return { schedule: Ly.reduce((g, y) => {
    const _ = o[y];
    return g[y] = (E, w = !1, T = !1) => (t || d(), _.schedule(E, w, T)), g;
  }, {}), cancel: (g) => Ly.forEach((y) => o[y].cancel(g)), state: r, steps: o };
}
const { schedule: qn, cancel: ll, state: Gr, steps: tM } = ZG(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Ei, !0), KG = {
  useVisualState: PD({
    scrapeMotionValuesFromProps: RD,
    createRenderState: bD,
    onMount: (i, e, { renderState: t, latestValues: n }) => {
      qn.read(() => {
        try {
          t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          t.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), qn.render(() => {
        wb(t, n, { enableHardwareAcceleration: !1 }, Ab(e.tagName), i.transformTemplate), AD(e, t);
      });
    }
  })
}, JG = {
  useVisualState: PD({
    scrapeMotionValuesFromProps: Rb,
    createRenderState: Tb
  })
};
function QG(i, { forwardMotionProps: e = !1 }, t, n) {
  return {
    ...Eb(i) ? KG : JG,
    preloadedFeatures: t,
    useRender: kG(e),
    createVisualElement: n,
    Component: i
  };
}
function tl(i, e, t, n = { passive: !0 }) {
  return i.addEventListener(e, t, n), () => i.removeEventListener(e, t);
}
const LD = (i) => i.pointerType === "mouse" ? typeof i.button != "number" || i.button <= 0 : i.isPrimary !== !1;
function k0(i, e = "page") {
  return {
    point: {
      x: i[e + "X"],
      y: i[e + "Y"]
    }
  };
}
const $G = (i) => (e) => LD(e) && i(e, k0(e));
function il(i, e, t, n) {
  return tl(i, e, $G(t), n);
}
const e5 = (i, e) => (t) => e(i(t)), pu = (...i) => i.reduce(e5);
function DD(i) {
  let e = null;
  return () => {
    const t = () => {
      e = null;
    };
    return e === null ? (e = i, t) : !1;
  };
}
const OR = DD("dragHorizontal"), IR = DD("dragVertical");
function ND(i) {
  let e = !1;
  if (i === "y")
    e = IR();
  else if (i === "x")
    e = OR();
  else {
    const t = OR(), n = IR();
    t && n ? e = () => {
      t(), n();
    } : (t && t(), n && n());
  }
  return e;
}
function UD() {
  const i = ND(!0);
  return i ? (i(), !1) : !0;
}
class Tu {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
function FR(i, e) {
  const t = "pointer" + (e ? "enter" : "leave"), n = "onHover" + (e ? "Start" : "End"), r = (o, l) => {
    if (o.pointerType === "touch" || UD())
      return;
    const u = i.getProps();
    i.animationState && u.whileHover && i.animationState.setActive("whileHover", e), u[n] && qn.update(() => u[n](o, l));
  };
  return il(i.current, t, r, {
    passive: !i.getProps()[n]
  });
}
class t5 extends Tu {
  mount() {
    this.unmount = pu(FR(this.node, !0), FR(this.node, !1));
  }
  unmount() {
  }
}
class n5 extends Tu {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pu(tl(this.node.current, "focus", () => this.onFocus()), tl(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const OD = (i, e) => e ? i === e ? !0 : OD(i, e.parentElement) : !1;
function nM(i, e) {
  if (!e)
    return;
  const t = new PointerEvent("pointer" + i);
  e(t, k0(t));
}
class i5 extends Tu {
  constructor() {
    super(...arguments), this.removeStartListeners = Ei, this.removeEndListeners = Ei, this.removeAccessibleListeners = Ei, this.startPointerPress = (e, t) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const n = this.node.getProps(), o = il(window, "pointerup", (u, d) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: h, onTapCancel: m, globalTapTarget: g } = this.node.getProps();
        qn.update(() => {
          !g && !OD(this.node.current, u.target) ? m && m(u, d) : h && h(u, d);
        });
      }, { passive: !(n.onTap || n.onPointerUp) }), l = il(window, "pointercancel", (u, d) => this.cancelPress(u, d), { passive: !(n.onTapCancel || n.onPointerCancel) });
      this.removeEndListeners = pu(o, l), this.startPress(e, t);
    }, this.startAccessiblePress = () => {
      const e = (o) => {
        if (o.key !== "Enter" || this.isPressing)
          return;
        const l = (u) => {
          u.key !== "Enter" || !this.checkPressEnd() || nM("up", (d, h) => {
            const { onTap: m } = this.node.getProps();
            m && qn.update(() => m(d, h));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = tl(this.node.current, "keyup", l), nM("down", (u, d) => {
          this.startPress(u, d);
        });
      }, t = tl(this.node.current, "keydown", e), n = () => {
        this.isPressing && nM("cancel", (o, l) => this.cancelPress(o, l));
      }, r = tl(this.node.current, "blur", n);
      this.removeAccessibleListeners = pu(t, r);
    };
  }
  startPress(e, t) {
    this.isPressing = !0;
    const { onTapStart: n, whileTap: r } = this.node.getProps();
    r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && qn.update(() => n(e, t));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !UD();
  }
  cancelPress(e, t) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: n } = this.node.getProps();
    n && qn.update(() => n(e, t));
  }
  mount() {
    const e = this.node.getProps(), t = il(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), n = tl(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pu(t, n);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const dE = /* @__PURE__ */ new WeakMap(), iM = /* @__PURE__ */ new WeakMap(), r5 = (i) => {
  const e = dE.get(i.target);
  e && e(i);
}, s5 = (i) => {
  i.forEach(r5);
};
function a5({ root: i, ...e }) {
  const t = i || document;
  iM.has(t) || iM.set(t, {});
  const n = iM.get(t), r = JSON.stringify(e);
  return n[r] || (n[r] = new IntersectionObserver(s5, { root: i, ...e })), n[r];
}
function o5(i, e, t) {
  const n = a5(e);
  return dE.set(i, t), n.observe(i), () => {
    dE.delete(i), n.unobserve(i);
  };
}
const l5 = {
  some: 0,
  all: 1
};
class u5 extends Tu {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: t, margin: n, amount: r = "some", once: o } = e, l = {
      root: t ? t.current : void 0,
      rootMargin: n,
      threshold: typeof r == "number" ? r : l5[r]
    }, u = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, o && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: m, onViewportLeave: g } = this.node.getProps(), y = h ? m : g;
      y && y(d);
    };
    return o5(this.node.current, l, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(c5(e, t)) && this.startObserver();
  }
  unmount() {
  }
}
function c5({ viewport: i = {} }, { viewport: e = {} } = {}) {
  return (t) => i[t] !== e[t];
}
const f5 = {
  inView: {
    Feature: u5
  },
  tap: {
    Feature: i5
  },
  focus: {
    Feature: n5
  },
  hover: {
    Feature: t5
  }
};
function ID(i, e) {
  if (!Array.isArray(e))
    return !1;
  const t = e.length;
  if (t !== i.length)
    return !1;
  for (let n = 0; n < t; n++)
    if (e[n] !== i[n])
      return !1;
  return !0;
}
function d5(i) {
  const e = {};
  return i.values.forEach((t, n) => e[n] = t.get()), e;
}
function h5(i) {
  const e = {};
  return i.values.forEach((t, n) => e[n] = t.getVelocity()), e;
}
function G0(i, e, t) {
  const n = i.getProps();
  return Cb(n, e, t !== void 0 ? t : n.custom, d5(i), h5(i));
}
let Xm = Ei, ma = Ei;
process.env.NODE_ENV !== "production" && (Xm = (i, e) => {
  !i && typeof console < "u" && console.warn(e);
}, ma = (i, e) => {
  if (!i)
    throw new Error(e);
});
const mu = (i) => i * 1e3, rl = (i) => i / 1e3, p5 = {
  current: !1
}, FD = (i) => Array.isArray(i) && typeof i[0] == "number";
function zD(i) {
  return !!(!i || typeof i == "string" && BD[i] || FD(i) || Array.isArray(i) && i.every(zD));
}
const Yp = ([i, e, t, n]) => `cubic-bezier(${i}, ${e}, ${t}, ${n})`, BD = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: Yp([0, 0.65, 0.55, 1]),
  circOut: Yp([0.55, 0, 1, 0.45]),
  backIn: Yp([0.31, 0.01, 0.66, -0.59]),
  backOut: Yp([0.33, 1.53, 0.69, 0.99])
};
function VD(i) {
  if (i)
    return FD(i) ? Yp(i) : Array.isArray(i) ? i.map(VD) : BD[i];
}
function m5(i, e, t, { delay: n = 0, duration: r, repeat: o = 0, repeatType: l = "loop", ease: u, times: d } = {}) {
  const h = { [e]: t };
  d && (h.offset = d);
  const m = VD(u);
  return Array.isArray(m) && (h.easing = m), i.animate(h, {
    delay: n,
    duration: r,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: o + 1,
    direction: l === "reverse" ? "alternate" : "normal"
  });
}
function v5(i, { repeat: e, repeatType: t = "loop" }) {
  const n = e && t !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return i[n];
}
const HD = (i, e, t) => (((1 - 3 * t + 3 * e) * i + (3 * t - 6 * e)) * i + 3 * e) * i, g5 = 1e-7, y5 = 12;
function x5(i, e, t, n, r) {
  let o, l, u = 0;
  do
    l = e + (t - e) / 2, o = HD(l, n, r) - i, o > 0 ? t = l : e = l;
  while (Math.abs(o) > g5 && ++u < y5);
  return l;
}
function jm(i, e, t, n) {
  if (i === e && t === n)
    return Ei;
  const r = (o) => x5(o, 0, 1, i, t);
  return (o) => o === 0 || o === 1 ? o : HD(r(o), e, n);
}
const _5 = jm(0.42, 0, 1, 1), S5 = jm(0, 0, 0.58, 1), kD = jm(0.42, 0, 0.58, 1), M5 = (i) => Array.isArray(i) && typeof i[0] != "number", GD = (i) => (e) => e <= 0.5 ? i(2 * e) / 2 : (2 - i(2 * (1 - e))) / 2, WD = (i) => (e) => 1 - i(1 - e), Pb = (i) => 1 - Math.sin(Math.acos(i)), XD = WD(Pb), E5 = GD(Pb), jD = jm(0.33, 1.53, 0.69, 0.99), Lb = WD(jD), b5 = GD(Lb), T5 = (i) => (i *= 2) < 1 ? 0.5 * Lb(i) : 0.5 * (2 - Math.pow(2, -10 * (i - 1))), zR = {
  linear: Ei,
  easeIn: _5,
  easeInOut: kD,
  easeOut: S5,
  circIn: Pb,
  circInOut: E5,
  circOut: XD,
  backIn: Lb,
  backInOut: b5,
  backOut: jD,
  anticipate: T5
}, BR = (i) => {
  if (Array.isArray(i)) {
    ma(i.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, t, n, r] = i;
    return jm(e, t, n, r);
  } else if (typeof i == "string")
    return ma(zR[i] !== void 0, `Invalid easing type '${i}'`), zR[i];
  return i;
}, Db = (i, e) => (t) => !!(Gm(t) && RG.test(t) && t.startsWith(i) || e && Object.prototype.hasOwnProperty.call(t, e)), YD = (i, e, t) => (n) => {
  if (!Gm(n))
    return n;
  const [r, o, l, u] = n.match(H0);
  return {
    [i]: parseFloat(r),
    [e]: parseFloat(o),
    [t]: parseFloat(l),
    alpha: u !== void 0 ? parseFloat(u) : 1
  };
}, w5 = (i) => xu(0, 255, i), rM = {
  ...qc,
  transform: (i) => Math.round(w5(i))
}, Dc = {
  test: Db("rgb", "red"),
  parse: YD("red", "green", "blue"),
  transform: ({ red: i, green: e, blue: t, alpha: n = 1 }) => "rgba(" + rM.transform(i) + ", " + rM.transform(e) + ", " + rM.transform(t) + ", " + nm(tm.transform(n)) + ")"
};
function A5(i) {
  let e = "", t = "", n = "", r = "";
  return i.length > 5 ? (e = i.substring(1, 3), t = i.substring(3, 5), n = i.substring(5, 7), r = i.substring(7, 9)) : (e = i.substring(1, 2), t = i.substring(2, 3), n = i.substring(3, 4), r = i.substring(4, 5), e += e, t += t, n += n, r += r), {
    red: parseInt(e, 16),
    green: parseInt(t, 16),
    blue: parseInt(n, 16),
    alpha: r ? parseInt(r, 16) / 255 : 1
  };
}
const hE = {
  test: Db("#"),
  parse: A5,
  transform: Dc.transform
}, qd = {
  test: Db("hsl", "hue"),
  parse: YD("hue", "saturation", "lightness"),
  transform: ({ hue: i, saturation: e, lightness: t, alpha: n = 1 }) => "hsla(" + Math.round(i) + ", " + yo.transform(nm(e)) + ", " + yo.transform(nm(t)) + ", " + nm(tm.transform(n)) + ")"
}, ns = {
  test: (i) => Dc.test(i) || hE.test(i) || qd.test(i),
  parse: (i) => Dc.test(i) ? Dc.parse(i) : qd.test(i) ? qd.parse(i) : hE.parse(i),
  transform: (i) => Gm(i) ? i : i.hasOwnProperty("red") ? Dc.transform(i) : qd.transform(i)
}, fi = (i, e, t) => -t * i + t * e + i;
function sM(i, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * (2 / 3 - t) * 6 : i;
}
function R5({ hue: i, saturation: e, lightness: t, alpha: n }) {
  i /= 360, e /= 100, t /= 100;
  let r = 0, o = 0, l = 0;
  if (!e)
    r = o = l = t;
  else {
    const u = t < 0.5 ? t * (1 + e) : t + e - t * e, d = 2 * t - u;
    r = sM(d, u, i + 1 / 3), o = sM(d, u, i), l = sM(d, u, i - 1 / 3);
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(o * 255),
    blue: Math.round(l * 255),
    alpha: n
  };
}
const aM = (i, e, t) => {
  const n = i * i;
  return Math.sqrt(Math.max(0, t * (e * e - n) + n));
}, C5 = [hE, Dc, qd], P5 = (i) => C5.find((e) => e.test(i));
function VR(i) {
  const e = P5(i);
  ma(!!e, `'${i}' is not an animatable color. Use the equivalent color code instead.`);
  let t = e.parse(i);
  return e === qd && (t = R5(t)), t;
}
const qD = (i, e) => {
  const t = VR(i), n = VR(e), r = { ...t };
  return (o) => (r.red = aM(t.red, n.red, o), r.green = aM(t.green, n.green, o), r.blue = aM(t.blue, n.blue, o), r.alpha = fi(t.alpha, n.alpha, o), Dc.transform(r));
};
function L5(i) {
  var e, t;
  return isNaN(i) && Gm(i) && (((e = i.match(H0)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = i.match(_D)) === null || t === void 0 ? void 0 : t.length) || 0) > 0;
}
const ZD = {
  regex: wG,
  countKey: "Vars",
  token: "${v}",
  parse: Ei
}, KD = {
  regex: _D,
  countKey: "Colors",
  token: "${c}",
  parse: ns.parse
}, JD = {
  regex: H0,
  countKey: "Numbers",
  token: "${n}",
  parse: qc.parse
};
function oM(i, { regex: e, countKey: t, token: n, parse: r }) {
  const o = i.tokenised.match(e);
  o && (i["num" + t] = o.length, i.tokenised = i.tokenised.replace(e, n), i.values.push(...o.map(r)));
}
function i0(i) {
  const e = i.toString(), t = {
    value: e,
    tokenised: e,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  return t.value.includes("var(--") && oM(t, ZD), oM(t, KD), oM(t, JD), t;
}
function QD(i) {
  return i0(i).values;
}
function $D(i) {
  const { values: e, numColors: t, numVars: n, tokenised: r } = i0(i), o = e.length;
  return (l) => {
    let u = r;
    for (let d = 0; d < o; d++)
      d < n ? u = u.replace(ZD.token, l[d]) : d < n + t ? u = u.replace(KD.token, ns.transform(l[d])) : u = u.replace(JD.token, nm(l[d]));
    return u;
  };
}
const D5 = (i) => typeof i == "number" ? 0 : i;
function N5(i) {
  const e = QD(i);
  return $D(i)(e.map(D5));
}
const _u = {
  test: L5,
  parse: QD,
  createTransformer: $D,
  getAnimatableNone: N5
}, e2 = (i, e) => (t) => `${t > 0 ? e : i}`;
function t2(i, e) {
  return typeof i == "number" ? (t) => fi(i, e, t) : ns.test(i) ? qD(i, e) : i.startsWith("var(") ? e2(i, e) : i2(i, e);
}
const n2 = (i, e) => {
  const t = [...i], n = t.length, r = i.map((o, l) => t2(o, e[l]));
  return (o) => {
    for (let l = 0; l < n; l++)
      t[l] = r[l](o);
    return t;
  };
}, U5 = (i, e) => {
  const t = { ...i, ...e }, n = {};
  for (const r in t)
    i[r] !== void 0 && e[r] !== void 0 && (n[r] = t2(i[r], e[r]));
  return (r) => {
    for (const o in n)
      t[o] = n[o](r);
    return t;
  };
}, i2 = (i, e) => {
  const t = _u.createTransformer(e), n = i0(i), r = i0(e);
  return n.numVars === r.numVars && n.numColors === r.numColors && n.numNumbers >= r.numNumbers ? pu(n2(n.values, r.values), t) : (Xm(!0, `Complex values '${i}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), e2(i, e));
}, Rm = (i, e, t) => {
  const n = e - i;
  return n === 0 ? 1 : (t - i) / n;
}, HR = (i, e) => (t) => fi(i, e, t);
function O5(i) {
  return typeof i == "number" ? HR : typeof i == "string" ? ns.test(i) ? qD : i2 : Array.isArray(i) ? n2 : typeof i == "object" ? U5 : HR;
}
function I5(i, e, t) {
  const n = [], r = t || O5(i[0]), o = i.length - 1;
  for (let l = 0; l < o; l++) {
    let u = r(i[l], i[l + 1]);
    if (e) {
      const d = Array.isArray(e) ? e[l] || Ei : e;
      u = pu(d, u);
    }
    n.push(u);
  }
  return n;
}
function r2(i, e, { clamp: t = !0, ease: n, mixer: r } = {}) {
  const o = i.length;
  if (ma(o === e.length, "Both input and output ranges must be the same length"), o === 1)
    return () => e[0];
  i[0] > i[o - 1] && (i = [...i].reverse(), e = [...e].reverse());
  const l = I5(e, n, r), u = l.length, d = (h) => {
    let m = 0;
    if (u > 1)
      for (; m < i.length - 2 && !(h < i[m + 1]); m++)
        ;
    const g = Rm(i[m], i[m + 1], h);
    return l[m](g);
  };
  return t ? (h) => d(xu(i[0], i[o - 1], h)) : d;
}
function F5(i, e) {
  const t = i[i.length - 1];
  for (let n = 1; n <= e; n++) {
    const r = Rm(0, e, n);
    i.push(fi(t, 1, r));
  }
}
function z5(i) {
  const e = [0];
  return F5(e, i.length - 1), e;
}
function B5(i, e) {
  return i.map((t) => t * e);
}
function V5(i, e) {
  return i.map(() => e || kD).splice(0, i.length - 1);
}
function r0({ duration: i = 300, keyframes: e, times: t, ease: n = "easeInOut" }) {
  const r = M5(n) ? n.map(BR) : BR(n), o = {
    done: !1,
    value: e[0]
  }, l = B5(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    t && t.length === e.length ? t : z5(e),
    i
  ), u = r2(l, e, {
    ease: Array.isArray(r) ? r : V5(e, r)
  });
  return {
    calculatedDuration: i,
    next: (d) => (o.value = u(d), o.done = d >= i, o)
  };
}
function s2(i, e) {
  return e ? i * (1e3 / e) : 0;
}
const H5 = 5;
function a2(i, e, t) {
  const n = Math.max(e - H5, 0);
  return s2(t - i(n), e - n);
}
const lM = 1e-3, k5 = 0.01, kR = 10, G5 = 0.05, W5 = 1;
function X5({ duration: i = 800, bounce: e = 0.25, velocity: t = 0, mass: n = 1 }) {
  let r, o;
  Xm(i <= mu(kR), "Spring duration must be 10 seconds or less");
  let l = 1 - e;
  l = xu(G5, W5, l), i = xu(k5, kR, rl(i)), l < 1 ? (r = (h) => {
    const m = h * l, g = m * i, y = m - t, _ = pE(h, l), E = Math.exp(-g);
    return lM - y / _ * E;
  }, o = (h) => {
    const g = h * l * i, y = g * t + t, _ = Math.pow(l, 2) * Math.pow(h, 2) * i, E = Math.exp(-g), w = pE(Math.pow(h, 2), l);
    return (-r(h) + lM > 0 ? -1 : 1) * ((y - _) * E) / w;
  }) : (r = (h) => {
    const m = Math.exp(-h * i), g = (h - t) * i + 1;
    return -lM + m * g;
  }, o = (h) => {
    const m = Math.exp(-h * i), g = (t - h) * (i * i);
    return m * g;
  });
  const u = 5 / i, d = Y5(r, o, u);
  if (i = mu(i), isNaN(d))
    return {
      stiffness: 100,
      damping: 10,
      duration: i
    };
  {
    const h = Math.pow(d, 2) * n;
    return {
      stiffness: h,
      damping: l * 2 * Math.sqrt(n * h),
      duration: i
    };
  }
}
const j5 = 12;
function Y5(i, e, t) {
  let n = t;
  for (let r = 1; r < j5; r++)
    n = n - i(n) / e(n);
  return n;
}
function pE(i, e) {
  return i * Math.sqrt(1 - e * e);
}
const q5 = ["duration", "bounce"], Z5 = ["stiffness", "damping", "mass"];
function GR(i, e) {
  return e.some((t) => i[t] !== void 0);
}
function K5(i) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...i
  };
  if (!GR(i, Z5) && GR(i, q5)) {
    const t = X5(i);
    e = {
      ...e,
      ...t,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function o2({ keyframes: i, restDelta: e, restSpeed: t, ...n }) {
  const r = i[0], o = i[i.length - 1], l = { done: !1, value: r }, { stiffness: u, damping: d, mass: h, duration: m, velocity: g, isResolvedFromDuration: y } = K5({
    ...n,
    velocity: -rl(n.velocity || 0)
  }), _ = g || 0, E = d / (2 * Math.sqrt(u * h)), w = o - r, T = rl(Math.sqrt(u / h)), M = Math.abs(w) < 5;
  t || (t = M ? 0.01 : 2), e || (e = M ? 5e-3 : 0.5);
  let C;
  if (E < 1) {
    const A = pE(T, E);
    C = (N) => {
      const z = Math.exp(-E * T * N);
      return o - z * ((_ + E * T * w) / A * Math.sin(A * N) + w * Math.cos(A * N));
    };
  } else if (E === 1)
    C = (A) => o - Math.exp(-T * A) * (w + (_ + T * w) * A);
  else {
    const A = T * Math.sqrt(E * E - 1);
    C = (N) => {
      const z = Math.exp(-E * T * N), I = Math.min(A * N, 300);
      return o - z * ((_ + E * T * w) * Math.sinh(I) + A * w * Math.cosh(I)) / A;
    };
  }
  return {
    calculatedDuration: y && m || null,
    next: (A) => {
      const N = C(A);
      if (y)
        l.done = A >= m;
      else {
        let z = _;
        A !== 0 && (E < 1 ? z = a2(C, A, N) : z = 0);
        const I = Math.abs(z) <= t, V = Math.abs(o - N) <= e;
        l.done = I && V;
      }
      return l.value = l.done ? o : N, l;
    }
  };
}
function WR({ keyframes: i, velocity: e = 0, power: t = 0.8, timeConstant: n = 325, bounceDamping: r = 10, bounceStiffness: o = 500, modifyTarget: l, min: u, max: d, restDelta: h = 0.5, restSpeed: m }) {
  const g = i[0], y = {
    done: !1,
    value: g
  }, _ = (W) => u !== void 0 && W < u || d !== void 0 && W > d, E = (W) => u === void 0 ? d : d === void 0 || Math.abs(u - W) < Math.abs(d - W) ? u : d;
  let w = t * e;
  const T = g + w, M = l === void 0 ? T : l(T);
  M !== T && (w = M - g);
  const C = (W) => -w * Math.exp(-W / n), A = (W) => M + C(W), N = (W) => {
    const U = C(W), O = A(W);
    y.done = Math.abs(U) <= h, y.value = y.done ? M : O;
  };
  let z, I;
  const V = (W) => {
    _(y.value) && (z = W, I = o2({
      keyframes: [y.value, E(y.value)],
      velocity: a2(A, W, y.value),
      damping: r,
      stiffness: o,
      restDelta: h,
      restSpeed: m
    }));
  };
  return V(0), {
    calculatedDuration: null,
    next: (W) => {
      let U = !1;
      return !I && z === void 0 && (U = !0, N(W), V(W)), z !== void 0 && W > z ? I.next(W - z) : (!U && N(W), y);
    }
  };
}
const J5 = (i) => {
  const e = ({ timestamp: t }) => i(t);
  return {
    start: () => qn.update(e, !0),
    stop: () => ll(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Gr.isProcessing ? Gr.timestamp : performance.now()
  };
}, XR = 2e4;
function jR(i) {
  let e = 0;
  const t = 50;
  let n = i.next(e);
  for (; !n.done && e < XR; )
    e += t, n = i.next(e);
  return e >= XR ? 1 / 0 : e;
}
const Q5 = {
  decay: WR,
  inertia: WR,
  tween: r0,
  keyframes: r0,
  spring: o2
};
function s0({ autoplay: i = !0, delay: e = 0, driver: t = J5, keyframes: n, type: r = "keyframes", repeat: o = 0, repeatDelay: l = 0, repeatType: u = "loop", onPlay: d, onStop: h, onComplete: m, onUpdate: g, ...y }) {
  let _ = 1, E = !1, w, T;
  const M = () => {
    T = new Promise((ue) => {
      w = ue;
    });
  };
  M();
  let C;
  const A = Q5[r] || r0;
  let N;
  A !== r0 && typeof n[0] != "number" && (process.env.NODE_ENV !== "production" && ma(n.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${n}`), N = r2([0, 100], n, {
    clamp: !1
  }), n = [0, 100]);
  const z = A({ ...y, keyframes: n });
  let I;
  u === "mirror" && (I = A({
    ...y,
    keyframes: [...n].reverse(),
    velocity: -(y.velocity || 0)
  }));
  let V = "idle", W = null, U = null, O = null;
  z.calculatedDuration === null && o && (z.calculatedDuration = jR(z));
  const { calculatedDuration: q } = z;
  let le = 1 / 0, ye = 1 / 0;
  q !== null && (le = q + l, ye = le * (o + 1) - l);
  let K = 0;
  const oe = (ue) => {
    if (U === null)
      return;
    _ > 0 && (U = Math.min(U, ue)), _ < 0 && (U = Math.min(ue - ye / _, U)), W !== null ? K = W : K = Math.round(ue - U) * _;
    const Le = K - e * (_ >= 0 ? 1 : -1), pe = _ >= 0 ? Le < 0 : Le > ye;
    K = Math.max(Le, 0), V === "finished" && W === null && (K = ye);
    let Ae = K, qe = z;
    if (o) {
      const Ut = Math.min(K, ye) / le;
      let ot = Math.floor(Ut), pt = Ut % 1;
      !pt && Ut >= 1 && (pt = 1), pt === 1 && ot--, ot = Math.min(ot, o + 1), !!(ot % 2) && (u === "reverse" ? (pt = 1 - pt, l && (pt -= l / le)) : u === "mirror" && (qe = I)), Ae = xu(0, 1, pt) * le;
    }
    const je = pe ? { done: !1, value: n[0] } : qe.next(Ae);
    N && (je.value = N(je.value));
    let { done: $e } = je;
    !pe && q !== null && ($e = _ >= 0 ? K >= ye : K <= 0);
    const Rt = W === null && (V === "finished" || V === "running" && $e);
    return g && g(je.value), Rt && Q(), je;
  }, ie = () => {
    C && C.stop(), C = void 0;
  }, Ee = () => {
    V = "idle", ie(), w(), M(), U = O = null;
  }, Q = () => {
    V = "finished", m && m(), ie(), w();
  }, se = () => {
    if (E)
      return;
    C || (C = t(oe));
    const ue = C.now();
    d && d(), W !== null ? U = ue - W : (!U || V === "finished") && (U = ue), V === "finished" && M(), O = U, W = null, V = "running", C.start();
  };
  i && se();
  const re = {
    then(ue, Le) {
      return T.then(ue, Le);
    },
    get time() {
      return rl(K);
    },
    set time(ue) {
      ue = mu(ue), K = ue, W !== null || !C || _ === 0 ? W = ue : U = C.now() - ue / _;
    },
    get duration() {
      const ue = z.calculatedDuration === null ? jR(z) : z.calculatedDuration;
      return rl(ue);
    },
    get speed() {
      return _;
    },
    set speed(ue) {
      ue === _ || !C || (_ = ue, re.time = rl(K));
    },
    get state() {
      return V;
    },
    play: se,
    pause: () => {
      V = "paused", W = K;
    },
    stop: () => {
      E = !0, V !== "idle" && (V = "idle", h && h(), Ee());
    },
    cancel: () => {
      O !== null && oe(O), Ee();
    },
    complete: () => {
      V = "finished";
    },
    sample: (ue) => (U = 0, oe(ue))
  };
  return re;
}
function $5(i) {
  let e;
  return () => (e === void 0 && (e = i()), e);
}
const eW = $5(() => Object.hasOwnProperty.call(Element.prototype, "animate")), tW = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), Dy = 10, nW = 2e4, iW = (i, e) => e.type === "spring" || i === "backgroundColor" || !zD(e.ease);
function rW(i, e, { onUpdate: t, onComplete: n, ...r }) {
  if (!(eW() && tW.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0 && r.type !== "inertia"))
    return !1;
  let l = !1, u, d, h = !1;
  const m = () => {
    d = new Promise((A) => {
      u = A;
    });
  };
  m();
  let { keyframes: g, duration: y = 300, ease: _, times: E } = r;
  if (iW(e, r)) {
    const A = s0({
      ...r,
      repeat: 0,
      delay: 0
    });
    let N = { done: !1, value: g[0] };
    const z = [];
    let I = 0;
    for (; !N.done && I < nW; )
      N = A.sample(I), z.push(N.value), I += Dy;
    E = void 0, g = z, y = I - Dy, _ = "linear";
  }
  const w = m5(i.owner.current, e, g, {
    ...r,
    duration: y,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: _,
    times: E
  }), T = () => {
    h = !1, w.cancel();
  }, M = () => {
    h = !0, qn.update(T), u(), m();
  };
  return w.onfinish = () => {
    h || (i.set(v5(g, r)), n && n(), M());
  }, {
    then(A, N) {
      return d.then(A, N);
    },
    attachTimeline(A) {
      return w.timeline = A, w.onfinish = null, Ei;
    },
    get time() {
      return rl(w.currentTime || 0);
    },
    set time(A) {
      w.currentTime = mu(A);
    },
    get speed() {
      return w.playbackRate;
    },
    set speed(A) {
      w.playbackRate = A;
    },
    get duration() {
      return rl(y);
    },
    play: () => {
      l || (w.play(), ll(T));
    },
    pause: () => w.pause(),
    stop: () => {
      if (l = !0, w.playState === "idle")
        return;
      const { currentTime: A } = w;
      if (A) {
        const N = s0({
          ...r,
          autoplay: !1
        });
        i.setWithVelocity(N.sample(A - Dy).value, N.sample(A).value, Dy);
      }
      M();
    },
    complete: () => {
      h || w.finish();
    },
    cancel: M
  };
}
function sW({ keyframes: i, delay: e, onUpdate: t, onComplete: n }) {
  const r = () => (t && t(i[i.length - 1]), n && n(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: Ei,
    pause: Ei,
    stop: Ei,
    then: (o) => (o(), Promise.resolve()),
    cancel: Ei,
    complete: Ei
  });
  return e ? s0({
    keyframes: [0, 1],
    duration: 0,
    delay: e,
    onComplete: r
  }) : r();
}
const aW = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, oW = (i) => ({
  type: "spring",
  stiffness: 550,
  damping: i === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), lW = {
  type: "keyframes",
  duration: 0.8
}, uW = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, cW = (i, { keyframes: e }) => e.length > 2 ? lW : Yc.has(i) ? i.startsWith("scale") ? oW(e[1]) : aW : uW, mE = (i, e) => i === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(_u.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url(")), fW = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function dW(i) {
  const [e, t] = i.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return i;
  const [n] = t.match(H0) || [];
  if (!n)
    return i;
  const r = t.replace(n, "");
  let o = fW.has(e) ? 1 : 0;
  return n !== t && (o *= 100), e + "(" + o + r + ")";
}
const hW = /([a-z-]*)\(.*?\)/g, vE = {
  ..._u,
  getAnimatableNone: (i) => {
    const e = i.match(hW);
    return e ? e.map(dW).join(" ") : i;
  }
}, pW = {
  ...SD,
  // Color props
  color: ns,
  backgroundColor: ns,
  outlineColor: ns,
  fill: ns,
  stroke: ns,
  // Border props
  borderColor: ns,
  borderTopColor: ns,
  borderRightColor: ns,
  borderBottomColor: ns,
  borderLeftColor: ns,
  filter: vE,
  WebkitFilter: vE
}, Nb = (i) => pW[i];
function l2(i, e) {
  let t = Nb(i);
  return t !== vE && (t = _u), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0;
}
const u2 = (i) => /^0[^.\s]+$/.test(i);
function mW(i) {
  if (typeof i == "number")
    return i === 0;
  if (i !== null)
    return i === "none" || i === "0" || u2(i);
}
function vW(i, e, t, n) {
  const r = mE(e, t);
  let o;
  Array.isArray(t) ? o = [...t] : o = [null, t];
  const l = n.from !== void 0 ? n.from : i.get();
  let u;
  const d = [];
  for (let h = 0; h < o.length; h++)
    o[h] === null && (o[h] = h === 0 ? l : o[h - 1]), mW(o[h]) && d.push(h), typeof o[h] == "string" && o[h] !== "none" && o[h] !== "0" && (u = o[h]);
  if (r && d.length && u)
    for (let h = 0; h < d.length; h++) {
      const m = d[h];
      o[m] = l2(e, u);
    }
  return o;
}
function gW({ when: i, delay: e, delayChildren: t, staggerChildren: n, staggerDirection: r, repeat: o, repeatType: l, repeatDelay: u, from: d, elapsed: h, ...m }) {
  return !!Object.keys(m).length;
}
function Ub(i, e) {
  return i[e] || i.default || i;
}
const yW = {
  skipAnimations: !1
}, Ob = (i, e, t, n = {}) => (r) => {
  const o = Ub(n, i) || {}, l = o.delay || n.delay || 0;
  let { elapsed: u = 0 } = n;
  u = u - mu(l);
  const d = vW(e, i, t, o), h = d[0], m = d[d.length - 1], g = mE(i, h), y = mE(i, m);
  Xm(g === y, `You are trying to animate ${i} from "${h}" to "${m}". ${h} is not an animatable value - to enable this animation set ${h} to a value animatable to ${m} via the \`style\` property.`);
  let _ = {
    keyframes: d,
    velocity: e.getVelocity(),
    ease: "easeOut",
    ...o,
    delay: -u,
    onUpdate: (E) => {
      e.set(E), o.onUpdate && o.onUpdate(E);
    },
    onComplete: () => {
      r(), o.onComplete && o.onComplete();
    }
  };
  if (gW(o) || (_ = {
    ..._,
    ...cW(i, _)
  }), _.duration && (_.duration = mu(_.duration)), _.repeatDelay && (_.repeatDelay = mu(_.repeatDelay)), !g || !y || p5.current || o.type === !1 || yW.skipAnimations)
    return sW(_);
  if (
    /**
     * If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    !n.isHandoff && e.owner && e.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !e.owner.getProps().onUpdate
  ) {
    const E = rW(e, i, _);
    if (E)
      return E;
  }
  return s0(_);
};
function a0(i) {
  return !!(bs(i) && i.add);
}
const c2 = (i) => /^\-?\d*\.?\d+$/.test(i);
function Ib(i, e) {
  i.indexOf(e) === -1 && i.push(e);
}
function Fb(i, e) {
  const t = i.indexOf(e);
  t > -1 && i.splice(t, 1);
}
class zb {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return Ib(this.subscriptions, e), () => Fb(this.subscriptions, e);
  }
  notify(e, t, n) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1)
        this.subscriptions[0](e, t, n);
      else
        for (let o = 0; o < r; o++) {
          const l = this.subscriptions[o];
          l && l(e, t, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const YR = /* @__PURE__ */ new Set();
function Bb(i, e, t) {
  i || YR.has(e) || (console.warn(e), YR.add(e));
}
const xW = (i) => !isNaN(parseFloat(i));
class _W {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, t = {}) {
    this.version = "10.18.0", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (n, r = !0) => {
      this.prev = this.current, this.current = n;
      const { delta: o, timestamp: l } = Gr;
      this.lastUpdated !== l && (this.timeDelta = o, this.lastUpdated = l, qn.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), r && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => qn.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: n }) => {
      n !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = xW(this.current), this.owner = t.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && Bb(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new zb());
    const n = this.events[e].add(t);
    return e === "change" ? () => {
      n(), qn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, t) {
    this.passiveEffect = e, this.stopPassiveEffect = t;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, t = !0) {
    !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, n) {
    this.set(t), this.prev = e, this.timeDelta = n;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e) {
    this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      s2(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((t) => {
      this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function rh(i, e) {
  return new _W(i, e);
}
const f2 = (i) => (e) => e.test(i), SW = {
  test: (i) => i === "auto",
  parse: (i) => i
}, d2 = [qc, Kt, yo, ou, PG, CG, SW], Gp = (i) => d2.find(f2(i)), MW = [...d2, ns, _u], EW = (i) => MW.find(f2(i));
function bW(i, e, t) {
  i.hasValue(e) ? i.getValue(e).set(t) : i.addValue(e, rh(t));
}
function TW(i, e) {
  const t = G0(i, e);
  let { transitionEnd: n = {}, transition: r = {}, ...o } = t ? i.makeTargetAnimatable(t, !1) : {};
  o = { ...o, ...n };
  for (const l in o) {
    const u = WG(o[l]);
    bW(i, l, u);
  }
}
function wW(i, e, t) {
  var n, r;
  const o = Object.keys(e).filter((u) => !i.hasValue(u)), l = o.length;
  if (l)
    for (let u = 0; u < l; u++) {
      const d = o[u], h = e[d];
      let m = null;
      Array.isArray(h) && (m = h[0]), m === null && (m = (r = (n = t[d]) !== null && n !== void 0 ? n : i.readValue(d)) !== null && r !== void 0 ? r : e[d]), m != null && (typeof m == "string" && (c2(m) || u2(m)) ? m = parseFloat(m) : !EW(m) && _u.test(h) && (m = l2(d, h)), i.addValue(d, rh(m, { owner: i })), t[d] === void 0 && (t[d] = m), m !== null && i.setBaseTarget(d, m));
    }
}
function AW(i, e) {
  return e ? (e[i] || e.default || e).from : void 0;
}
function RW(i, e, t) {
  const n = {};
  for (const r in i) {
    const o = AW(r, e);
    if (o !== void 0)
      n[r] = o;
    else {
      const l = t.getValue(r);
      l && (n[r] = l.get());
    }
  }
  return n;
}
function CW({ protectedKeys: i, needsAnimating: e }, t) {
  const n = i.hasOwnProperty(t) && e[t] !== !0;
  return e[t] = !1, n;
}
function PW(i, e) {
  const t = i.get();
  if (Array.isArray(e)) {
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t)
        return !0;
  } else
    return t !== e;
}
function h2(i, e, { delay: t = 0, transitionOverride: n, type: r } = {}) {
  let { transition: o = i.getDefaultTransition(), transitionEnd: l, ...u } = i.makeTargetAnimatable(e);
  const d = i.getValue("willChange");
  n && (o = n);
  const h = [], m = r && i.animationState && i.animationState.getState()[r];
  for (const g in u) {
    const y = i.getValue(g), _ = u[g];
    if (!y || _ === void 0 || m && CW(m, g))
      continue;
    const E = {
      delay: t,
      elapsed: 0,
      ...Ub(o || {}, g)
    };
    if (window.HandoffAppearAnimations) {
      const M = i.getProps()[pD];
      if (M) {
        const C = window.HandoffAppearAnimations(M, g, y, qn);
        C !== null && (E.elapsed = C, E.isHandoff = !0);
      }
    }
    let w = !E.isHandoff && !PW(y, _);
    if (E.type === "spring" && (y.getVelocity() || E.velocity) && (w = !1), y.animation && (w = !1), w)
      continue;
    y.start(Ob(g, y, _, i.shouldReduceMotion && Yc.has(g) ? { type: !1 } : E));
    const T = y.animation;
    a0(d) && (d.add(g), T.then(() => d.remove(g))), h.push(T);
  }
  return l && Promise.all(h).then(() => {
    l && TW(i, l);
  }), h;
}
function gE(i, e, t = {}) {
  const n = G0(i, e, t.custom);
  let { transition: r = i.getDefaultTransition() || {} } = n || {};
  t.transitionOverride && (r = t.transitionOverride);
  const o = n ? () => Promise.all(h2(i, n, t)) : () => Promise.resolve(), l = i.variantChildren && i.variantChildren.size ? (d = 0) => {
    const { delayChildren: h = 0, staggerChildren: m, staggerDirection: g } = r;
    return LW(i, e, h + d, m, g, t);
  } : () => Promise.resolve(), { when: u } = r;
  if (u) {
    const [d, h] = u === "beforeChildren" ? [o, l] : [l, o];
    return d().then(() => h());
  } else
    return Promise.all([o(), l(t.delay)]);
}
function LW(i, e, t = 0, n = 0, r = 1, o) {
  const l = [], u = (i.variantChildren.size - 1) * n, d = r === 1 ? (h = 0) => h * n : (h = 0) => u - h * n;
  return Array.from(i.variantChildren).sort(DW).forEach((h, m) => {
    h.notify("AnimationStart", e), l.push(gE(h, e, {
      ...o,
      delay: t + d(m)
    }).then(() => h.notify("AnimationComplete", e)));
  }), Promise.all(l);
}
function DW(i, e) {
  return i.sortNodePosition(e);
}
function NW(i, e, t = {}) {
  i.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const r = e.map((o) => gE(i, o, t));
    n = Promise.all(r);
  } else if (typeof e == "string")
    n = gE(i, e, t);
  else {
    const r = typeof e == "function" ? G0(i, e, t.custom) : e;
    n = Promise.all(h2(i, r, t));
  }
  return n.then(() => i.notify("AnimationComplete", e));
}
const UW = [..._b].reverse(), OW = _b.length;
function IW(i) {
  return (e) => Promise.all(e.map(({ animation: t, options: n }) => NW(i, t, n)));
}
function FW(i) {
  let e = IW(i);
  const t = BW();
  let n = !0;
  const r = (d, h) => {
    const m = G0(i, h);
    if (m) {
      const { transition: g, transitionEnd: y, ..._ } = m;
      d = { ...d, ..._, ...y };
    }
    return d;
  };
  function o(d) {
    e = d(i);
  }
  function l(d, h) {
    const m = i.getProps(), g = i.getVariantContext(!0) || {}, y = [], _ = /* @__PURE__ */ new Set();
    let E = {}, w = 1 / 0;
    for (let M = 0; M < OW; M++) {
      const C = UW[M], A = t[C], N = m[C] !== void 0 ? m[C] : g[C], z = wm(N), I = C === h ? A.isActive : null;
      I === !1 && (w = M);
      let V = N === g[C] && N !== m[C] && z;
      if (V && n && i.manuallyAnimateOnMount && (V = !1), A.protectedKeys = { ...E }, // If it isn't active and hasn't *just* been set as inactive
      !A.isActive && I === null || // If we didn't and don't have any defined prop for this animation type
      !N && !A.prevProp || // Or if the prop doesn't define an animation
      B0(N) || typeof N == "boolean")
        continue;
      let U = zW(A.prevProp, N) || // If we're making this variant active, we want to always make it active
      C === h && A.isActive && !V && z || // If we removed a higher-priority variant (i is in reverse order)
      M > w && z, O = !1;
      const q = Array.isArray(N) ? N : [N];
      let le = q.reduce(r, {});
      I === !1 && (le = {});
      const { prevResolvedValues: ye = {} } = A, K = {
        ...ye,
        ...le
      }, oe = (ie) => {
        U = !0, _.has(ie) && (O = !0, _.delete(ie)), A.needsAnimating[ie] = !0;
      };
      for (const ie in K) {
        const Ee = le[ie], Q = ye[ie];
        if (E.hasOwnProperty(ie))
          continue;
        let se = !1;
        n0(Ee) && n0(Q) ? se = !ID(Ee, Q) : se = Ee !== Q, se ? Ee !== void 0 ? oe(ie) : _.add(ie) : Ee !== void 0 && _.has(ie) ? oe(ie) : A.protectedKeys[ie] = !0;
      }
      A.prevProp = N, A.prevResolvedValues = le, A.isActive && (E = { ...E, ...le }), n && i.blockInitialAnimation && (U = !1), U && (!V || O) && y.push(...q.map((ie) => ({
        animation: ie,
        options: { type: C, ...d }
      })));
    }
    if (_.size) {
      const M = {};
      _.forEach((C) => {
        const A = i.getBaseTarget(C);
        A !== void 0 && (M[C] = A);
      }), y.push({ animation: M });
    }
    let T = !!y.length;
    return n && (m.initial === !1 || m.initial === m.animate) && !i.manuallyAnimateOnMount && (T = !1), n = !1, T ? e(y) : Promise.resolve();
  }
  function u(d, h, m) {
    var g;
    if (t[d].isActive === h)
      return Promise.resolve();
    (g = i.variantChildren) === null || g === void 0 || g.forEach((_) => {
      var E;
      return (E = _.animationState) === null || E === void 0 ? void 0 : E.setActive(d, h);
    }), t[d].isActive = h;
    const y = l(m, d);
    for (const _ in t)
      t[_].protectedKeys = {};
    return y;
  }
  return {
    animateChanges: l,
    setActive: u,
    setAnimateFunction: o,
    getState: () => t
  };
}
function zW(i, e) {
  return typeof e == "string" ? e !== i : Array.isArray(e) ? !ID(e, i) : !1;
}
function xc(i = !1) {
  return {
    isActive: i,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function BW() {
  return {
    animate: xc(!0),
    whileInView: xc(),
    whileHover: xc(),
    whileTap: xc(),
    whileDrag: xc(),
    whileFocus: xc(),
    exit: xc()
  };
}
class VW extends Tu {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = FW(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), B0(e) && (this.unmount = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let HW = 0;
class kW extends Tu {
  constructor() {
    super(...arguments), this.id = HW++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: t, custom: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r)
      return;
    const o = this.node.animationState.setActive("exit", !e, { custom: n ?? this.node.getProps().custom });
    t && !e && o.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const GW = {
  animation: {
    Feature: VW
  },
  exit: {
    Feature: kW
  }
}, qR = (i, e) => Math.abs(i - e);
function WW(i, e) {
  const t = qR(i.x, e.x), n = qR(i.y, e.y);
  return Math.sqrt(t ** 2 + n ** 2);
}
class p2 {
  constructor(e, t, { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: o = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const g = cM(this.lastMoveEventInfo, this.history), y = this.startEvent !== null, _ = WW(g.offset, { x: 0, y: 0 }) >= 3;
      if (!y && !_)
        return;
      const { point: E } = g, { timestamp: w } = Gr;
      this.history.push({ ...E, timestamp: w });
      const { onStart: T, onMove: M } = this.handlers;
      y || (T && T(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), M && M(this.lastMoveEvent, g);
    }, this.handlePointerMove = (g, y) => {
      this.lastMoveEvent = g, this.lastMoveEventInfo = uM(y, this.transformPagePoint), qn.update(this.updatePoint, !0);
    }, this.handlePointerUp = (g, y) => {
      this.end();
      const { onEnd: _, onSessionEnd: E, resumeAnimation: w } = this.handlers;
      if (this.dragSnapToOrigin && w && w(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const T = cM(g.type === "pointercancel" ? this.lastMoveEventInfo : uM(y, this.transformPagePoint), this.history);
      this.startEvent && _ && _(g, T), E && E(g, T);
    }, !LD(e))
      return;
    this.dragSnapToOrigin = o, this.handlers = t, this.transformPagePoint = n, this.contextWindow = r || window;
    const l = k0(e), u = uM(l, this.transformPagePoint), { point: d } = u, { timestamp: h } = Gr;
    this.history = [{ ...d, timestamp: h }];
    const { onSessionStart: m } = t;
    m && m(e, cM(u, this.history)), this.removeListeners = pu(il(this.contextWindow, "pointermove", this.handlePointerMove), il(this.contextWindow, "pointerup", this.handlePointerUp), il(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), ll(this.updatePoint);
  }
}
function uM(i, e) {
  return e ? { point: e(i.point) } : i;
}
function ZR(i, e) {
  return { x: i.x - e.x, y: i.y - e.y };
}
function cM({ point: i }, e) {
  return {
    point: i,
    delta: ZR(i, m2(e)),
    offset: ZR(i, XW(e)),
    velocity: jW(e, 0.1)
  };
}
function XW(i) {
  return i[0];
}
function m2(i) {
  return i[i.length - 1];
}
function jW(i, e) {
  if (i.length < 2)
    return { x: 0, y: 0 };
  let t = i.length - 1, n = null;
  const r = m2(i);
  for (; t >= 0 && (n = i[t], !(r.timestamp - n.timestamp > mu(e))); )
    t--;
  if (!n)
    return { x: 0, y: 0 };
  const o = rl(r.timestamp - n.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const l = {
    x: (r.x - n.x) / o,
    y: (r.y - n.y) / o
  };
  return l.x === 1 / 0 && (l.x = 0), l.y === 1 / 0 && (l.y = 0), l;
}
function Gs(i) {
  return i.max - i.min;
}
function yE(i, e = 0, t = 0.01) {
  return Math.abs(i - e) <= t;
}
function KR(i, e, t, n = 0.5) {
  i.origin = n, i.originPoint = fi(e.min, e.max, i.origin), i.scale = Gs(t) / Gs(e), (yE(i.scale, 1, 1e-4) || isNaN(i.scale)) && (i.scale = 1), i.translate = fi(t.min, t.max, i.origin) - i.originPoint, (yE(i.translate) || isNaN(i.translate)) && (i.translate = 0);
}
function im(i, e, t, n) {
  KR(i.x, e.x, t.x, n ? n.originX : void 0), KR(i.y, e.y, t.y, n ? n.originY : void 0);
}
function JR(i, e, t) {
  i.min = t.min + e.min, i.max = i.min + Gs(e);
}
function YW(i, e, t) {
  JR(i.x, e.x, t.x), JR(i.y, e.y, t.y);
}
function QR(i, e, t) {
  i.min = e.min - t.min, i.max = i.min + Gs(e);
}
function rm(i, e, t) {
  QR(i.x, e.x, t.x), QR(i.y, e.y, t.y);
}
function qW(i, { min: e, max: t }, n) {
  return e !== void 0 && i < e ? i = n ? fi(e, i, n.min) : Math.max(i, e) : t !== void 0 && i > t && (i = n ? fi(t, i, n.max) : Math.min(i, t)), i;
}
function $R(i, e, t) {
  return {
    min: e !== void 0 ? i.min + e : void 0,
    max: t !== void 0 ? i.max + t - (i.max - i.min) : void 0
  };
}
function ZW(i, { top: e, left: t, bottom: n, right: r }) {
  return {
    x: $R(i.x, t, r),
    y: $R(i.y, e, n)
  };
}
function eC(i, e) {
  let t = e.min - i.min, n = e.max - i.max;
  return e.max - e.min < i.max - i.min && ([t, n] = [n, t]), { min: t, max: n };
}
function KW(i, e) {
  return {
    x: eC(i.x, e.x),
    y: eC(i.y, e.y)
  };
}
function JW(i, e) {
  let t = 0.5;
  const n = Gs(i), r = Gs(e);
  return r > n ? t = Rm(e.min, e.max - n, i.min) : n > r && (t = Rm(i.min, i.max - r, e.min)), xu(0, 1, t);
}
function QW(i, e) {
  const t = {};
  return e.min !== void 0 && (t.min = e.min - i.min), e.max !== void 0 && (t.max = e.max - i.min), t;
}
const xE = 0.35;
function $W(i = xE) {
  return i === !1 ? i = 0 : i === !0 && (i = xE), {
    x: tC(i, "left", "right"),
    y: tC(i, "top", "bottom")
  };
}
function tC(i, e, t) {
  return {
    min: nC(i, e),
    max: nC(i, t)
  };
}
function nC(i, e) {
  return typeof i == "number" ? i : i[e] || 0;
}
const iC = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Zd = () => ({
  x: iC(),
  y: iC()
}), rC = () => ({ min: 0, max: 0 }), ji = () => ({
  x: rC(),
  y: rC()
});
function pa(i) {
  return [i("x"), i("y")];
}
function v2({ top: i, left: e, right: t, bottom: n }) {
  return {
    x: { min: e, max: t },
    y: { min: i, max: n }
  };
}
function e8({ x: i, y: e }) {
  return { top: e.min, right: i.max, bottom: e.max, left: i.min };
}
function t8(i, e) {
  if (!e)
    return i;
  const t = e({ x: i.left, y: i.top }), n = e({ x: i.right, y: i.bottom });
  return {
    top: t.y,
    left: t.x,
    bottom: n.y,
    right: n.x
  };
}
function fM(i) {
  return i === void 0 || i === 1;
}
function _E({ scale: i, scaleX: e, scaleY: t }) {
  return !fM(i) || !fM(e) || !fM(t);
}
function bc(i) {
  return _E(i) || g2(i) || i.z || i.rotate || i.rotateX || i.rotateY;
}
function g2(i) {
  return sC(i.x) || sC(i.y);
}
function sC(i) {
  return i && i !== "0%";
}
function o0(i, e, t) {
  const n = i - t, r = e * n;
  return t + r;
}
function aC(i, e, t, n, r) {
  return r !== void 0 && (i = o0(i, r, n)), o0(i, t, n) + e;
}
function SE(i, e = 0, t = 1, n, r) {
  i.min = aC(i.min, e, t, n, r), i.max = aC(i.max, e, t, n, r);
}
function y2(i, { x: e, y: t }) {
  SE(i.x, e.translate, e.scale, e.originPoint), SE(i.y, t.translate, t.scale, t.originPoint);
}
function n8(i, e, t, n = !1) {
  const r = t.length;
  if (!r)
    return;
  e.x = e.y = 1;
  let o, l;
  for (let u = 0; u < r; u++) {
    o = t[u], l = o.projectionDelta;
    const d = o.instance;
    d && d.style && d.style.display === "contents" || (n && o.options.layoutScroll && o.scroll && o !== o.root && Kd(i, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), l && (e.x *= l.x.scale, e.y *= l.y.scale, y2(i, l)), n && bc(o.latestValues) && Kd(i, o.latestValues));
  }
  e.x = oC(e.x), e.y = oC(e.y);
}
function oC(i) {
  return Number.isInteger(i) || i > 1.0000000000001 || i < 0.999999999999 ? i : 1;
}
function lu(i, e) {
  i.min = i.min + e, i.max = i.max + e;
}
function lC(i, e, [t, n, r]) {
  const o = e[r] !== void 0 ? e[r] : 0.5, l = fi(i.min, i.max, o);
  SE(i, e[t], e[n], l, e.scale);
}
const i8 = ["x", "scaleX", "originX"], r8 = ["y", "scaleY", "originY"];
function Kd(i, e) {
  lC(i.x, e, i8), lC(i.y, e, r8);
}
function x2(i, e) {
  return v2(t8(i.getBoundingClientRect(), e));
}
function s8(i, e, t) {
  const n = x2(i, t), { scroll: r } = e;
  return r && (lu(n.x, r.offset.x), lu(n.y, r.offset.y)), n;
}
const _2 = ({ current: i }) => i ? i.ownerDocument.defaultView : null, a8 = /* @__PURE__ */ new WeakMap();
class o8 {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ji(), this.visualElement = e;
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1)
      return;
    const r = (m) => {
      const { dragSnapToOrigin: g } = this.getProps();
      g ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(k0(m, "page").point);
    }, o = (m, g) => {
      const { drag: y, dragPropagation: _, onDragStart: E } = this.getProps();
      if (y && !_ && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = ND(y), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), pa((T) => {
        let M = this.getAxisMotionValue(T).get() || 0;
        if (yo.test(M)) {
          const { projection: C } = this.visualElement;
          if (C && C.layout) {
            const A = C.layout.layoutBox[T];
            A && (M = Gs(A) * (parseFloat(M) / 100));
          }
        }
        this.originPoint[T] = M;
      }), E && qn.update(() => E(m, g), !1, !0);
      const { animationState: w } = this.visualElement;
      w && w.setActive("whileDrag", !0);
    }, l = (m, g) => {
      const { dragPropagation: y, dragDirectionLock: _, onDirectionLock: E, onDrag: w } = this.getProps();
      if (!y && !this.openGlobalLock)
        return;
      const { offset: T } = g;
      if (_ && this.currentDirection === null) {
        this.currentDirection = l8(T), this.currentDirection !== null && E && E(this.currentDirection);
        return;
      }
      this.updateAxis("x", g.point, T), this.updateAxis("y", g.point, T), this.visualElement.render(), w && w(m, g);
    }, u = (m, g) => this.stop(m, g), d = () => pa((m) => {
      var g;
      return this.getAnimationState(m) === "paused" && ((g = this.getAxisMotionValue(m).animation) === null || g === void 0 ? void 0 : g.play());
    }), { dragSnapToOrigin: h } = this.getProps();
    this.panSession = new p2(e, {
      onSessionStart: r,
      onStart: o,
      onMove: l,
      onSessionEnd: u,
      resumeAnimation: d
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: h,
      contextWindow: _2(this.visualElement)
    });
  }
  stop(e, t) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: r } = t;
    this.startAnimation(r);
    const { onDragEnd: o } = this.getProps();
    o && qn.update(() => o(e, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, n) {
    const { drag: r } = this.getProps();
    if (!n || !Ny(e, r, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(e);
    let l = this.originPoint[e] + n[e];
    this.constraints && this.constraints[e] && (l = qW(l, this.constraints[e], this.elastic[e])), o.set(l);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, o = this.constraints;
    t && Yd(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = ZW(r.layoutBox, t) : this.constraints = !1, this.elastic = $W(n), o !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && pa((l) => {
      this.getAxisMotionValue(l) && (this.constraints[l] = QW(r.layoutBox[l], this.constraints[l]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !Yd(e))
      return !1;
    const n = e.current;
    ma(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: r } = this.visualElement;
    if (!r || !r.layout)
      return !1;
    const o = s8(n, r.root, this.visualElement.getTransformPagePoint());
    let l = KW(r.layout.layoutBox, o);
    if (t) {
      const u = t(e8(l));
      this.hasMutatedConstraints = !!u, u && (l = v2(u));
    }
    return l;
  }
  startAnimation(e) {
    const { drag: t, dragMomentum: n, dragElastic: r, dragTransition: o, dragSnapToOrigin: l, onDragTransitionEnd: u } = this.getProps(), d = this.constraints || {}, h = pa((m) => {
      if (!Ny(m, t, this.currentDirection))
        return;
      let g = d && d[m] || {};
      l && (g = { min: 0, max: 0 });
      const y = r ? 200 : 1e6, _ = r ? 40 : 1e7, E = {
        type: "inertia",
        velocity: n ? e[m] : 0,
        bounceStiffness: y,
        bounceDamping: _,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...g
      };
      return this.startAxisValueAnimation(m, E);
    });
    return Promise.all(h).then(u);
  }
  startAxisValueAnimation(e, t) {
    const n = this.getAxisMotionValue(e);
    return n.start(Ob(e, n, 0, t));
  }
  stopAnimation() {
    pa((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    pa((e) => {
      var t;
      return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause();
    });
  }
  getAnimationState(e) {
    var t;
    return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(), n = this.visualElement.getProps(), r = n[t];
    return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    pa((t) => {
      const { drag: n } = this.getProps();
      if (!Ny(t, n, this.currentDirection))
        return;
      const { projection: r } = this.visualElement, o = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: l, max: u } = r.layout.layoutBox[t];
        o.set(e[t] - fi(l, u, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: t } = this.getProps(), { projection: n } = this.visualElement;
    if (!Yd(t) || !n || !this.constraints)
      return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    pa((l) => {
      const u = this.getAxisMotionValue(l);
      if (u) {
        const d = u.get();
        r[l] = JW({ min: d, max: d }, this.constraints[l]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), pa((l) => {
      if (!Ny(l, e, null))
        return;
      const u = this.getAxisMotionValue(l), { min: d, max: h } = this.constraints[l];
      u.set(fi(d, h, r[l]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    a8.set(this.visualElement, this);
    const e = this.visualElement.current, t = il(e, "pointerdown", (d) => {
      const { drag: h, dragListener: m = !0 } = this.getProps();
      h && m && this.start(d);
    }), n = () => {
      const { dragConstraints: d } = this.getProps();
      Yd(d) && (this.constraints = this.resolveRefConstraints());
    }, { projection: r } = this.visualElement, o = r.addEventListener("measure", n);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), n();
    const l = tl(window, "resize", () => this.scalePositionWithinConstraints()), u = r.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: h }) => {
      this.isDragging && h && (pa((m) => {
        const g = this.getAxisMotionValue(m);
        g && (this.originPoint[m] += d[m].translate, g.set(g.get() + d[m].translate));
      }), this.visualElement.render());
    });
    return () => {
      l(), t(), o(), u && u();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: o = !1, dragElastic: l = xE, dragMomentum: u = !0 } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: n,
      dragPropagation: r,
      dragConstraints: o,
      dragElastic: l,
      dragMomentum: u
    };
  }
}
function Ny(i, e, t) {
  return (e === !0 || e === i) && (t === null || t === i);
}
function l8(i, e = 10) {
  let t = null;
  return Math.abs(i.y) > e ? t = "y" : Math.abs(i.x) > e && (t = "x"), t;
}
class u8 extends Tu {
  constructor(e) {
    super(e), this.removeGroupControls = Ei, this.removeListeners = Ei, this.controls = new o8(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Ei;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const uC = (i) => (e, t) => {
  i && qn.update(() => i(e, t));
};
class c8 extends Tu {
  constructor() {
    super(...arguments), this.removePointerDownListener = Ei;
  }
  onPointerDown(e) {
    this.session = new p2(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: _2(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps();
    return {
      onSessionStart: uC(e),
      onStart: uC(t),
      onMove: n,
      onEnd: (o, l) => {
        delete this.session, r && qn.update(() => r(o, l));
      }
    };
  }
  mount() {
    this.removePointerDownListener = il(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function f8() {
  const i = rs(F0);
  if (i === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: t, register: n } = i, r = TE();
  return Hs(() => n(r), []), !e && t ? [!1, () => t && t(r)] : [!0];
}
const Xy = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function cC(i, e) {
  return e.max === e.min ? 0 : i / (e.max - e.min) * 100;
}
const Wp = {
  correct: (i, e) => {
    if (!e.target)
      return i;
    if (typeof i == "string")
      if (Kt.test(i))
        i = parseFloat(i);
      else
        return i;
    const t = cC(i, e.target.x), n = cC(i, e.target.y);
    return `${t}% ${n}%`;
  }
}, d8 = {
  correct: (i, { treeScale: e, projectionDelta: t }) => {
    const n = i, r = _u.parse(i);
    if (r.length > 5)
      return n;
    const o = _u.createTransformer(i), l = typeof r[0] != "number" ? 1 : 0, u = t.x.scale * e.x, d = t.y.scale * e.y;
    r[0 + l] /= u, r[1 + l] /= d;
    const h = fi(u, d, 0.5);
    return typeof r[2 + l] == "number" && (r[2 + l] /= h), typeof r[3 + l] == "number" && (r[3 + l] /= h), o(r);
  }
};
class h8 extends kc.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props, { projection: o } = e;
    MG(p8), o && (t.group && t.group.add(o), n && n.register && r && n.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      onExitComplete: () => this.safeToRemove()
    })), Xy.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: t, visualElement: n, drag: r, isPresent: o } = this.props, l = n.projection;
    return l && (l.isPresent = o, r || e.layoutDependency !== t || t === void 0 ? l.willUpdate() : this.safeToRemove(), e.isPresent !== o && (o ? l.promote() : l.relegate() || qn.postRender(() => {
      const u = l.getStack();
      (!u || !u.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), queueMicrotask(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props, { projection: r } = e;
    r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), n && n.deregister && n.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function S2(i) {
  const [e, t] = f8(), n = rs(Mb);
  return kc.createElement(h8, { ...i, layoutGroup: n, switchLayoutGroup: rs(vD), isPresent: e, safeToRemove: t });
}
const p8 = {
  borderRadius: {
    ...Wp,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Wp,
  borderTopRightRadius: Wp,
  borderBottomLeftRadius: Wp,
  borderBottomRightRadius: Wp,
  boxShadow: d8
}, M2 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], m8 = M2.length, fC = (i) => typeof i == "string" ? parseFloat(i) : i, dC = (i) => typeof i == "number" || Kt.test(i);
function v8(i, e, t, n, r, o) {
  r ? (i.opacity = fi(
    0,
    // TODO Reinstate this if only child
    t.opacity !== void 0 ? t.opacity : 1,
    g8(n)
  ), i.opacityExit = fi(e.opacity !== void 0 ? e.opacity : 1, 0, y8(n))) : o && (i.opacity = fi(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, n));
  for (let l = 0; l < m8; l++) {
    const u = `border${M2[l]}Radius`;
    let d = hC(e, u), h = hC(t, u);
    if (d === void 0 && h === void 0)
      continue;
    d || (d = 0), h || (h = 0), d === 0 || h === 0 || dC(d) === dC(h) ? (i[u] = Math.max(fi(fC(d), fC(h), n), 0), (yo.test(h) || yo.test(d)) && (i[u] += "%")) : i[u] = h;
  }
  (e.rotate || t.rotate) && (i.rotate = fi(e.rotate || 0, t.rotate || 0, n));
}
function hC(i, e) {
  return i[e] !== void 0 ? i[e] : i.borderRadius;
}
const g8 = E2(0, 0.5, XD), y8 = E2(0.5, 0.95, Ei);
function E2(i, e, t) {
  return (n) => n < i ? 0 : n > e ? 1 : t(Rm(i, e, n));
}
function pC(i, e) {
  i.min = e.min, i.max = e.max;
}
function ha(i, e) {
  pC(i.x, e.x), pC(i.y, e.y);
}
function mC(i, e, t, n, r) {
  return i -= e, i = o0(i, 1 / t, n), r !== void 0 && (i = o0(i, 1 / r, n)), i;
}
function x8(i, e = 0, t = 1, n = 0.5, r, o = i, l = i) {
  if (yo.test(e) && (e = parseFloat(e), e = fi(l.min, l.max, e / 100) - l.min), typeof e != "number")
    return;
  let u = fi(o.min, o.max, n);
  i === o && (u -= e), i.min = mC(i.min, e, t, u, r), i.max = mC(i.max, e, t, u, r);
}
function vC(i, e, [t, n, r], o, l) {
  x8(i, e[t], e[n], e[r], e.scale, o, l);
}
const _8 = ["x", "scaleX", "originX"], S8 = ["y", "scaleY", "originY"];
function gC(i, e, t, n) {
  vC(i.x, e, _8, t ? t.x : void 0, n ? n.x : void 0), vC(i.y, e, S8, t ? t.y : void 0, n ? n.y : void 0);
}
function yC(i) {
  return i.translate === 0 && i.scale === 1;
}
function b2(i) {
  return yC(i.x) && yC(i.y);
}
function M8(i, e) {
  return i.x.min === e.x.min && i.x.max === e.x.max && i.y.min === e.y.min && i.y.max === e.y.max;
}
function T2(i, e) {
  return Math.round(i.x.min) === Math.round(e.x.min) && Math.round(i.x.max) === Math.round(e.x.max) && Math.round(i.y.min) === Math.round(e.y.min) && Math.round(i.y.max) === Math.round(e.y.max);
}
function xC(i) {
  return Gs(i.x) / Gs(i.y);
}
class E8 {
  constructor() {
    this.members = [];
  }
  add(e) {
    Ib(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Fb(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0)
      return !1;
    let n;
    for (let r = t; r >= 0; r--) {
      const o = this.members[r];
      if (o.isPresent !== !1) {
        n = o;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, t) {
    const n = this.lead;
    if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
      n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: n } = e;
      t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function _C(i, e, t) {
  let n = "";
  const r = i.x.translate / e.x, o = i.y.translate / e.y;
  if ((r || o) && (n = `translate3d(${r}px, ${o}px, 0) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), t) {
    const { rotate: d, rotateX: h, rotateY: m } = t;
    d && (n += `rotate(${d}deg) `), h && (n += `rotateX(${h}deg) `), m && (n += `rotateY(${m}deg) `);
  }
  const l = i.x.scale * e.x, u = i.y.scale * e.y;
  return (l !== 1 || u !== 1) && (n += `scale(${l}, ${u})`), n || "none";
}
const b8 = (i, e) => i.depth - e.depth;
class T8 {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    Ib(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Fb(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(b8), this.isDirty = !1, this.children.forEach(e);
  }
}
function w8(i, e) {
  const t = performance.now(), n = ({ timestamp: r }) => {
    const o = r - t;
    o >= e && (ll(n), i(o - e));
  };
  return qn.read(n, !0), () => ll(n);
}
function A8(i) {
  window.MotionDebug && window.MotionDebug.record(i);
}
function R8(i) {
  return i instanceof SVGElement && i.tagName !== "svg";
}
function C8(i, e, t) {
  const n = bs(i) ? i : rh(i);
  return n.start(Ob("", n, e, t)), n.animation;
}
const SC = ["", "X", "Y", "Z"], P8 = { visibility: "hidden" }, MC = 1e3;
let L8 = 0;
const Tc = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function w2({ attachResizeListener: i, defaultParent: e, measureScroll: t, checkIsScrollRoot: n, resetTransform: r }) {
  return class {
    constructor(l = {}, u = e == null ? void 0 : e()) {
      this.id = L8++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Tc.totalNodes = Tc.resolvedTargetDeltas = Tc.recalculatedProjection = 0, this.nodes.forEach(U8), this.nodes.forEach(B8), this.nodes.forEach(V8), this.nodes.forEach(O8), A8(Tc);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = l, this.root = u ? u.root || u : this, this.path = u ? [...u.path, u] : [], this.parent = u, this.depth = u ? u.depth + 1 : 0;
      for (let d = 0; d < this.path.length; d++)
        this.path[d].shouldResetTransform = !0;
      this.root === this && (this.nodes = new T8());
    }
    addEventListener(l, u) {
      return this.eventHandlers.has(l) || this.eventHandlers.set(l, new zb()), this.eventHandlers.get(l).add(u);
    }
    notifyListeners(l, ...u) {
      const d = this.eventHandlers.get(l);
      d && d.notify(...u);
    }
    hasListeners(l) {
      return this.eventHandlers.has(l);
    }
    /**
     * Lifecycles
     */
    mount(l, u = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = R8(l), this.instance = l;
      const { layoutId: d, layout: h, visualElement: m } = this.options;
      if (m && !m.current && m.mount(l), this.root.nodes.add(this), this.parent && this.parent.children.add(this), u && (h || d) && (this.isLayoutDirty = !0), i) {
        let g;
        const y = () => this.root.updateBlockedByResize = !1;
        i(l, () => {
          this.root.updateBlockedByResize = !0, g && g(), g = w8(y, 250), Xy.hasAnimatedSinceResize && (Xy.hasAnimatedSinceResize = !1, this.nodes.forEach(bC));
        });
      }
      d && this.root.registerSharedNode(d, this), this.options.animate !== !1 && m && (d || h) && this.addEventListener("didUpdate", ({ delta: g, hasLayoutChanged: y, hasRelativeTargetChanged: _, layout: E }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const w = this.options.transition || m.getDefaultTransition() || X8, { onLayoutAnimationStart: T, onLayoutAnimationComplete: M } = m.getProps(), C = !this.targetLayout || !T2(this.targetLayout, E) || _, A = !y && _;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || A || y && (C || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(g, A);
          const N = {
            ...Ub(w, "layout"),
            onPlay: T,
            onComplete: M
          };
          (m.shouldReduceMotion || this.options.layoutRoot) && (N.delay = 0, N.type = !1), this.startAnimation(N);
        } else
          y || bC(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = E;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const l = this.getStack();
      l && l.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, ll(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(H8), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: l } = this.options;
      return l && l.getProps().transformTemplate;
    }
    willUpdate(l = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let m = 0; m < this.path.length; m++) {
        const g = this.path[m];
        g.shouldResetTransform = !0, g.updateScroll("snapshot"), g.options.layoutRoot && g.willUpdate(!1);
      }
      const { layoutId: u, layout: d } = this.options;
      if (u === void 0 && !d)
        return;
      const h = this.getTransformTemplate();
      this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0, this.updateSnapshot(), l && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(EC);
        return;
      }
      this.isUpdating || this.nodes.forEach(F8), this.isUpdating = !1, this.nodes.forEach(z8), this.nodes.forEach(D8), this.nodes.forEach(N8), this.clearAllSnapshots();
      const u = performance.now();
      Gr.delta = xu(0, 1e3 / 60, u - Gr.timestamp), Gr.timestamp = u, Gr.isProcessing = !0, tM.update.process(Gr), tM.preRender.process(Gr), tM.render.process(Gr), Gr.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(I8), this.sharedNodes.forEach(k8);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, qn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      qn.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let d = 0; d < this.path.length; d++)
          this.path[d].updateScroll();
      const l = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = ji(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: u } = this.options;
      u && u.notify("LayoutMeasure", this.layout.layoutBox, l ? l.layoutBox : void 0);
    }
    updateScroll(l = "measure") {
      let u = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === l && (u = !1), u && (this.scroll = {
        animationId: this.root.animationId,
        phase: l,
        isRoot: n(this.instance),
        offset: t(this.instance)
      });
    }
    resetTransform() {
      if (!r)
        return;
      const l = this.isLayoutDirty || this.shouldResetTransform, u = this.projectionDelta && !b2(this.projectionDelta), d = this.getTransformTemplate(), h = d ? d(this.latestValues, "") : void 0, m = h !== this.prevTransformTemplateValue;
      l && (u || bc(this.latestValues) || m) && (r(this.instance, h), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(l = !0) {
      const u = this.measurePageBox();
      let d = this.removeElementScroll(u);
      return l && (d = this.removeTransform(d)), j8(d), {
        animationId: this.root.animationId,
        measuredBox: u,
        layoutBox: d,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: l } = this.options;
      if (!l)
        return ji();
      const u = l.measureViewportBox(), { scroll: d } = this.root;
      return d && (lu(u.x, d.offset.x), lu(u.y, d.offset.y)), u;
    }
    removeElementScroll(l) {
      const u = ji();
      ha(u, l);
      for (let d = 0; d < this.path.length; d++) {
        const h = this.path[d], { scroll: m, options: g } = h;
        if (h !== this.root && m && g.layoutScroll) {
          if (m.isRoot) {
            ha(u, l);
            const { scroll: y } = this.root;
            y && (lu(u.x, -y.offset.x), lu(u.y, -y.offset.y));
          }
          lu(u.x, m.offset.x), lu(u.y, m.offset.y);
        }
      }
      return u;
    }
    applyTransform(l, u = !1) {
      const d = ji();
      ha(d, l);
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h];
        !u && m.options.layoutScroll && m.scroll && m !== m.root && Kd(d, {
          x: -m.scroll.offset.x,
          y: -m.scroll.offset.y
        }), bc(m.latestValues) && Kd(d, m.latestValues);
      }
      return bc(this.latestValues) && Kd(d, this.latestValues), d;
    }
    removeTransform(l) {
      const u = ji();
      ha(u, l);
      for (let d = 0; d < this.path.length; d++) {
        const h = this.path[d];
        if (!h.instance || !bc(h.latestValues))
          continue;
        _E(h.latestValues) && h.updateSnapshot();
        const m = ji(), g = h.measurePageBox();
        ha(m, g), gC(u, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, m);
      }
      return bc(this.latestValues) && gC(u, this.latestValues), u;
    }
    setTargetDelta(l) {
      this.targetDelta = l, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(l) {
      this.options = {
        ...this.options,
        ...l,
        crossfade: l.crossfade !== void 0 ? l.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Gr.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(l = !1) {
      var u;
      const d = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = d.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = d.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = d.isSharedProjectionDirty);
      const h = !!this.resumingFrom || this !== d;
      if (!(l || h && this.isSharedProjectionDirty || this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: g, layoutId: y } = this.options;
      if (!(!this.layout || !(g || y))) {
        if (this.resolvedRelativeTargetAt = Gr.timestamp, !this.targetDelta && !this.relativeTarget) {
          const _ = this.getClosestProjectingParent();
          _ && _.layout && this.animationProgress !== 1 ? (this.relativeParent = _, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ji(), this.relativeTargetOrigin = ji(), rm(this.relativeTargetOrigin, this.layout.layoutBox, _.layout.layoutBox), ha(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = ji(), this.targetWithTransforms = ji()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), YW(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : ha(this.target, this.layout.layoutBox), y2(this.target, this.targetDelta)) : ha(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const _ = this.getClosestProjectingParent();
            _ && !!_.resumingFrom == !!this.resumingFrom && !_.options.layoutScroll && _.target && this.animationProgress !== 1 ? (this.relativeParent = _, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ji(), this.relativeTargetOrigin = ji(), rm(this.relativeTargetOrigin, this.target, _.target), ha(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Tc.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || _E(this.parent.latestValues) || g2(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var l;
      const u = this.getLead(), d = !!this.resumingFrom || this !== u;
      let h = !0;
      if ((this.isProjectionDirty || !((l = this.parent) === null || l === void 0) && l.isProjectionDirty) && (h = !1), d && (this.isSharedProjectionDirty || this.isTransformDirty) && (h = !1), this.resolvedRelativeTargetAt === Gr.timestamp && (h = !1), h)
        return;
      const { layout: m, layoutId: g } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(m || g))
        return;
      ha(this.layoutCorrected, this.layout.layoutBox);
      const y = this.treeScale.x, _ = this.treeScale.y;
      n8(this.layoutCorrected, this.treeScale, this.path, d), u.layout && !u.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (u.target = u.layout.layoutBox);
      const { target: E } = u;
      if (!E) {
        this.projectionTransform && (this.projectionDelta = Zd(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = Zd(), this.projectionDeltaWithTransform = Zd());
      const w = this.projectionTransform;
      im(this.projectionDelta, this.layoutCorrected, E, this.latestValues), this.projectionTransform = _C(this.projectionDelta, this.treeScale), (this.projectionTransform !== w || this.treeScale.x !== y || this.treeScale.y !== _) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", E)), Tc.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(l = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), l) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(l, u = !1) {
      const d = this.snapshot, h = d ? d.latestValues : {}, m = { ...this.latestValues }, g = Zd();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !u;
      const y = ji(), _ = d ? d.source : void 0, E = this.layout ? this.layout.source : void 0, w = _ !== E, T = this.getStack(), M = !T || T.members.length <= 1, C = !!(w && !M && this.options.crossfade === !0 && !this.path.some(W8));
      this.animationProgress = 0;
      let A;
      this.mixTargetDelta = (N) => {
        const z = N / 1e3;
        TC(g.x, l.x, z), TC(g.y, l.y, z), this.setTargetDelta(g), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (rm(y, this.layout.layoutBox, this.relativeParent.layout.layoutBox), G8(this.relativeTarget, this.relativeTargetOrigin, y, z), A && M8(this.relativeTarget, A) && (this.isProjectionDirty = !1), A || (A = ji()), ha(A, this.relativeTarget)), w && (this.animationValues = m, v8(m, h, this.latestValues, z, C, M)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = z;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(l) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (ll(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = qn.update(() => {
        Xy.hasAnimatedSinceResize = !0, this.currentAnimation = C8(0, MC, {
          ...l,
          onUpdate: (u) => {
            this.mixTargetDelta(u), l.onUpdate && l.onUpdate(u);
          },
          onComplete: () => {
            l.onComplete && l.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const l = this.getStack();
      l && l.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(MC), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const l = this.getLead();
      let { targetWithTransforms: u, target: d, layout: h, latestValues: m } = l;
      if (!(!u || !d || !h)) {
        if (this !== l && this.layout && h && A2(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
          d = this.target || ji();
          const g = Gs(this.layout.layoutBox.x);
          d.x.min = l.target.x.min, d.x.max = d.x.min + g;
          const y = Gs(this.layout.layoutBox.y);
          d.y.min = l.target.y.min, d.y.max = d.y.min + y;
        }
        ha(u, d), Kd(u, m), im(this.projectionDeltaWithTransform, this.layoutCorrected, u, m);
      }
    }
    registerSharedNode(l, u) {
      this.sharedNodes.has(l) || this.sharedNodes.set(l, new E8()), this.sharedNodes.get(l).add(u);
      const h = u.options.initialPromotionConfig;
      u.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(u) : void 0
      });
    }
    isLead() {
      const l = this.getStack();
      return l ? l.lead === this : !0;
    }
    getLead() {
      var l;
      const { layoutId: u } = this.options;
      return u ? ((l = this.getStack()) === null || l === void 0 ? void 0 : l.lead) || this : this;
    }
    getPrevLead() {
      var l;
      const { layoutId: u } = this.options;
      return u ? (l = this.getStack()) === null || l === void 0 ? void 0 : l.prevLead : void 0;
    }
    getStack() {
      const { layoutId: l } = this.options;
      if (l)
        return this.root.sharedNodes.get(l);
    }
    promote({ needsReset: l, transition: u, preserveFollowOpacity: d } = {}) {
      const h = this.getStack();
      h && h.promote(this, d), l && (this.projectionDelta = void 0, this.needsReset = !0), u && this.setOptions({ transition: u });
    }
    relegate() {
      const l = this.getStack();
      return l ? l.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: l } = this.options;
      if (!l)
        return;
      let u = !1;
      const { latestValues: d } = l;
      if ((d.rotate || d.rotateX || d.rotateY || d.rotateZ) && (u = !0), !u)
        return;
      const h = {};
      for (let m = 0; m < SC.length; m++) {
        const g = "rotate" + SC[m];
        d[g] && (h[g] = d[g], l.setStaticValue(g, 0));
      }
      l.render();
      for (const m in h)
        l.setStaticValue(m, h[m]);
      l.scheduleRender();
    }
    getProjectionStyles(l) {
      var u, d;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return P8;
      const h = {
        visibility: ""
      }, m = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, h.opacity = "", h.pointerEvents = Wy(l == null ? void 0 : l.pointerEvents) || "", h.transform = m ? m(this.latestValues, "") : "none", h;
      const g = this.getLead();
      if (!this.projectionDelta || !this.layout || !g.target) {
        const w = {};
        return this.options.layoutId && (w.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, w.pointerEvents = Wy(l == null ? void 0 : l.pointerEvents) || ""), this.hasProjected && !bc(this.latestValues) && (w.transform = m ? m({}, "") : "none", this.hasProjected = !1), w;
      }
      const y = g.animationValues || g.latestValues;
      this.applyTransformsToTarget(), h.transform = _C(this.projectionDeltaWithTransform, this.treeScale, y), m && (h.transform = m(y, h.transform));
      const { x: _, y: E } = this.projectionDelta;
      h.transformOrigin = `${_.origin * 100}% ${E.origin * 100}% 0`, g.animationValues ? h.opacity = g === this ? (d = (u = y.opacity) !== null && u !== void 0 ? u : this.latestValues.opacity) !== null && d !== void 0 ? d : 1 : this.preserveOpacity ? this.latestValues.opacity : y.opacityExit : h.opacity = g === this ? y.opacity !== void 0 ? y.opacity : "" : y.opacityExit !== void 0 ? y.opacityExit : 0;
      for (const w in e0) {
        if (y[w] === void 0)
          continue;
        const { correct: T, applyTo: M } = e0[w], C = h.transform === "none" ? y[w] : T(y[w], g);
        if (M) {
          const A = M.length;
          for (let N = 0; N < A; N++)
            h[M[N]] = C;
        } else
          h[w] = C;
      }
      return this.options.layoutId && (h.pointerEvents = g === this ? Wy(l == null ? void 0 : l.pointerEvents) || "" : "none"), h;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((l) => {
        var u;
        return (u = l.currentAnimation) === null || u === void 0 ? void 0 : u.stop();
      }), this.root.nodes.forEach(EC), this.root.sharedNodes.clear();
    }
  };
}
function D8(i) {
  i.updateLayout();
}
function N8(i) {
  var e;
  const t = ((e = i.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || i.snapshot;
  if (i.isLead() && i.layout && t && i.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: r } = i.layout, { animationType: o } = i.options, l = t.source !== i.layout.source;
    o === "size" ? pa((g) => {
      const y = l ? t.measuredBox[g] : t.layoutBox[g], _ = Gs(y);
      y.min = n[g].min, y.max = y.min + _;
    }) : A2(o, t.layoutBox, n) && pa((g) => {
      const y = l ? t.measuredBox[g] : t.layoutBox[g], _ = Gs(n[g]);
      y.max = y.min + _, i.relativeTarget && !i.currentAnimation && (i.isProjectionDirty = !0, i.relativeTarget[g].max = i.relativeTarget[g].min + _);
    });
    const u = Zd();
    im(u, n, t.layoutBox);
    const d = Zd();
    l ? im(d, i.applyTransform(r, !0), t.measuredBox) : im(d, n, t.layoutBox);
    const h = !b2(u);
    let m = !1;
    if (!i.resumeFrom) {
      const g = i.getClosestProjectingParent();
      if (g && !g.resumeFrom) {
        const { snapshot: y, layout: _ } = g;
        if (y && _) {
          const E = ji();
          rm(E, t.layoutBox, y.layoutBox);
          const w = ji();
          rm(w, n, _.layoutBox), T2(E, w) || (m = !0), g.options.layoutRoot && (i.relativeTarget = w, i.relativeTargetOrigin = E, i.relativeParent = g);
        }
      }
    }
    i.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: d,
      layoutDelta: u,
      hasLayoutChanged: h,
      hasRelativeTargetChanged: m
    });
  } else if (i.isLead()) {
    const { onExitComplete: n } = i.options;
    n && n();
  }
  i.options.transition = void 0;
}
function U8(i) {
  Tc.totalNodes++, i.parent && (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty), i.isSharedProjectionDirty || (i.isSharedProjectionDirty = !!(i.isProjectionDirty || i.parent.isProjectionDirty || i.parent.isSharedProjectionDirty)), i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty));
}
function O8(i) {
  i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1;
}
function I8(i) {
  i.clearSnapshot();
}
function EC(i) {
  i.clearMeasurements();
}
function F8(i) {
  i.isLayoutDirty = !1;
}
function z8(i) {
  const { visualElement: e } = i.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), i.resetTransform();
}
function bC(i) {
  i.finishAnimation(), i.targetDelta = i.relativeTarget = i.target = void 0, i.isProjectionDirty = !0;
}
function B8(i) {
  i.resolveTargetDelta();
}
function V8(i) {
  i.calcProjection();
}
function H8(i) {
  i.resetRotation();
}
function k8(i) {
  i.removeLeadSnapshot();
}
function TC(i, e, t) {
  i.translate = fi(e.translate, 0, t), i.scale = fi(e.scale, 1, t), i.origin = e.origin, i.originPoint = e.originPoint;
}
function wC(i, e, t, n) {
  i.min = fi(e.min, t.min, n), i.max = fi(e.max, t.max, n);
}
function G8(i, e, t, n) {
  wC(i.x, e.x, t.x, n), wC(i.y, e.y, t.y, n);
}
function W8(i) {
  return i.animationValues && i.animationValues.opacityExit !== void 0;
}
const X8 = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, AC = (i) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(i), RC = AC("applewebkit/") && !AC("chrome/") ? Math.round : Ei;
function CC(i) {
  i.min = RC(i.min), i.max = RC(i.max);
}
function j8(i) {
  CC(i.x), CC(i.y);
}
function A2(i, e, t) {
  return i === "position" || i === "preserve-aspect" && !yE(xC(e), xC(t), 0.2);
}
const Y8 = w2({
  attachResizeListener: (i, e) => tl(i, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), dM = {
  current: void 0
}, R2 = w2({
  measureScroll: (i) => ({
    x: i.scrollLeft,
    y: i.scrollTop
  }),
  defaultParent: () => {
    if (!dM.current) {
      const i = new Y8({});
      i.mount(window), i.setOptions({ layoutScroll: !0 }), dM.current = i;
    }
    return dM.current;
  },
  resetTransform: (i, e) => {
    i.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (i) => window.getComputedStyle(i).position === "fixed"
}), q8 = {
  pan: {
    Feature: c8
  },
  drag: {
    Feature: u8,
    ProjectionNode: R2,
    MeasureLayout: S2
  }
}, Z8 = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function K8(i) {
  const e = Z8.exec(i);
  if (!e)
    return [,];
  const [, t, n] = e;
  return [t, n];
}
const J8 = 4;
function ME(i, e, t = 1) {
  ma(t <= J8, `Max CSS variable fallback depth detected in property "${i}". This may indicate a circular fallback dependency.`);
  const [n, r] = K8(i);
  if (!n)
    return;
  const o = window.getComputedStyle(e).getPropertyValue(n);
  if (o) {
    const l = o.trim();
    return c2(l) ? parseFloat(l) : l;
  } else return fE(r) ? ME(r, e, t + 1) : r;
}
function Q8(i, { ...e }, t) {
  const n = i.current;
  if (!(n instanceof Element))
    return { target: e, transitionEnd: t };
  t && (t = { ...t }), i.values.forEach((r) => {
    const o = r.get();
    if (!fE(o))
      return;
    const l = ME(o, n);
    l && r.set(l);
  });
  for (const r in e) {
    const o = e[r];
    if (!fE(o))
      continue;
    const l = ME(o, n);
    l && (e[r] = l, t || (t = {}), t[r] === void 0 && (t[r] = o));
  }
  return { target: e, transitionEnd: t };
}
const $8 = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), C2 = (i) => $8.has(i), e6 = (i) => Object.keys(i).some(C2), Uy = (i) => i === qc || i === Kt, PC = (i, e) => parseFloat(i.split(", ")[e]), LC = (i, e) => (t, { transform: n }) => {
  if (n === "none" || !n)
    return 0;
  const r = n.match(/^matrix3d\((.+)\)$/);
  if (r)
    return PC(r[1], e);
  {
    const o = n.match(/^matrix\((.+)\)$/);
    return o ? PC(o[1], i) : 0;
  }
}, t6 = /* @__PURE__ */ new Set(["x", "y", "z"]), n6 = km.filter((i) => !t6.has(i));
function i6(i) {
  const e = [];
  return n6.forEach((t) => {
    const n = i.getValue(t);
    n !== void 0 && (e.push([t, n.get()]), n.set(t.startsWith("scale") ? 1 : 0));
  }), e.length && i.render(), e;
}
const sh = {
  // Dimensions
  width: ({ x: i }, { paddingLeft: e = "0", paddingRight: t = "0" }) => i.max - i.min - parseFloat(e) - parseFloat(t),
  height: ({ y: i }, { paddingTop: e = "0", paddingBottom: t = "0" }) => i.max - i.min - parseFloat(e) - parseFloat(t),
  top: (i, { top: e }) => parseFloat(e),
  left: (i, { left: e }) => parseFloat(e),
  bottom: ({ y: i }, { top: e }) => parseFloat(e) + (i.max - i.min),
  right: ({ x: i }, { left: e }) => parseFloat(e) + (i.max - i.min),
  // Transform
  x: LC(4, 13),
  y: LC(5, 14)
};
sh.translateX = sh.x;
sh.translateY = sh.y;
const r6 = (i, e, t) => {
  const n = e.measureViewportBox(), r = e.current, o = getComputedStyle(r), { display: l } = o, u = {};
  l === "none" && e.setStaticValue("display", i.display || "block"), t.forEach((h) => {
    u[h] = sh[h](n, o);
  }), e.render();
  const d = e.measureViewportBox();
  return t.forEach((h) => {
    const m = e.getValue(h);
    m && m.jump(u[h]), i[h] = sh[h](d, o);
  }), i;
}, s6 = (i, e, t = {}, n = {}) => {
  e = { ...e }, n = { ...n };
  const r = Object.keys(e).filter(C2);
  let o = [], l = !1;
  const u = [];
  if (r.forEach((d) => {
    const h = i.getValue(d);
    if (!i.hasValue(d))
      return;
    let m = t[d], g = Gp(m);
    const y = e[d];
    let _;
    if (n0(y)) {
      const E = y.length, w = y[0] === null ? 1 : 0;
      m = y[w], g = Gp(m);
      for (let T = w; T < E && y[T] !== null; T++)
        _ ? ma(Gp(y[T]) === _, "All keyframes must be of the same type") : (_ = Gp(y[T]), ma(_ === g || Uy(g) && Uy(_), "Keyframes must be of the same dimension as the current value"));
    } else
      _ = Gp(y);
    if (g !== _)
      if (Uy(g) && Uy(_)) {
        const E = h.get();
        typeof E == "string" && h.set(parseFloat(E)), typeof y == "string" ? e[d] = parseFloat(y) : Array.isArray(y) && _ === Kt && (e[d] = y.map(parseFloat));
      } else g != null && g.transform && (_ != null && _.transform) && (m === 0 || y === 0) ? m === 0 ? h.set(_.transform(m)) : e[d] = g.transform(y) : (l || (o = i6(i), l = !0), u.push(d), n[d] = n[d] !== void 0 ? n[d] : e[d], h.jump(y));
  }), u.length) {
    const d = u.indexOf("height") >= 0 ? window.pageYOffset : null, h = r6(e, i, u);
    return o.length && o.forEach(([m, g]) => {
      i.getValue(m).set(g);
    }), i.render(), z0 && d !== null && window.scrollTo({ top: d }), { target: h, transitionEnd: n };
  } else
    return { target: e, transitionEnd: n };
};
function a6(i, e, t, n) {
  return e6(e) ? s6(i, e, t, n) : { target: e, transitionEnd: n };
}
const o6 = (i, e, t, n) => {
  const r = Q8(i, e, n);
  return e = r.target, n = r.transitionEnd, a6(i, e, t, n);
}, EE = { current: null }, P2 = { current: !1 };
function l6() {
  if (P2.current = !0, !!z0)
    if (window.matchMedia) {
      const i = window.matchMedia("(prefers-reduced-motion)"), e = () => EE.current = i.matches;
      i.addListener(e), e();
    } else
      EE.current = !1;
}
function u6(i, e, t) {
  const { willChange: n } = e;
  for (const r in e) {
    const o = e[r], l = t[r];
    if (bs(o))
      i.addValue(r, o), a0(n) && n.add(r), process.env.NODE_ENV === "development" && Bb(o.version === "10.18.0", `Attempting to mix Framer Motion versions ${o.version} with 10.18.0 may not work as expected.`);
    else if (bs(l))
      i.addValue(r, rh(o, { owner: i })), a0(n) && n.remove(r);
    else if (l !== o)
      if (i.hasValue(r)) {
        const u = i.getValue(r);
        !u.hasAnimated && u.set(o);
      } else {
        const u = i.getStaticValue(r);
        i.addValue(r, rh(u !== void 0 ? u : o, { owner: i }));
      }
  }
  for (const r in t)
    e[r] === void 0 && i.removeValue(r);
  return e;
}
const DC = /* @__PURE__ */ new WeakMap(), L2 = Object.keys(Am), c6 = L2.length, NC = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], f6 = Sb.length;
class d6 {
  constructor({ parent: e, props: t, presenceContext: n, reducedMotionConfig: r, visualState: o }, l = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => qn.render(this.render, !1, !0);
    const { latestValues: u, renderState: d } = o;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = t.initial ? { ...u } : {}, this.renderState = d, this.parent = e, this.props = t, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = l, this.isControllingVariants = V0(t), this.isVariantNode = mD(t), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(t, {});
    for (const g in m) {
      const y = m[g];
      u[g] !== void 0 && bs(y) && (y.set(u[g], !1), a0(h) && h.add(g));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    this.current = e, DC.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, n) => this.bindToMotionValue(n, t)), P2.current || l6(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : EE.current, process.env.NODE_ENV !== "production" && Bb(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    DC.delete(this.current), this.projection && this.projection.unmount(), ll(this.notifyUpdate), ll(this.render), this.valueSubscriptions.forEach((e) => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features)
      this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const n = Yc.has(e), r = t.on("change", (l) => {
      this.latestValues[e] = l, this.props.onUpdate && qn.update(this.notifyUpdate, !1, !0), n && this.projection && (this.projection.isTransformDirty = !0);
    }), o = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      r(), o();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...t }, n, r, o) {
    let l, u;
    if (process.env.NODE_ENV !== "production" && r && n) {
      const d = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      t.ignoreStrict ? Xm(!1, d) : ma(!1, d);
    }
    for (let d = 0; d < c6; d++) {
      const h = L2[d], { isEnabled: m, Feature: g, ProjectionNode: y, MeasureLayout: _ } = Am[h];
      y && (l = y), m(t) && (!this.features[h] && g && (this.features[h] = new g(this)), _ && (u = _));
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && l) {
      this.projection = new l(this.latestValues, this.parent && this.parent.projection);
      const { layoutId: d, layout: h, drag: m, dragConstraints: g, layoutScroll: y, layoutRoot: _ } = t;
      this.projection.setOptions({
        layoutId: d,
        layout: h,
        alwaysMeasureLayout: !!m || g && Yd(g),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof h == "string" ? h : "both",
        initialPromotionConfig: o,
        layoutScroll: y,
        layoutRoot: _
      });
    }
    return u;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted ? t.update() : (t.mount(), t.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ji();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(e, t = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, t);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t;
    for (let n = 0; n < NC.length; n++) {
      const r = NC[n];
      this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]);
      const o = e["on" + r];
      o && (this.propEventSubscriptions[r] = this.on(r, o));
    }
    this.prevMotionValues = u6(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(e = !1) {
    if (e)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const n = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (n.initial = this.props.initial), n;
    }
    const t = {};
    for (let n = 0; n < f6; n++) {
      const r = Sb[n], o = this.props[r];
      (wm(o) || o === !1) && (t[r] = o);
    }
    return t;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, t) {
    t !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, t)), this.values.set(e, t), this.latestValues[e] = t.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let n = this.values.get(e);
    return n === void 0 && t !== void 0 && (n = rh(t, { owner: this }), this.addValue(e, n)), n;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e) {
    var t;
    return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (t = this.getBaseTargetFromProps(this.props, e)) !== null && t !== void 0 ? t : this.readValueFromInstance(this.current, e, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var t;
    const { initial: n } = this.props, r = typeof n == "string" || typeof n == "object" ? (t = Cb(this.props, n)) === null || t === void 0 ? void 0 : t[e] : void 0;
    if (n && r !== void 0)
      return r;
    const o = this.getBaseTargetFromProps(this.props, e);
    return o !== void 0 && !bs(o) ? o : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new zb()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class D2 extends d6 {
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: n }) {
    delete t[e], delete n[e];
  }
  makeTargetAnimatableFromInstance({ transition: e, transitionEnd: t, ...n }, { transformValues: r }, o) {
    let l = RW(n, e || {}, this);
    if (r && (t && (t = r(t)), n && (n = r(n)), l && (l = r(l))), o) {
      wW(this, n, l);
      const u = o6(this, n, l, t);
      t = u.transitionEnd, n = u.target;
    }
    return {
      transition: e,
      transitionEnd: t,
      ...n
    };
  }
}
function h6(i) {
  return window.getComputedStyle(i);
}
class p6 extends D2 {
  constructor() {
    super(...arguments), this.type = "html";
  }
  readValueFromInstance(e, t) {
    if (Yc.has(t)) {
      const n = Nb(t);
      return n && n.default || 0;
    } else {
      const n = h6(e), r = (xD(t) ? n.getPropertyValue(t) : n[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return x2(e, t);
  }
  build(e, t, n, r) {
    bb(e, t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return Rb(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    bs(e) && (this.childSubscription = e.on("change", (t) => {
      this.current && (this.current.textContent = `${t}`);
    }));
  }
  renderInstance(e, t, n, r) {
    TD(e, t, n, r);
  }
}
class m6 extends D2 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1;
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (Yc.has(t)) {
      const n = Nb(t);
      return n && n.default || 0;
    }
    return t = wD.has(t) ? t : xb(t), e.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return ji();
  }
  scrapeMotionValuesFromProps(e, t) {
    return RD(e, t);
  }
  build(e, t, n, r) {
    wb(e, t, n, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, t, n, r) {
    AD(e, t, n, r);
  }
  mount(e) {
    this.isSVGTag = Ab(e.tagName), super.mount(e);
  }
}
const v6 = (i, e) => Eb(i) ? new m6(e, { enableHardwareAcceleration: !1 }) : new p6(e, { enableHardwareAcceleration: !0 }), g6 = {
  layout: {
    ProjectionNode: R2,
    MeasureLayout: S2
  }
}, y6 = {
  ...GW,
  ...f5,
  ...q8,
  ...g6
}, x6 = /* @__PURE__ */ _G((i, e) => QG(i, e, y6, v6));
function N2() {
  const i = fr(!1);
  return yb(() => (i.current = !0, () => {
    i.current = !1;
  }), []), i;
}
function _6() {
  const i = N2(), [e, t] = qp(0), n = pM(() => {
    i.current && t(e + 1);
  }, [e]);
  return [pM(() => qn.postRender(n), [n]), e];
}
class S6 extends Lt.Component {
  getSnapshotBeforeUpdate(e) {
    const t = this.props.childRef.current;
    if (t && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      n.height = t.offsetHeight || 0, n.width = t.offsetWidth || 0, n.top = t.offsetTop, n.left = t.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function M6({ children: i, isPresent: e }) {
  const t = TE(), n = fr(null), r = fr({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return FC(() => {
    const { width: o, height: l, top: u, left: d } = r.current;
    if (e || !n.current || !o || !l)
      return;
    n.current.dataset.motionPopId = t;
    const h = document.createElement("style");
    return document.head.appendChild(h), h.sheet && h.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${l}px !important;
            top: ${u}px !important;
            left: ${d}px !important;
          }
        `), () => {
      document.head.removeChild(h);
    };
  }, [e]), Lt.createElement(S6, { isPresent: e, childRef: n, sizeRef: r }, Lt.cloneElement(i, { ref: n }));
}
const hM = ({ children: i, initial: e, isPresent: t, onExitComplete: n, custom: r, presenceAffectsLayout: o, mode: l }) => {
  const u = CD(E6), d = TE(), h = zc(
    () => ({
      id: d,
      initial: e,
      isPresent: t,
      custom: r,
      onExitComplete: (m) => {
        u.set(m, !0);
        for (const g of u.values())
          if (!g)
            return;
        n && n();
      },
      register: (m) => (u.set(m, !1), () => u.delete(m))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    o ? void 0 : [t]
  );
  return zc(() => {
    u.forEach((m, g) => u.set(g, !1));
  }, [t]), Lt.useEffect(() => {
    !t && !u.size && n && n();
  }, [t]), l === "popLayout" && (i = Lt.createElement(M6, { isPresent: t }, i)), Lt.createElement(F0.Provider, { value: h }, i);
};
function E6() {
  return /* @__PURE__ */ new Map();
}
function b6(i) {
  return Hs(() => () => i(), []);
}
const wc = (i) => i.key || "";
function T6(i, e) {
  i.forEach((t) => {
    const n = wc(t);
    e.set(n, t);
  });
}
function w6(i) {
  const e = [];
  return xO.forEach(i, (t) => {
    _O(t) && e.push(t);
  }), e;
}
const A6 = ({ children: i, custom: e, initial: t = !0, onExitComplete: n, exitBeforeEnter: r, presenceAffectsLayout: o = !0, mode: l = "sync" }) => {
  ma(!r, "Replace exitBeforeEnter with mode='wait'");
  const u = rs(Mb).forceRender || _6()[0], d = N2(), h = w6(i);
  let m = h;
  const g = fr(/* @__PURE__ */ new Map()).current, y = fr(m), _ = fr(/* @__PURE__ */ new Map()).current, E = fr(!0);
  if (yb(() => {
    E.current = !1, T6(h, _), y.current = m;
  }), b6(() => {
    E.current = !0, _.clear(), g.clear();
  }), E.current)
    return Lt.createElement(Lt.Fragment, null, m.map((C) => Lt.createElement(hM, { key: wc(C), isPresent: !0, initial: t ? void 0 : !1, presenceAffectsLayout: o, mode: l }, C)));
  m = [...m];
  const w = y.current.map(wc), T = h.map(wc), M = w.length;
  for (let C = 0; C < M; C++) {
    const A = w[C];
    T.indexOf(A) === -1 && !g.has(A) && g.set(A, void 0);
  }
  return l === "wait" && g.size && (m = []), g.forEach((C, A) => {
    if (T.indexOf(A) !== -1)
      return;
    const N = _.get(A);
    if (!N)
      return;
    const z = w.indexOf(A);
    let I = C;
    if (!I) {
      const V = () => {
        g.delete(A);
        const W = Array.from(_.keys()).filter((U) => !T.includes(U));
        if (W.forEach((U) => _.delete(U)), y.current = h.filter((U) => {
          const O = wc(U);
          return (
            // filter out the node exiting
            O === A || // filter out the leftover children
            W.includes(O)
          );
        }), !g.size) {
          if (d.current === !1)
            return;
          u(), n && n();
        }
      };
      I = Lt.createElement(hM, { key: wc(N), isPresent: !1, onExitComplete: V, custom: e, presenceAffectsLayout: o, mode: l }, N), g.set(A, I);
    }
    m.splice(z, 0, I);
  }), m = m.map((C) => {
    const A = C.key;
    return g.has(A) ? C : Lt.createElement(hM, { key: wc(C), isPresent: !0, presenceAffectsLayout: o, mode: l }, C);
  }), process.env.NODE_ENV !== "production" && l === "wait" && m.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), Lt.createElement(Lt.Fragment, null, g.size ? m : m.map((C) => yO(C)));
};
function Cm() {
  return Cm = Object.assign ? Object.assign.bind() : function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (i[n] = t[n]);
    }
    return i;
  }, Cm.apply(null, arguments);
}
var R6 = Object.defineProperty, C6 = (i, e, t) => e in i ? R6(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, P6 = (i, e, t) => (C6(i, e + "", t), t);
class L6 {
  constructor() {
    P6(this, "_listeners");
  }
  /**
   * Adds a listener to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
      * Checks if listener is added to an event type.
      * @param type The type of event to listen to.
      * @param listener The function that gets called when the event is fired.
      */
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
      * Removes a listener from an event type.
      * @param type The type of the listener that gets removed.
      * @param listener The listener function that gets removed.
      */
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const o = r.indexOf(t);
      o !== -1 && r.splice(o, 1);
    }
  }
  /**
      * Fire an event type.
      * @param event The event that gets fired.
      */
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let o = 0, l = r.length; o < l; o++)
        r[o].call(this, e);
      e.target = null;
    }
  }
}
var D6 = Object.defineProperty, N6 = (i, e, t) => e in i ? D6(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Gt = (i, e, t) => (N6(i, typeof e != "symbol" ? e + "" : e, t), t);
const Oy = /* @__PURE__ */ new Gc(), UC = /* @__PURE__ */ new Jo(), U6 = Math.cos(70 * (Math.PI / 180)), OC = (i, e) => (i % e + e) % e;
let O6 = class extends L6 {
  constructor(e, t) {
    super(), Gt(this, "object"), Gt(this, "domElement"), Gt(this, "enabled", !0), Gt(this, "target", new j()), Gt(this, "minDistance", 0), Gt(this, "maxDistance", 1 / 0), Gt(this, "minZoom", 0), Gt(this, "maxZoom", 1 / 0), Gt(this, "minPolarAngle", 0), Gt(this, "maxPolarAngle", Math.PI), Gt(this, "minAzimuthAngle", -1 / 0), Gt(this, "maxAzimuthAngle", 1 / 0), Gt(this, "enableDamping", !1), Gt(this, "dampingFactor", 0.05), Gt(this, "enableZoom", !0), Gt(this, "zoomSpeed", 1), Gt(this, "enableRotate", !0), Gt(this, "rotateSpeed", 1), Gt(this, "enablePan", !0), Gt(this, "panSpeed", 1), Gt(this, "screenSpacePanning", !0), Gt(this, "keyPanSpeed", 7), Gt(this, "zoomToCursor", !1), Gt(this, "autoRotate", !1), Gt(this, "autoRotateSpeed", 2), Gt(this, "reverseOrbit", !1), Gt(this, "reverseHorizontalOrbit", !1), Gt(this, "reverseVerticalOrbit", !1), Gt(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), Gt(this, "mouseButtons", {
      LEFT: _c.ROTATE,
      MIDDLE: _c.DOLLY,
      RIGHT: _c.PAN
    }), Gt(this, "touches", { ONE: Sc.ROTATE, TWO: Sc.DOLLY_PAN }), Gt(this, "target0"), Gt(this, "position0"), Gt(this, "zoom0"), Gt(this, "_domElementKeyEvents", null), Gt(this, "getPolarAngle"), Gt(this, "getAzimuthalAngle"), Gt(this, "setPolarAngle"), Gt(this, "setAzimuthalAngle"), Gt(this, "getDistance"), Gt(this, "getZoomScale"), Gt(this, "listenToKeyEvents"), Gt(this, "stopListenToKeyEvents"), Gt(this, "saveState"), Gt(this, "reset"), Gt(this, "update"), Gt(this, "connect"), Gt(this, "dispose"), Gt(this, "dollyIn"), Gt(this, "dollyOut"), Gt(this, "getScale"), Gt(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => m.phi, this.getAzimuthalAngle = () => m.theta, this.setPolarAngle = (Y) => {
      let he = OC(Y, 2 * Math.PI), Ze = m.phi;
      Ze < 0 && (Ze += 2 * Math.PI), he < 0 && (he += 2 * Math.PI);
      let Ve = Math.abs(he - Ze);
      2 * Math.PI - Ve < Ve && (he < Ze ? he += 2 * Math.PI : Ze += 2 * Math.PI), g.phi = he - Ze, n.update();
    }, this.setAzimuthalAngle = (Y) => {
      let he = OC(Y, 2 * Math.PI), Ze = m.theta;
      Ze < 0 && (Ze += 2 * Math.PI), he < 0 && (he += 2 * Math.PI);
      let Ve = Math.abs(he - Ze);
      2 * Math.PI - Ve < Ve && (he < Ze ? he += 2 * Math.PI : Ze += 2 * Math.PI), g.theta = he - Ze, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (Y) => {
      Y.addEventListener("keydown", Dt), this._domElementKeyEvents = Y;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", Dt), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), d = u.NONE;
    }, this.update = (() => {
      const Y = new j(), he = new j(0, 1, 0), Ze = new Xr().setFromUnitVectors(e.up, he), Ve = Ze.clone().invert(), Te = new j(), ee = new Xr(), Ke = 2 * Math.PI;
      return function() {
        const zt = n.object.position;
        Ze.setFromUnitVectors(e.up, he), Ve.copy(Ze).invert(), Y.copy(zt).sub(n.target), Y.applyQuaternion(Ze), m.setFromVector3(Y), n.autoRotate && d === u.NONE && K(le()), n.enableDamping ? (m.theta += g.theta * n.dampingFactor, m.phi += g.phi * n.dampingFactor) : (m.theta += g.theta, m.phi += g.phi);
        let Ye = n.minAzimuthAngle, qt = n.maxAzimuthAngle;
        isFinite(Ye) && isFinite(qt) && (Ye < -Math.PI ? Ye += Ke : Ye > Math.PI && (Ye -= Ke), qt < -Math.PI ? qt += Ke : qt > Math.PI && (qt -= Ke), Ye <= qt ? m.theta = Math.max(Ye, Math.min(qt, m.theta)) : m.theta = m.theta > (Ye + qt) / 2 ? Math.max(Ye, m.theta) : Math.min(qt, m.theta)), m.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, m.phi)), m.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(_, n.dampingFactor) : n.target.add(_), n.zoomToCursor && U || n.object.isOrthographicCamera ? m.radius = pe(m.radius) : m.radius = pe(m.radius * y), Y.setFromSpherical(m), Y.applyQuaternion(Ve), zt.copy(n.target).add(Y), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (g.theta *= 1 - n.dampingFactor, g.phi *= 1 - n.dampingFactor, _.multiplyScalar(1 - n.dampingFactor)) : (g.set(0, 0, 0), _.set(0, 0, 0));
        let tn = !1;
        if (n.zoomToCursor && U) {
          let Sn = null;
          if (n.object instanceof Ii && n.object.isPerspectiveCamera) {
            const bn = Y.length();
            Sn = pe(bn * y);
            const Jt = bn - Sn;
            n.object.position.addScaledVector(V, Jt), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const bn = new j(W.x, W.y, 0);
            bn.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / y)), n.object.updateProjectionMatrix(), tn = !0;
            const Jt = new j(W.x, W.y, 0);
            Jt.unproject(n.object), n.object.position.sub(Jt).add(bn), n.object.updateMatrixWorld(), Sn = Y.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          Sn !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Sn).add(n.object.position) : (Oy.origin.copy(n.object.position), Oy.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Oy.direction)) < U6 ? e.lookAt(n.target) : (UC.setFromNormalAndCoplanarPoint(n.object.up, n.target), Oy.intersectPlane(UC, n.target))));
        } else n.object instanceof hu && n.object.isOrthographicCamera && (tn = y !== 1, tn && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / y)), n.object.updateProjectionMatrix()));
        return y = 1, U = !1, tn || Te.distanceToSquared(n.object.position) > h || 8 * (1 - ee.dot(n.object.quaternion)) > h ? (n.dispatchEvent(r), Te.copy(n.object.position), ee.copy(n.object.quaternion), tn = !1, !0) : !1;
      };
    })(), this.connect = (Y) => {
      n.domElement = Y, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", nt), n.domElement.addEventListener("pointerdown", Fe), n.domElement.addEventListener("pointercancel", Ie), n.domElement.addEventListener("wheel", mt);
    }, this.dispose = () => {
      var Y, he, Ze, Ve, Te, ee;
      n.domElement && (n.domElement.style.touchAction = "auto"), (Y = n.domElement) == null || Y.removeEventListener("contextmenu", nt), (he = n.domElement) == null || he.removeEventListener("pointerdown", Fe), (Ze = n.domElement) == null || Ze.removeEventListener("pointercancel", Ie), (Ve = n.domElement) == null || Ve.removeEventListener("wheel", mt), (Te = n.domElement) == null || Te.ownerDocument.removeEventListener("pointermove", ze), (ee = n.domElement) == null || ee.ownerDocument.removeEventListener("pointerup", Ie), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", Dt);
    };
    const n = this, r = { type: "change" }, o = { type: "start" }, l = { type: "end" }, u = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let d = u.NONE;
    const h = 1e-6, m = new sE(), g = new sE();
    let y = 1;
    const _ = new j(), E = new Oe(), w = new Oe(), T = new Oe(), M = new Oe(), C = new Oe(), A = new Oe(), N = new Oe(), z = new Oe(), I = new Oe(), V = new j(), W = new Oe();
    let U = !1;
    const O = [], q = {};
    function le() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function ye() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function K(Y) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? g.theta += Y : g.theta -= Y;
    }
    function oe(Y) {
      n.reverseOrbit || n.reverseVerticalOrbit ? g.phi += Y : g.phi -= Y;
    }
    const ie = (() => {
      const Y = new j();
      return function(Ze, Ve) {
        Y.setFromMatrixColumn(Ve, 0), Y.multiplyScalar(-Ze), _.add(Y);
      };
    })(), Ee = (() => {
      const Y = new j();
      return function(Ze, Ve) {
        n.screenSpacePanning === !0 ? Y.setFromMatrixColumn(Ve, 1) : (Y.setFromMatrixColumn(Ve, 0), Y.crossVectors(n.object.up, Y)), Y.multiplyScalar(Ze), _.add(Y);
      };
    })(), Q = (() => {
      const Y = new j();
      return function(Ze, Ve) {
        const Te = n.domElement;
        if (Te && n.object instanceof Ii && n.object.isPerspectiveCamera) {
          const ee = n.object.position;
          Y.copy(ee).sub(n.target);
          let Ke = Y.length();
          Ke *= Math.tan(n.object.fov / 2 * Math.PI / 180), ie(2 * Ze * Ke / Te.clientHeight, n.object.matrix), Ee(2 * Ve * Ke / Te.clientHeight, n.object.matrix);
        } else Te && n.object instanceof hu && n.object.isOrthographicCamera ? (ie(
          Ze * (n.object.right - n.object.left) / n.object.zoom / Te.clientWidth,
          n.object.matrix
        ), Ee(
          Ve * (n.object.top - n.object.bottom) / n.object.zoom / Te.clientHeight,
          n.object.matrix
        )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function se(Y) {
      n.object instanceof Ii && n.object.isPerspectiveCamera || n.object instanceof hu && n.object.isOrthographicCamera ? y = Y : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function re(Y) {
      se(y / Y);
    }
    function ue(Y) {
      se(y * Y);
    }
    function Le(Y) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      U = !0;
      const he = n.domElement.getBoundingClientRect(), Ze = Y.clientX - he.left, Ve = Y.clientY - he.top, Te = he.width, ee = he.height;
      W.x = Ze / Te * 2 - 1, W.y = -(Ve / ee) * 2 + 1, V.set(W.x, W.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function pe(Y) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, Y));
    }
    function Ae(Y) {
      E.set(Y.clientX, Y.clientY);
    }
    function qe(Y) {
      Le(Y), N.set(Y.clientX, Y.clientY);
    }
    function je(Y) {
      M.set(Y.clientX, Y.clientY);
    }
    function $e(Y) {
      w.set(Y.clientX, Y.clientY), T.subVectors(w, E).multiplyScalar(n.rotateSpeed);
      const he = n.domElement;
      he && (K(2 * Math.PI * T.x / he.clientHeight), oe(2 * Math.PI * T.y / he.clientHeight)), E.copy(w), n.update();
    }
    function Rt(Y) {
      z.set(Y.clientX, Y.clientY), I.subVectors(z, N), I.y > 0 ? re(ye()) : I.y < 0 && ue(ye()), N.copy(z), n.update();
    }
    function Ut(Y) {
      C.set(Y.clientX, Y.clientY), A.subVectors(C, M).multiplyScalar(n.panSpeed), Q(A.x, A.y), M.copy(C), n.update();
    }
    function ot(Y) {
      Le(Y), Y.deltaY < 0 ? ue(ye()) : Y.deltaY > 0 && re(ye()), n.update();
    }
    function pt(Y) {
      let he = !1;
      switch (Y.code) {
        case n.keys.UP:
          Q(0, n.keyPanSpeed), he = !0;
          break;
        case n.keys.BOTTOM:
          Q(0, -n.keyPanSpeed), he = !0;
          break;
        case n.keys.LEFT:
          Q(n.keyPanSpeed, 0), he = !0;
          break;
        case n.keys.RIGHT:
          Q(-n.keyPanSpeed, 0), he = !0;
          break;
      }
      he && (Y.preventDefault(), n.update());
    }
    function J() {
      if (O.length == 1)
        E.set(O[0].pageX, O[0].pageY);
      else {
        const Y = 0.5 * (O[0].pageX + O[1].pageX), he = 0.5 * (O[0].pageY + O[1].pageY);
        E.set(Y, he);
      }
    }
    function Be() {
      if (O.length == 1)
        M.set(O[0].pageX, O[0].pageY);
      else {
        const Y = 0.5 * (O[0].pageX + O[1].pageX), he = 0.5 * (O[0].pageY + O[1].pageY);
        M.set(Y, he);
      }
    }
    function Pe() {
      const Y = O[0].pageX - O[1].pageX, he = O[0].pageY - O[1].pageY, Ze = Math.sqrt(Y * Y + he * he);
      N.set(0, Ze);
    }
    function He() {
      n.enableZoom && Pe(), n.enablePan && Be();
    }
    function Re() {
      n.enableZoom && Pe(), n.enableRotate && J();
    }
    function _t(Y) {
      if (O.length == 1)
        w.set(Y.pageX, Y.pageY);
      else {
        const Ze = at(Y), Ve = 0.5 * (Y.pageX + Ze.x), Te = 0.5 * (Y.pageY + Ze.y);
        w.set(Ve, Te);
      }
      T.subVectors(w, E).multiplyScalar(n.rotateSpeed);
      const he = n.domElement;
      he && (K(2 * Math.PI * T.x / he.clientHeight), oe(2 * Math.PI * T.y / he.clientHeight)), E.copy(w);
    }
    function rt(Y) {
      if (O.length == 1)
        C.set(Y.pageX, Y.pageY);
      else {
        const he = at(Y), Ze = 0.5 * (Y.pageX + he.x), Ve = 0.5 * (Y.pageY + he.y);
        C.set(Ze, Ve);
      }
      A.subVectors(C, M).multiplyScalar(n.panSpeed), Q(A.x, A.y), M.copy(C);
    }
    function G(Y) {
      const he = at(Y), Ze = Y.pageX - he.x, Ve = Y.pageY - he.y, Te = Math.sqrt(Ze * Ze + Ve * Ve);
      z.set(0, Te), I.set(0, Math.pow(z.y / N.y, n.zoomSpeed)), re(I.y), N.copy(z);
    }
    function B(Y) {
      n.enableZoom && G(Y), n.enablePan && rt(Y);
    }
    function ce(Y) {
      n.enableZoom && G(Y), n.enableRotate && _t(Y);
    }
    function Fe(Y) {
      var he, Ze;
      n.enabled !== !1 && (O.length === 0 && ((he = n.domElement) == null || he.ownerDocument.addEventListener("pointermove", ze), (Ze = n.domElement) == null || Ze.ownerDocument.addEventListener("pointerup", Ie)), lt(Y), Y.pointerType === "touch" ? Ht(Y) : Mt(Y));
    }
    function ze(Y) {
      n.enabled !== !1 && (Y.pointerType === "touch" ? de(Y) : it(Y));
    }
    function Ie(Y) {
      var he, Ze, Ve;
      Xe(Y), O.length === 0 && ((he = n.domElement) == null || he.releasePointerCapture(Y.pointerId), (Ze = n.domElement) == null || Ze.ownerDocument.removeEventListener("pointermove", ze), (Ve = n.domElement) == null || Ve.ownerDocument.removeEventListener("pointerup", Ie)), n.dispatchEvent(l), d = u.NONE;
    }
    function Mt(Y) {
      let he;
      switch (Y.button) {
        case 0:
          he = n.mouseButtons.LEFT;
          break;
        case 1:
          he = n.mouseButtons.MIDDLE;
          break;
        case 2:
          he = n.mouseButtons.RIGHT;
          break;
        default:
          he = -1;
      }
      switch (he) {
        case _c.DOLLY:
          if (n.enableZoom === !1)
            return;
          qe(Y), d = u.DOLLY;
          break;
        case _c.ROTATE:
          if (Y.ctrlKey || Y.metaKey || Y.shiftKey) {
            if (n.enablePan === !1)
              return;
            je(Y), d = u.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            Ae(Y), d = u.ROTATE;
          }
          break;
        case _c.PAN:
          if (Y.ctrlKey || Y.metaKey || Y.shiftKey) {
            if (n.enableRotate === !1)
              return;
            Ae(Y), d = u.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            je(Y), d = u.PAN;
          }
          break;
        default:
          d = u.NONE;
      }
      d !== u.NONE && n.dispatchEvent(o);
    }
    function it(Y) {
      if (n.enabled !== !1)
        switch (d) {
          case u.ROTATE:
            if (n.enableRotate === !1)
              return;
            $e(Y);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1)
              return;
            Rt(Y);
            break;
          case u.PAN:
            if (n.enablePan === !1)
              return;
            Ut(Y);
            break;
        }
    }
    function mt(Y) {
      n.enabled === !1 || n.enableZoom === !1 || d !== u.NONE && d !== u.ROTATE || (Y.preventDefault(), n.dispatchEvent(o), ot(Y), n.dispatchEvent(l));
    }
    function Dt(Y) {
      n.enabled === !1 || n.enablePan === !1 || pt(Y);
    }
    function Ht(Y) {
      switch (dt(Y), O.length) {
        case 1:
          switch (n.touches.ONE) {
            case Sc.ROTATE:
              if (n.enableRotate === !1)
                return;
              J(), d = u.TOUCH_ROTATE;
              break;
            case Sc.PAN:
              if (n.enablePan === !1)
                return;
              Be(), d = u.TOUCH_PAN;
              break;
            default:
              d = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Sc.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              He(), d = u.TOUCH_DOLLY_PAN;
              break;
            case Sc.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              Re(), d = u.TOUCH_DOLLY_ROTATE;
              break;
            default:
              d = u.NONE;
          }
          break;
        default:
          d = u.NONE;
      }
      d !== u.NONE && n.dispatchEvent(o);
    }
    function de(Y) {
      switch (dt(Y), d) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          _t(Y), n.update();
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          rt(Y), n.update();
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          B(Y), n.update();
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          ce(Y), n.update();
          break;
        default:
          d = u.NONE;
      }
    }
    function nt(Y) {
      n.enabled !== !1 && Y.preventDefault();
    }
    function lt(Y) {
      O.push(Y);
    }
    function Xe(Y) {
      delete q[Y.pointerId];
      for (let he = 0; he < O.length; he++)
        if (O[he].pointerId == Y.pointerId) {
          O.splice(he, 1);
          return;
        }
    }
    function dt(Y) {
      let he = q[Y.pointerId];
      he === void 0 && (he = new Oe(), q[Y.pointerId] = he), he.set(Y.pageX, Y.pageY);
    }
    function at(Y) {
      const he = Y.pointerId === O[0].pointerId ? O[1] : O[0];
      return q[he.pointerId];
    }
    this.dollyIn = (Y = ye()) => {
      ue(Y), n.update();
    }, this.dollyOut = (Y = ye()) => {
      re(Y), n.update();
    }, this.getScale = () => y, this.setScale = (Y) => {
      se(Y), n.update();
    }, this.getZoomScale = () => ye(), t !== void 0 && this.connect(t), this.update();
  }
};
const I6 = /* @__PURE__ */ Lt.forwardRef(({
  makeDefault: i,
  camera: e,
  regress: t,
  domElement: n,
  enableDamping: r = !0,
  keyEvents: o = !1,
  onChange: l,
  onStart: u,
  onEnd: d,
  ...h
}, m) => {
  const g = au((I) => I.invalidate), y = au((I) => I.camera), _ = au((I) => I.gl), E = au((I) => I.events), w = au((I) => I.setEvents), T = au((I) => I.set), M = au((I) => I.get), C = au((I) => I.performance), A = e || y, N = n || E.connected || _.domElement, z = Lt.useMemo(() => new O6(A), [A]);
  return aD(() => {
    z.enabled && z.update();
  }, -1), Lt.useEffect(() => (o && z.connect(o === !0 ? N : o), z.connect(N), () => void z.dispose()), [o, N, t, z, g]), Lt.useEffect(() => {
    const I = (U) => {
      g(), t && C.regress(), l && l(U);
    }, V = (U) => {
      u && u(U);
    }, W = (U) => {
      d && d(U);
    };
    return z.addEventListener("change", I), z.addEventListener("start", V), z.addEventListener("end", W), () => {
      z.removeEventListener("start", V), z.removeEventListener("end", W), z.removeEventListener("change", I);
    };
  }, [l, u, d, z, g, w]), Lt.useEffect(() => {
    if (i) {
      const I = M().controls;
      return T({
        controls: z
      }), () => T({
        controls: I
      });
    }
  }, [i, z]), /* @__PURE__ */ Lt.createElement("primitive", Cm({
    ref: m,
    object: z,
    enableDamping: r
  }, h));
});
var F6 = `#define GLSLIFY 1
vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}`;
class z6 extends sb {
  constructor(e = {}) {
    super(e), this.setValues(e), this._time = {
      value: 0
    }, this._distort = {
      value: 0.4
    }, this._radius = {
      value: 1
    };
  }
  // FIXME Use `THREE.WebGLProgramParametersWithUniforms` type when able to target @types/three@0.160.0
  onBeforeCompile(e) {
    e.uniforms.time = this._time, e.uniforms.radius = this._radius, e.uniforms.distort = this._distort, e.vertexShader = `
      uniform float time;
      uniform float radius;
      uniform float distort;
      ${F6}
      ${e.vertexShader}
    `, e.vertexShader = e.vertexShader.replace("#include <begin_vertex>", `
        float updateTime = time / 50.0;
        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));
        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));
        `);
  }
  get time() {
    return this._time.value;
  }
  set time(e) {
    this._time.value = e;
  }
  get distort() {
    return this._distort.value;
  }
  set distort(e) {
    this._distort.value = e;
  }
  get radius() {
    return this._radius.value;
  }
  set radius(e) {
    this._radius.value = e;
  }
}
const B6 = /* @__PURE__ */ Lt.forwardRef(({
  speed: i = 1,
  ...e
}, t) => {
  const [n] = Lt.useState(() => new z6());
  return aD((r) => n && (n.time = r.clock.elapsedTime * i)), /* @__PURE__ */ Lt.createElement("primitive", Cm({
    object: n,
    ref: t,
    attach: "material"
  }, e));
});
function V6(i, e) {
  const t = i + "Geometry";
  return /* @__PURE__ */ Lt.forwardRef(({
    args: n,
    children: r,
    ...o
  }, l) => {
    const u = Lt.useRef(null);
    return Lt.useImperativeHandle(l, () => u.current), Lt.useLayoutEffect(() => void (e == null ? void 0 : e(u.current))), /* @__PURE__ */ Lt.createElement("mesh", Cm({
      ref: u
    }, o), /* @__PURE__ */ Lt.createElement(t, {
      attach: "geometry",
      args: n
    }), r);
  });
}
const H6 = /* @__PURE__ */ V6("sphere"), k6 = () => /* @__PURE__ */ _n.jsx("mesh", { children: /* @__PURE__ */ _n.jsx(H6, { args: [1, 32, 32], scale: 1.5, children: /* @__PURE__ */ _n.jsx(
  B6,
  {
    color: "#4f46e5",
    attach: "material",
    distort: 0.5,
    speed: 2
  }
) }) }), G6 = ({ tours: i, onStart: e, onStepComplete: t, onComplete: n, onAbandon: r }) => {
  const [o, l] = qp(!0), [u, d] = qp(0), [h, m] = qp(!0), g = (i == null ? void 0 : i.steps) || [
    { title: "Welcome", content: "Welcome to our platform! Le me show you around.", id: "1" },
    { title: "Features", content: "Here are the key features you can use.", id: "2" },
    { title: "Dashboard", content: "Track your progress in the dashboard.", id: "3" },
    { title: "Settings", content: "Configure your account settings here.", id: "4" },
    { title: "Get Started", content: "You are all set! Click here to begin.", id: "5" }
  ], y = g[u];
  Hs(() => {
    const M = localStorage.getItem("tour-step");
    if (M) {
      const C = setTimeout(() => d(parseInt(M, 10)), 0);
      return () => clearTimeout(C);
    }
  }, []), Hs(() => {
    const M = localStorage.getItem("user"), C = M ? JSON.parse(M) : null, A = (i == null ? void 0 : i.id) || "demo_tour";
    e == null || e(A, C == null ? void 0 : C.id);
  }, []), Hs(() => {
    localStorage.setItem("tour-step", u.toString());
  }, [u]);
  const _ = () => {
    u < g.length - 1 ? (d(u + 1), t == null || t(y.id)) : T();
  }, E = () => {
    u > 0 && d(u - 1);
  }, w = () => {
    m(!1), localStorage.removeItem("tour-step"), r == null || r();
  }, T = () => {
    m(!1), localStorage.removeItem("tour-step"), n == null || n();
  };
  return h ? /* @__PURE__ */ _n.jsxs("div", { className: "fixed bottom-10 right-10 z-50 flex flex-col items-end gap-4 pointer-events-none", children: [
    /* @__PURE__ */ _n.jsx("div", { className: "w-24 h-24 pointer-events-auto cursor-pointer", onClick: () => l(!o), children: /* @__PURE__ */ _n.jsxs(cG, { children: [
      /* @__PURE__ */ _n.jsx("ambientLight", { intensity: 0.5 }),
      /* @__PURE__ */ _n.jsx("directionalLight", { position: [10, 10, 5], intensity: 1 }),
      /* @__PURE__ */ _n.jsx(k6, {}),
      /* @__PURE__ */ _n.jsx(I6, { enableZoom: !1, autoRotate: !0 })
    ] }) }),
    /* @__PURE__ */ _n.jsx(A6, { children: o && /* @__PURE__ */ _n.jsxs(
      x6.div,
      {
        initial: { opacity: 0, y: 20, scale: 0.9 },
        animate: { opacity: 1, y: 0, scale: 1 },
        exit: { opacity: 0, y: 20, scale: 0.9 },
        className: "bg-white p-6 rounded-xl shadow-2xl w-80 pointer-events-auto border border-indigo-100",
        children: [
          /* @__PURE__ */ _n.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
            /* @__PURE__ */ _n.jsx("h3", { className: "font-bold text-lg text-gray-800", children: y.title }),
            /* @__PURE__ */ _n.jsx("button", { onClick: () => l(!1), className: "text-gray-400 hover:text-gray-600", children: "" })
          ] }),
          /* @__PURE__ */ _n.jsx("p", { className: "text-gray-600 mb-4 text-sm leading-relaxed", children: y.content }),
          /* @__PURE__ */ _n.jsxs("div", { className: "flex items-center justify-between mt-4", children: [
            /* @__PURE__ */ _n.jsx("div", { className: "flex gap-1", children: g.map((M, C) => /* @__PURE__ */ _n.jsx(
              "div",
              {
                className: `h-1.5 w-1.5 rounded-full ${C === u ? "bg-indigo-600" : "bg-gray-200"}`
              },
              C
            )) }),
            /* @__PURE__ */ _n.jsxs("span", { className: "text-xs text-gray-400", children: [
              u + 1,
              " / ",
              g.length
            ] })
          ] }),
          /* @__PURE__ */ _n.jsxs("div", { className: "flex justify-between mt-6 pt-4 border-t border-gray-100", children: [
            /* @__PURE__ */ _n.jsx(
              "button",
              {
                onClick: w,
                className: "text-xs text-gray-400 hover:text-gray-600 font-medium",
                children: "Skip"
              }
            ),
            /* @__PURE__ */ _n.jsxs("div", { className: "flex gap-2", children: [
              /* @__PURE__ */ _n.jsx(
                "button",
                {
                  onClick: E,
                  disabled: u === 0,
                  className: "px-3 py-1.5 text-xs font-medium text-gray-600 bg-gray-100 rounded-lg hover:bg-gray-200 disabled:opacity-50",
                  children: "Back"
                }
              ),
              /* @__PURE__ */ _n.jsx(
                "button",
                {
                  onClick: _,
                  className: "px-3 py-1.5 text-xs font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700",
                  children: u === g.length - 1 ? "Finish" : "Next"
                }
              )
            ] })
          ] })
        ]
      }
    ) })
  ] }) : null;
};
let bE = document.getElementById("root");
if (!bE) {
  const i = document.createElement("div");
  i.id = "tour-widget-root", document.body.appendChild(i), bE = i;
}
Xp.createRoot(bE).render(
  /* @__PURE__ */ _n.jsx(kc.StrictMode, { children: /* @__PURE__ */ _n.jsx(G6, {}) })
);
